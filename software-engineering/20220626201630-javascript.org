:PROPERTIES:
:ID:       63bc8d8d-4fc8-4b34-8881-43ace1415a53
:END:
#+title: JavaScript
#+date: [2022-06-26 Sun 20:16]

** Introduction to JavaScript

console.log() prints to the console
    Data is printed, or logged, to the console, a panel that displays messages, with console.log().
  console.log("hello")

window.alert(); creates a popup
  window.alert("hello");


Built-in objects, including Math, are collections of methods and properties that JavaScript provides.


is case sensitive.
uses camelCasing
  starts with a lowercase letter for the first word
  but every word after the first word begins with a capital letter.
  There are no spaces between words.

  thisIsCamelCasing;
  alsoThisIsCamelCasing;
  andThisIsToo;
  camelCasingIsFun;
  youWillCamelCaseToo;

script.js: All your JavaScript code will be written here


JavaScript was written by Brendan Eich to enhance static web pages.
JavaScript was built specifically as a tool for the web rather than for building software.

Node.js - Node
Node, which was created by Ryan Dahl in 2009, allows you to run JavaScript projects on your machine.
It also allows you to configure the project environment.

JavaScript often abbreviated JS

JavaScript is a high-level, often just-in-time compiled language that conforms to the ECMAScript standard.
It has dynamic typing, prototype-based object-orientation, and first-class functions.
It is multi-paradigm, supporting event-driven, functional, and imperative programming styles.
It has application programming interfaces (APIs) for working with text, dates, regular expressions, standard data structures, and the Document Object Model (DOM).

The ECMAScript standard does not include any input/output (I/O), such as networking, storage, or graphics facilities. In practice, the web browser or other runtime system provides JavaScript APIs for I/O.

JavaScript engines were originally used only in web browsers, but are now core components of some servers and a variety of applications.
The most popular runtime system for this usage is Node.js.

** JavaScript Statements

JavaScript Programs
A computer program is a list of "instructions" to be "executed" by a computer.
In a programming language, these programming instructions are called statements.
A JavaScript program is a list of programming statements.
In HTML, JavaScript programs are executed by the web browser.

JavaScript Statements
JavaScript statements are composed of:
Values, Operators, Expressions, Keywords, and Comments.

Most JavaScript programs contain many JavaScript statements.
The statements are executed, one by one, in the same order as they are written.
JavaScript programs (and JavaScript statements) are often called JavaScript code.

Semicolons ;
Semicolons separate JavaScript statements.
Ending statements with semicolon is not required, but highly recommended.

JavaScript White Space
JavaScript ignores multiple spaces.
You can add white space to your script to make it more readable.


JavaScript Line Length and Line Breaks
For best readability, programmers often like to avoid code lines longer than 80 characters.
If a JavaScript statement does not fit on one line, the best place to break it is after an operator:

JavaScript Code Blocks
JavaScript statements can be grouped together in code blocks, inside curly brackets {...}.
The purpose of code blocks is to define statements to be executed together.

*** JavaScript Keywords

JavaScript statements often start with a keyword to identify the JavaScript action to be performed.

Our Reserved Words Reference lists all JavaScript keywords.

Here is a list of some of the keywords you will learn about in this tutorial:

JavaScript keywords are reserved words. Reserved words cannot be used as names for variables.

JavaScript Statement Identifiers

JavaScript statements often start with a statement identifier to identify the JavaScript action to be performed.

Statement identifiers are reserved words and cannot be used as variable names (or any other things).



The following table lists all JavaScript statement identifiers:

Statement 	Description

break; - Exits a switch or a loop
  break labelname; - optional label reference
a class is type object template
class className { // Declares a class
  // class body
}
const varName = val; - Declares a block readonly variable
continue; - Breaks one iteration (in the loop) if a specified condition occurs, and continues with the next iteration in the loop
  continue labelname; - optional label reference
debugger; - Stops the execution of JavaScript, and calls (if available) the debugging function
The do...while statements combo defines a code block to be executed once, and repeated as long as a condition is true.
The do...while is used when you want to run a code block at least one time.
do { // Executes a block of statements and repeats the block while a condition is true
  code block to be executed
}
while (condition);
for - defines a code block that is executed as long as a condition is true.
for (let i = 0; arr.length < i; i++){}
for...in - iterates (loops) over the properties of an object.
for (i in object){}
for...of - iterates (loops) over the values of any iterable.
for (i of array){}

function - Declares a function
function funcName(parameters) {}


if - a block of code to be executed if a condition is true:
if (condition) {
  // block of code to be executed if the condition is true
}

else - a block of code to be executed if the condition is false:
if (condition) {
  // block of code to be executed if the condition is true
} else {
  // block of code to be executed if the condition is false
}

else if - a new condition if the first condition is false:
if (condition1) {
  // block of code to be executed if condition1 is true
} else if (condition2) {
  // block of code to be executed if the condition1 is false and condition2 is true
} else {
  // block of code to be executed if the condition1 is false and condition2 is false
}

let name = value; - Declares a block variable
return value; - stops the execution of a function and returns a value.

switch - executes a block of code depending on different cases.
switch(expression){
  case n:
    code block
    break;
  case n:
    code block
    break;
  default:
    code block
}
throw expression; - statement defines a custom error.
  throw 	Throws (generates) an error

try...catch...finally - handles errors without stopping JavaScript.
try {
  tryCode - Code block to run
}
catch(err) {
  catchCode - Code block to handle errors
}
finally {
  finallyCode - Code block to be executed regardless of the try result
}

try - defines the code block to run (to try).
catch - defines a code block to handle any error.
finally - defines a code block to run regardless of the result.


var name = value; - Declares a variable
while - creates a loop (araund a code block) that is executed while a condition is true.
while (condition) {
  code block to be executed
}

*** js Statements Example

Example
let x, y, z;    // Statement 1
x = 5;          // Statement 2
y = 6;          // Statement 3
z = x + y;      // Statement 4

This statement tells the browser to write "Hello Dolly." inside an HTML element with id="demo":
Example
document.getElementById("demo").innerHTML = "Hello Dolly.";


Add a semicolon at the end of each executable statement:
Examples
let a, b, c;  // Declare 3 variables
a = 5;        // Assign the value 5 to a
b = 6;        // Assign the value 6 to b
c = a + b;    // Assign the sum of a and b to c

When separated by semicolons, multiple statements on one line are allowed:
a = 5; b = 6; c = a + b;


The following lines are equivalent:
let person = "Hege";
let person="Hege";

A good practice is to put spaces around operators ( = + - * / ):
let x = y + z;

If a JavaScript statement does not fit on one line, the best place to break it is after an operator:

Example
document.getElementById("demo").innerHTML =
"Hello Dolly!";
JavaScript Code Blocks

Example
document.getElementById("demo").innerHTML =
"Hello Dolly!";

One place you will find statements grouped together in blocks, is in JavaScript functions:
Example
function myFunction() {
  document.getElementById("demo1").innerHTML = "Hello Dolly!";
  document.getElementById("demo2").innerHTML = "How are you?";
}

** JavaScript Syntax

JavaScript syntax is the set of rules, how JavaScript programs are constructed:

JavaScript Values
The JavaScript syntax defines two types of values:
    Fixed values
    Variable values

Fixed values are called Literals.
Variable values are called Variables.

JavaScript Literals
The two most important syntax rules for fixed values are:
1. Numbers are written with or without decimals:
10.50
1001
1. Strings are text, written within double or single quotes:
"John Doe"
'John Doe'



JavaScript Expressions
An expression is a combination of values, variables, and operators, which computes to a value.
The computation is called an evaluation.
For example, 5 * 10 evaluates to 50:
5 * 10
Expressions can also contain variable values:
x * 10
The values can be of various types, such as numbers and strings.
For example, "John" + " " + "Doe", evaluates to "John Doe":
"John" + " " + "Doe"

JavaScript Keywords
JavaScript keywords are used to identify actions to be performed.
The let keyword tells the browser to create variables:
let x, y;
x = 5 + 6;
y = x * 10;
The var keyword also tells the browser to create variables:
var x, y;
x = 5 + 6;
y = x * 10;

In these examples, using var or let will produce the same result.
You will learn more about var and let later in this tutorial.


JavaScript Identifiers / Names
Identifiers are JavaScript names.
Identifiers are used to name variables and keywords, and functions.
The rules for legal names are the same in most programming languages.
A JavaScript name must begin with:
    A letter (A-Z or a-z)
    A dollar sign ($)
    Or an underscore (_)
Subsequent characters may be letters, digits, underscores, or dollar signs.
Note
Numbers are not allowed as the first character in names.
This way JavaScript can easily distinguish identifiers from numbers.

JavaScript is Case Sensitive
All JavaScript identifiers are case sensitive.
The variables lastName and lastname, are two different variables:
let lastname, lastName;
lastName = "Doe";
lastname = "Peterson";

JavaScript and Camel Case
Historically, programmers have used different ways of joining multiple words into one variable name:
Hyphens:
first-name, last-name, master-card, inter-city.
Hyphens are not allowed in JavaScript. They are reserved for subtractions.
Underscore:
first_name, last_name, master_card, inter_city.
Upper Camel Case (Pascal Case):
FirstName, LastName, MasterCard, InterCity.
Lower Camel Case:
JavaScript programmers tend to use camel case that starts with a lowercase letter:
firstName, lastName, masterCard, interCity.

JavaScript Character Set
JavaScript uses the Unicode character set.
Unicode covers (almost) all the characters, punctuations, and symbols in the world.


JavaScript Identifiers
All JavaScript variables must be identified with unique names.

These unique names are called identifiers.

Identifiers can be short names (like x and y) or more descriptive names (age, sum, totalVolume).

The general rules for constructing names for variables (unique identifiers) are:

    Names can contain letters, digits, underscores, and dollar signs.
    Names must begin with a letter
    Names can also begin with $ and _ (but we will not use it in this tutorial)
    Names are case sensitive (y and Y are different variables)
    Reserved words (like JavaScript keywords) cannot be used as names

Note
JavaScript identifiers are case-sensitive.

** what are javascript comments? wip

Comments are ignore when the program runs.
Comments are ignored, and will not be executed:

Comments allow you explain you code, in the code itself, without affecting your program.
JavaScript comments can be used to explain JavaScript code, and to make it more readable.

Reasons to use code comments:
+ To describe and explain complicated code and create reminders for yourself and others
+ To deliberately disable sections of code
+ To improve collaboration with other developers working on the code, helping them clearly understand what needs to be added, fixed, or removed in the code
+ To add titles to the sections of long pages of code to make the pages easier to scan
+ It's important to note that HTML and CSS comments are not tags. They also are not written in the same way; they have a distinct syntax.


JavaScript comments can also be used to prevent execution, when testing alternative code.

Single Line Comments
Single line comments start with //.

Multi-line Comments
Multi-line comments start with /* and end with */.

Any text between /* and */ will be ignored by JavaScript.

multi-line comment - a comment block.

Block comments are often used for formal documentation.
Using comments to prevent execution of code is suitable for code testing.

*** JavaScript Comments Examples
#+begin_src js
// single-line comment
/*
  muli-line comment
*/
#+end_src

** what are js variables? wip

Variables are containers for storing data (storing data values).

A variable behaves as if it was the value that it contains.

Variables hold reusable data in a program and associate it with a name.

Variables are stored in memory.


Variables allow computers to store and manipulate data in a dynamic fashion.
They do this by using a "label" to point to the data rather than using the data itself.

In computer science, data is anything that is meaningful to the computer.

Two steps:
  Declaration (var, let, const)
  Assignment (= assignment operator)




An equal sign is used to assign values to variables.



Declare JavaScript Variables
Declaring a JavaScript Variable

Creating a variable in JavaScript is called "declaring" a variable.

JavaScript uses the keywords var, let and const to declare variables.

After the declaration, the variable has no value (technically it is undefined).
A variable declared without a value will have the value undefined.

It's a good programming practice to declare all variables at the beginning of a script.


In computer programs, variables are often declared without a value.
The value can be something that has to be calculated, or something that will be provided later, like user input.



JavaScript Dollar Sign $
Since JavaScript treats a dollar sign as a letter, identifiers containing $ are valid variable names:
Example
let $ = "Hello World";
let $$$ = 2;
let $myMoney = 5;
Using the dollar sign is not very common in JavaScript, but professional programmers often use it as an alias for the main function in a JavaScript library.
In the JavaScript library jQuery, for instance, the main function $ is used to select HTML elements. In jQuery $("p"); means "select all p elements".

JavaScript Underscore (_)
Since JavaScript treats underscore as a letter, identifiers containing _ are valid variable names:
Example
let _lastName = "Johnson";
let _x = 2;
let _100 = 5;
Using the underscore is not very common in JavaScript, but a convention among professional programmers is to use it as an alias for "private (hidden)" variables.


 That's where const and let can help. They prevent developers from making unintended mistakes when declaring their variables.


What method should you use?

At this point, you might be wondering which method of declaring variables you should use. Here's the process that you should follow when determining whether to use let, const, or var:

    Use const primarily; this will be your go-to. Moving forward, you'll want to declare most of your variables using const.
    Use let if you need to reassign a value. This is a common requirement during for loops and sometimes with if statements.
    Don't use var unless necessary, like when working in a codebase that uses it. However, that will likely only happen in the distant future. As mentioned above, there are other reasons to use (and to not use) var, but those will be covered in a different lesson. For now, just avoid it.

    var makes variable global even in functions

Initializing Variables with the Assignment Operator
It is common to initialize a variable to an initial value in the same line as it is declared.
var myVar = 0;
Creates a new variable called myVar and assigns it an initial value of 0.
Define a variable a with var and initialize it to a value of 9.



Understanding Uninitialized Variables
When JavaScript variables are declared, they have an initial value of undefined.
If you do a mathematical operation on an undefined variable your result will be NaN which means "Not a Number".
If you concatenate a string with an undefined variable, you will get a string of undefined.

Compare Scopes of the var and let Keywords
If you are unfamiliar with let, check out this challenge about the difference bewteen let and var.
When you declare a variable with the var keyword, it is declared globally, or locally if declared inside a function.
The let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.
For example:
var numArray = [];
for (var i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Here the console will display the values [0, 1, 2] and 3.
With the var keyword, i is declared globally. So when i++ is executed, it updates the global variable. This code is similar to the following:
var numArray = [];
var i;
for (i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Here the console will display the values [0, 1, 2] and 3.
This behavior will cause problems if you were to create a function and store it for later use inside a for loop that uses the i variable. This is because the stored function will always refer to the value of the updated global i variable.
var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
Here the console will display the value 3.
As you can see, printNumTwo() prints 3 and not 2. This is because the value assigned to i was updated and the printNumTwo() returns the global i and not the value i had when the function was created in the for loop. The let keyword does not follow this behavior:
let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
console.log(i);
Here the console will display the value 2, and an error that i is not defined.
i is not defined because it was not declared in the global scope. It is only declared within the for loop statement. printNumTwo() returned the correct value because three different i variables with unique values (0, 1, and 2) were created by the let keyword within the loop statement.

*** var keyword

var keyword isnt used anymore, and you should avoid using them.
var variables can be re-declared and updated.
The var keyword is used in pre-ES6 versions of JS.
Explore Differences Between the var and let Keywords
One of the biggest problems with declaring variables with the var keyword is that you can easily overwrite variable declarations:
var camper = "James";
var camper = "David";
console.log(camper);
In the code above, the camper variable is originally declared as James, and is then overridden to be David.
The console then displays the string David.
In a small application, you might not run into this type of problem.
But as your codebase becomes larger, you might accidentally overwrite a variable that you did not intend to.
Because this behavior does not throw an error, searching for and fixing bugs becomes more difficult.


The var keyword
In the past, variables were declared with the keyword var.
Here is what var looks like in action:
var productName = "Jogger Sweatpants";
Just like with let, variables created with the var keyword can be reassigned.
However, var doesn't have the same restrictions as let when it comes to declaring variables with the same name.
See the example below:
var productName = "Jogger Sweatpants";
productName = "Men's Jogger Sweatpants";
var productName = "Woman's Jogger Sweatpants";
Because var is an older method of declaring variables, you will often see var referenced in older code.
However, you shouldn't use var in your code unless you have a very specific reason to do so.

*** let keyword

let variables, however, can be updated.
let is the preferred way to declare a variable when it can be reassigned
A keyword called let was introduced in ES6, a major update to JavaScript, to solve this potential issue with the var keyword.
If you replace var with let in the code above, it results in an error:
let camper = "James";
let camper = "David";
The error can be seen in your browser console.
So unlike var, when you use let, a variable with the same name can only be declared once.

JavaScript Let

The let keyword was introduced in ES6 (2015).

Variables defined with let cannot be Redeclared.

Variables defined with let must be Declared before use.

Variables defined with let have Block Scope.
Cannot be Redeclared

Variables defined with let cannot be redeclared.

You cannot accidentally redeclare a variable.

With let you can not do this:
Example
let x = "John Doe";

let x = 0;

// SyntaxError: 'x' has already been declared

With var you can:
Example
var x = "John Doe";

var x = 0;
Block Scope

Before ES6 (2015), JavaScript had only Global Scope and Function Scope.

ES6 introduced two important new JavaScript keywords: let and const.

These two keywords provide Block Scope in JavaScript.

Variables declared inside a { } block cannot be accessed from outside the block:
Example
{
  let x = 2;
}
// x can NOT be used here

Variables declared with the var keyword can NOT have block scope.

Variables declared inside a { } block can be accessed from outside the block.
Example
{
  var x = 2;
}
// x CAN be used here
Redeclaring Variables

Redeclaring a variable using the var keyword can impose problems.

Redeclaring a variable inside a block will also redeclare the variable outside the block:
Example
var x = 10;
// Here x is 10

{
var x = 2;
// Here x is 2
}

// Here x is 2

Redeclaring a variable using the let keyword can solve this problem.

Redeclaring a variable inside a block will not redeclare the variable outside the block:
Example
let x = 10;
// Here x is 10

{
let x = 2;
// Here x is 2
}

// Here x is 10
Browser Support

The let keyword is not fully supported in Internet Explorer 11 or earlier.

The following table defines the first browser versions with full support for the let keyword:

Chrome 49 	Edge 12 	Firefox 44 	Safari 11 	Opera 36
Mar, 2016 	Jul, 2015 	Jan, 2015 	Sep, 2017 	Mar, 2016
Redeclaring

Redeclaring a JavaScript variable with var is allowed anywhere in a program:
Example
var x = 2;
// Now x is 2

var x = 3;
// Now x is 3

With let, redeclaring a variable in the same block is NOT allowed:
Example
var x = 2;    // Allowed
let x = 3;    // Not allowed

{
let x = 2;    // Allowed
let x = 3     // Not allowed
}

{
let x = 2;    // Allowed
var x = 3     // Not allowed
}

Redeclaring a variable with let, in another block, IS allowed:
Example
let x = 2;    // Allowed

{
let x = 3;    // Allowed
}

{
let x = 4;    // Allowed
}
Let Hoisting

Variables defined with var are hoisted to the top and can be initialized at any time.

Meaning: You can use the variable before it is declared:
Example

This is OK:
carName = "Volvo";
var carName;

If you want to learn more about hoisting, study the chapter JavaScript Hoisting.

Variables defined with let are also hoisted to the top of the block, but not initialized.

Meaning: Using a let variable before it is declared will result in a ReferenceError:
Example
carName = "Saab";
let carName = "Volvo";


The variable total is declared with the let keyword.

This is a value that can be changed.
Just Like Algebra

Just like in algebra, variables hold values:
let x = 5;
let y = 6;

Just like in algebra, variables are used in expressions:
let z = x + y;

From the example above, you can guess that the total is calculated to be 11.

The let keyword
As you've learned, the let keyword is used to declare variables in JavaScript. Here's some refresher code for your review:
let price = 9.99;
You can also reassign variables that have already been created using let. Here's an example:
let price = 9.99;
price = 8.5;
However, if you declare a variable with let, you cannot use let to later define that same variable. See the error below:
let price = 9.99;
let price = 8.5; //> Uncaught SyntaxError: Identifier 'price' has already been declared
This SyntaxError is pretty useful. It will stop you from accidentally recreating the same variable later on in your program when you don't intend to do so.

*** const keyword

const keyword stand for constants
const keyword used to declare variables that can't be changed
  const pi = 3.14;
  pi = 3.1415; // This will throw an error because const variables can't be updated
const is the preferred way to declare a variable with a constant value.


Declare a Read-Only Variable with the const Keyword
const has all the awesome features that let has, with the added bonus that variables declared using const are read-only.
They are a constant value, which means that once a variable is assigned with const, it cannot be reassigned:
const FAV_PET = "Cats";
FAV_PET = "Dogs";
The console will display an error due to reassigning the value of FAV_PET.
You should always name variables you don't want to reassign using the const keyword.
This helps when you accidentally attempt to reassign a variable that is meant to stay constant.
Note: It is common for developers to use uppercase variable identifiers for immutable values and lowercase or camelCase for mutable values (objects and arrays).
You will learn more about objects, arrays, and immutable and mutable values in later challenges.
Also in later challenges, you will see examples of uppercase, lowercase, or camelCase variable identifiers.

JavaScript Const

The const keyword was introduced in ES6 (2015).

Variables defined with const cannot be Redeclared.

Variables defined with const cannot be Reassigned.

Variables defined with const have Block Scope.
Cannot be Reassigned

A const variable cannot be reassigned:
Example
const PI = 3.141592653589793;
PI = 3.14;      // This will give an error
PI = PI + 10;   // This will also give an error
Must be Assigned

JavaScript const variables must be assigned a value when they are declared:
Correct
const PI = 3.14159265359;
Incorrect
const PI;
PI = 3.14159265359;
When to use JavaScript const?

As a general rule, always declare a variable with const unless you know that the value will change.

Use const when you declare:

    A new Array
    A new Object
    A new Function
    A new RegExp

Constant Objects and Arrays

The keyword const is a little misleading.

It does not define a constant value. It defines a constant reference to a value.

Because of this you can NOT:

    Reassign a constant value
    Reassign a constant array
    Reassign a constant object

    But you CAN:
    Change the elements of constant array
    Change the properties of constant object

Constant Arrays

You can change the elements of a constant array:
Example
// You can create a constant array:
const cars = ["Saab", "Volvo", "BMW"];

// You can change an element:
cars[0] = "Toyota";

// You can add an element:
cars.push("Audi");

But you can NOT reassign the array:
Example
const cars = ["Saab", "Volvo", "BMW"];

cars = ["Toyota", "Volvo", "Audi"];    // ERROR
Constant Objects

You can change the properties of a constant object:
Example
// You can create a const object:
const car = {type:"Fiat", model:"500", color:"white"};

// You can change a property:
car.color = "red";

// You can add a property:
car.owner = "Johnson";

But you can NOT reassign the object:
Example
const car = {type:"Fiat", model:"500", color:"white"};

car = {type:"Volvo", model:"EX60", color:"red"};    // ERROR
Browser Support

The const keyword is not supported in Internet Explorer 10 or earlier.

The following table defines the first browser versions with full support for the const keyword:

Chrome 49 	IE 11 / Edge 	Firefox 36 	Safari 10 	Opera 36
Mar, 2016 	Oct, 2013 	Feb, 2015 	Sep, 2016 	Mar, 2016
Block Scope

Declaring a variable with const is similar to let when it comes to Block Scope.

The x declared in the block, in this example, is not the same as the x declared outside the block:
Example
const x = 10;
// Here x is 10

{
const x = 2;
// Here x is 2
}

// Here x is 10

You can learn more about block scope in the chapter JavaScript Scope.
Redeclaring

Redeclaring a JavaScript var variable is allowed anywhere in a program:
Example
var x = 2;     // Allowed
var x = 3;     // Allowed
x = 4;         // Allowed

Redeclaring an existing var or let variable to const, in the same scope, is not allowed:
Example
var x = 2;     // Allowed
const x = 2;   // Not allowed

{
let x = 2;     // Allowed
const x = 2;   // Not allowed
}

{
const x = 2;   // Allowed
const x = 2;   // Not allowed
}

Reassigning an existing const variable, in the same scope, is not allowed:
Example
const x = 2;     // Allowed
x = 2;           // Not allowed
var x = 2;       // Not allowed
let x = 2;       // Not allowed
const x = 2;     // Not allowed

{
  const x = 2;   // Allowed
  x = 2;         // Not allowed
  var x = 2;     // Not allowed
  let x = 2;     // Not allowed
  const x = 2;   // Not allowed
}

Redeclaring a variable with const, in another scope, or in another block, is allowed:
Example
const x = 2;       // Allowed

{
  const x = 3;   // Allowed
}

{
  const x = 4;   // Allowed
}
Const Hoisting

Variables defined with var are hoisted to the top and can be initialized at any time.

Meaning: You can use the variable before it is declared:
Example

This is OK:
carName = "Volvo";
var carName;

If you want to learn more about hoisting, study the chapter JavaScript Hoisting.

Variables defined with const are also hoisted to the top, but not initialized.

Meaning: Using a const variable before it is declared will result in a ReferenceError:
Example
alert (carName);
const carName = "Volvo";


When to Use JavaScript const?

If you want a general rule: always declare variables with const.

If you think the value of the variable can change, use let.

In this example, price1, price2, and total, are variables:
Example
const price1 = 5;
const price2 = 6;
let total = price1 + price2;

The two variables price1 and price2 are declared with the const keyword.

These are constant values and cannot be changed.


The const keyword
const size = "M";
const size = "L"; //> Uncaught SyntaxError: Identifier 'size' has already been declared
However, with const, you also can't reassign the value. See below:
const size = "M";
size = "S"; //> Uncaught TypeError: Assignment to constant variable.



Warning: Using const with arrays and objects
But const also has some other traits that are worth discussing.
And when it comes to arrays and objects, using const can be a bit tricky.

Take a look at the following code. It works as you may expect:
const product = { priceInCents: 2100, name: "Yellow Beanie", size: "M" };
product = { priceInCents: 2100, name: "Red Beanie", size: "L" };
//> Uncaught TypeError: Assignment to constant variable.
In the above case, you aren't able to reassign the value of const, as intended. The following code, on the other hand, does run.

const product = { priceInCents: 2100, name: "Yellow Beanie", size: "M" };
product.name = "Red Beanie";
product.size = "L";
Although you can't reassign the variable completely with const, you can change the values inside of the object. The same goes for arrays. Take a look:

const sizes = [8, 10, 12, 14];

sizes[4] = 16;

Mutate an Array Declared with const

If you are unfamiliar with const, check out this challenge about the const keyword.

The const declaration has many use cases in modern JavaScript.

Some developers prefer to assign all their variables using const by default, unless they know they will need to reassign the value. Only in that case, they use let.

However, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of the variable identifier.

const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);

s = [1, 2, 3] will result in an error. The console.log will display the value [5, 6, 45].

As you can see, you can mutate the object [5, 6, 7] itself and the variable s will still point to the altered array [5, 6, 45]. Like all arrays, the array elements in s are mutable, but because const was used, you cannot use the variable identifier s to point to a different array using the assignment operator.

An array is declared as const s = [5, 7, 2]. Change the array to [2, 5, 7] using various element assignments.

*** js Variables examples

#+begin_src js
// declare a variable myVar without initial value:
let myVar; // returns undefined
// assign myVar with value 11:
myVar = 11; // returns 11

// declaring and initializing a variable myVar with string foo
let myVar = "foo"; // returns foo

// declare a constants variables named PI with value 3.14
const PI = 3.14; // returns 3.14; readonly
// updating constant variable
PI = 11 // returns a error

// var keyword is bad practice
// declare a variable named myVar without initial value:
var myVar; // returns undefined
// assign myVar with value 33:
myVar = 33; // returns 33
// declaring and initializing a variable myVar with string foo
var myVar = "foo"; // returns foo

// Assigning the Value of One Variable to Another
// declare variable named myStr
let myStr; // returns undefined
// assign myVar to myStr:
myStr = myVar; // returns foo

#+end_src


In this example, x is defined as a variable. Then, x is assigned (given) the value 6:
let x;
x = 6;


In this example, x, y, and z, are variables, declared with the var keyword:
Example
var x = 5;
var y = 6;
var z = x + y;

In this example, x, y, and z, are variables, declared with the let keyword:
Example
let x = 5;
let y = 6;
let z = x + y;

In this example, x, y, and z, are undeclared variables:
Example
x = 5;
y = 6;
z = x + y;

From all the examples above, you can guess:

    x stores the value 5
    y stores the value 6
    z stores the value 11

You declare a JavaScript variable with the var or the let keyword:
var carName;
or:
let carName;

To assign a value to the variable, use the equal sign:
carName = "Volvo";

You can also assign a value to the variable when you declare it:
let carName = "Volvo";

One Statement, Many Variables
You can declare many variables in one statement.

Start the statement with let and separate the variables by comma:
Example
let person = "John Doe", carName = "Volvo", price = 200;

A declaration can span multiple lines:
Example
let person = "John Doe",
carName = "Volvo",
price = 200;
Value = undefined


Re-Declaring JavaScript Variables
If you re-declare a JavaScript variable declared with var, it will not lose its value.
The variable carName will still have the value "Volvo" after the execution of these statements:
Example
var carName = "Volvo";
var carName;
Note
You cannot re-declare a variable declared with let or const.

This will not work:
let carName = "Volvo";
let carName;

** javaScript data types and data structures wip

what is the difference between data types and data structures

Programming languages all have built-in data structures, but these often differ from one language to another.

This article attempts to list the built-in data structures available in JavaScript and what properties they have.
These can be used to build other data structures.
Wherever possible, comparisons with other languages are drawn.

Dynamic typing

JavaScript is a loosely typed and dynamic language. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:

let foo = 42;    // foo is now a number
foo     = 'bar'; // foo is now a string
foo     = true;  // foo is now a boolean

JavaScript types
The set of types in the JavaScript language consists of primitive values and objects.

Primitive values (immutable datum represented directly at the lowest level of the language)
  Boolean type
  Null type
  Undefined type
  Number type
  BigInt type
  String type
  Symbol type

Objects (collections of properties)


There are 7 fundamental data types in JavaScript: strings, numbers, booleans, null, undefined, symbol, and object.
The built-in arithmetic operators include +, -, *, /, and %.
Objects, including instances of data types, can have properties, stored information. The properties are denoted with a . after the name of the object, for example: 'Hello'.length.
Objects, including instances of data types, can have methods which perform actions. Methods are called by appending the object or instance with a period, the method name, and parentheses. For example: 'hello'.toUpperCase().
We can access properties and methods by using the ., dot operator.

JavaScript provides eight different data types which are undefined, null, boolean, string, symbol, bigint, number, and object.
has eight

Create Decimal Numbers with JavaScript
We can store decimal numbers in variables too. Decimal numbers are sometimes referred to as floating point numbers or floats.
Note: when you compute numbers, they are computed with finite precision. Operations using floating points may lead to different results than the desired outcome. If you are getting one of these results, open a topic on the freeCodeCamp forum.
Create a variable myDecimal and give it a decimal value with a fractional part (e.g. 5.7).

Data type
The type of value that a variable can have, such as string, number, or boolean
A data type is a value that variables can have in a given programming language

  String
  Number
  Boolean
  Null
    The null data type is used to indicate that a variable has no value. Sometimes, null is used as the default value when other data isn't available.
  Undefined
    The undefined data type is a special value that, in a way, means exactly that—that a variable was never defined. Like null, undefined means empty. But null and undefined have a slightly different understanding of emptiness.
    A null value means that the developer decided that the value was empty. It was a deliberate choice. An undefined value, on the other hand, means that the value was left empty, simply because nothing was ever assigned to it.
    That means that you shouldn't assign a variable undefined, like in this command: let variable = undefined.

Integer
Also called an int, a whole number that isn't written as a fraction or with a decimal point
Floating-point number
Also called a float, a number that includes a decimal point
Boolean
A binary variable with two possible values: true and false
  Pronounced not or bang, ! inverts a boolean value. This means that !false turns into true, and !true turns into false.
Coercion
The process of converting a value from one data type to another
  Number()
  parseInt()
  parseFloat()
  toString()

typeof, which is a built-in operator that JavaScript provides to reveal the data type of a particular value.
  console.log(typeof 2); // Number
  console.log(typeof "2");
  console.log(typeof true);



Use the parseInt Function
The parseInt() function parses a string and returns an integer. Here's an example:
const a = parseInt("007");
The above function converts the string 007 to the integer 7. If the first character in the string can't be converted into a number, then it returns NaN.
Use parseInt() in the convertToInteger function so it converts the input string str into an integer, and returns it.

Use the parseInt Function with a Radix
The parseInt() function parses a string and returns an integer. It takes a second argument for the radix, which specifies the base of the number in the string. The radix can be an integer between 2 and 36.
The function call looks like:
parseInt(string, radix);
And here's an example:
const a = parseInt("11", 2);
The radix variable says that 11 is in the binary system, or base 2. This example converts the string 11 to an integer 3.
Use parseInt() in the convertToInteger function so it converts a binary number to an integer and returns it.

  Null type
  BigInt type
  Symbol type

  JavaScript Data Types

JavaScript variables can hold different data types: numbers, strings, objects and more:
let length = 16;                               // Number
let lastName = "Johnson";                      // String
let x = {firstName:"John", lastName:"Doe"};    // Object
The Concept of Data Types

In programming, data types is an important concept.

To be able to operate on variables, it is important to know something about the type.

Without data types, a computer cannot safely solve this:
let x = 16 + "Volvo";

Does it make any sense to add "Volvo" to sixteen? Will it produce an error or will it produce a result?

JavaScript will treat the example above as:
let x = "16" + "Volvo";

When adding a number and a string, JavaScript will treat the number as a string.
Example
let x = 16 + "Volvo";
Example
let x = "Volvo" + 16;

JavaScript evaluates expressions from left to right. Different sequences can produce different results:
JavaScript:
let x = 16 + 4 + "Volvo";

Result:
20Volvo
JavaScript:
let x = "Volvo" + 16 + 4;

Result:
Volvo164

In the first example, JavaScript treats 16 and 4 as numbers, until it reaches "Volvo".

In the second example, since the first operand is a string, all operands are treated as strings.
JavaScript Types are Dynamic

JavaScript has dynamic types. This means that the same variable can be used to hold different data types:
Example
let x;           // Now x is undefined
x = 5;           // Now x is a Number
x = "John";      // Now x is a String
JavaScript Strings

A string (or a text string) is a series of characters like "John Doe".

Strings are written with quotes. You can use single or double quotes:
Example
let carName1 = "Volvo XC60";   // Using double quotes
let carName2 = 'Volvo XC60';   // Using single quotes

You can use quotes inside a string, as long as they don't match the quotes surrounding the string:
Example
let answer1 = "It's alright";             // Single quote inside double quotes
let answer2 = "He is called 'Johnny'";    // Single quotes inside double quotes
let answer3 = 'He is called "Johnny"';    // Double quotes inside single quotes

You will learn more about strings later in this tutorial.
JavaScript Numbers

JavaScript has only one type of numbers.

Numbers can be written with, or without decimals:
Example
let x1 = 34.00;     // Written with decimals
let x2 = 34;        // Written without decimals

Extra large or extra small numbers can be written with scientific (exponential) notation:
Example
let y = 123e5;      // 12300000
let z = 123e-5;     // 0.00123

You will learn more about numbers later in this tutorial.
JavaScript Booleans

Booleans can only have two values: true or false.
Example
let x = 5;
let y = 5;
let z = 6;
(x == y)       // Returns true
(x == z)       // Returns false

Booleans are often used in conditional testing.

You will learn more about conditional testing later in this tutorial.
JavaScript Arrays

JavaScript arrays are written with square brackets.

Array items are separated by commas.

The following code declares (creates) an array called cars, containing three items (car names):
Example
const cars = ["Saab", "Volvo", "BMW"];

Array indexes are zero-based, which means the first item is [0], second is [1], and so on.

You will learn more about arrays later in this tutorial.
JavaScript Objects

JavaScript objects are written with curly braces {}.

Object properties are written as name:value pairs, separated by commas.
Example
const person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};

The object (person) in the example above has 4 properties: firstName, lastName, age, and eyeColor.

You will learn more about objects later in this tutorial.
The typeof Operator

You can use the JavaScript typeof operator to find the type of a JavaScript variable.

The typeof operator returns the type of a variable or an expression:
Example
typeof ""             // Returns "string"
typeof "John"         // Returns "string"
typeof "John Doe"     // Returns "string"
Example
typeof 0              // Returns "number"
typeof 314            // Returns "number"
typeof 3.14           // Returns "number"
typeof (3)            // Returns "number"
typeof (3 + 4)        // Returns "number"

You will learn more about typeof later in this tutorial.
Undefined

In JavaScript, a variable without a value, has the value undefined. The type is also undefined.
Example
let car;    // Value is undefined, type is undefined

Any variable can be emptied, by setting the value to undefined. The type will also be undefined.
Example
car = undefined;    // Value is undefined, type is undefined
Empty Values

An empty value has nothing to do with undefined.

An empty string has both a legal value and a type.
Example
let car = "";    // The value is "", the typeof is "string"
Test Yourself With Exercises
Exercise:

Use comments to describe the correct data type of the following variables:

let length = 16;            //
let lastName = "Johnson";   //
const x = {
  firstName: "John",
  lastName: "Doe"
};                          //


Start the Exercise

** javascript strings wip

Strings are characters wrapped in single or double quotes

A sequence of letters, numerals, punctuation marks, or other characters, treated as text
Strings are used to represent text.
The data type is called a string because it's made up of a string of characters, such as letters, that are arranged in a line.

"your name" is called a string literal.
 string literal, or string, is a series of zero or more characters enclosed in single or double quotes.


Manipulate text

JavaScript Strings

JavaScript strings are for storing and manipulating text.

A JavaScript string is zero or more characters written inside quotes.
Example
let text = "John Doe";

You can use single or double quotes:
Example
let carName1 = "Volvo XC60";  // Double quotes
let carName2 = 'Volvo XC60';  // Single quotes

You can use quotes inside a string, as long as they don't match the quotes surrounding the string:
Example
let answer1 = "It's alright";
let answer2 = "He is called 'Johnny'";
let answer3 = 'He is called "Johnny"';
String Length

To find the length of a string, use the built-in length property:
Example
let text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let length = text.length;
Escape Character

Because strings must be written within quotes, JavaScript will misunderstand this string:
let text = "We are the so-called "Vikings" from the north.";

The string will be chopped to "We are the so-called ".

The solution to avoid this problem, is to use the backslash escape character.

The backslash (\) escape character turns special characters into string characters:
Code 	Result 	Description
\' 	' 	Single quote
\" 	" 	Double quote
\\ 	\ 	Backslash

The sequence \"  inserts a double quote in a string:

Example
let text = "We are the so-called \"Vikings\" from the north.";

The sequence \'  inserts a single quote in a string:

Example
let text= 'It\'s alright.';

The sequence \\  inserts a backslash in a string:

Example
let text = "The character \\ is called backslash.";

Six other escape sequences are valid in JavaScript:
Code 	Result
\b 	Backspace
\f 	Form Feed
\n 	New Line
\r 	Carriage Return
\t 	Horizontal Tabulator
\v 	Vertical Tabulator

The 6 escape characters above were originally designed to control typewriters, teletypes, and fax machines. They do not make any sense in HTML.
Breaking Long Code Lines

For best readability, programmers often like to avoid code lines longer than 80 characters.

If a JavaScript statement does not fit on one line, the best place to break it is after an operator:
Example
document.getElementById("demo").innerHTML =
"Hello Dolly!";

You can also break up a code line within a text string with a single backslash:
Example
document.getElementById("demo").innerHTML = "Hello \
Dolly!";

The \ method is not the preferred method. It might not have universal support.
Some browsers do not allow spaces behind the \ character.

A safer way to break up a string, is to use string addition:
Example
document.getElementById("demo").innerHTML = "Hello " +
"Dolly!";

You cannot break up a code line with a backslash:
Example
document.getElementById("demo").innerHTML = \
"Hello Dolly!";
JavaScript Strings as Objects

Normally, JavaScript strings are primitive values, created from literals:
let x = "John";

But strings can also be defined as objects with the keyword new:
let y = new String("John");
Example
let x = "John";
let y = new String("John");

Do not create Strings objects.

The new keyword complicates the code and slows down execution speed.

String objects can produce unexpected results:

When using the == operator, x and y are equal:
let x = "John";
let y = new String("John");

When using the === operator, x and y are not equal:
let x = "John";
let y = new String("John");

Note the difference between (x==y) and (x===y).

(x == y) true or false?
let x = new String("John");
let y = new String("John");

(x === y) true or false?
let x = new String("John");
let y = new String("John");

Comparing two JavaScript objects always returns false.
Complete String Reference

For a complete String reference, go to our:

Complete JavaScript String Reference.

The reference contains descriptions and examples of all string properties and methods.
Test Yourself With Exercises
Exercise:

Use the length property to alert the length of txt.

let txt = "Hello World!";
let x = ;
alert(x);

*** Escape Sequences in Strings

Escaping Literal Quotes in Strings with and without backslashes
'foo\'s bar'
"foo's bar"
'"Thats foo bar"'
"\"Thats foo bar \""

Quotes are not the only characters that can be escaped inside a string. There are two reasons to use escaping characters:
To allow you to use characters you may not otherwise be able to type out, such as a carriage return.
To allow you to represent multiple quotes in a string without JavaScript misinterpreting what you mean.
We learned this in the previous challenge.
Code	Output
\'	single quote
\"	double quote
\\	backslash
\n	newline
\r	carriage return
\t	tab
\b	word boundary
\f	form feed
Note that the backslash itself must be escaped in order to display as a backslash.
Assign the following three lines of text into the single variable myStr using escape sequences.
FirstLine
    \SecondLine
ThirdLine
You will need to use escape sequences to insert special characters correctly. You will also need to follow the spacing as it looks above, with no spaces between escape sequences or words.
Note: The indentation for SecondLine is achieved with the tab escape character, not spaces.

*** concatenation

The process of joining different values or pieces of text together

Concatenating Strings with Plus Operator
In JavaScript, when the + operator is used with a String value, it is called the concatenation operator. You can build a new string out of other strings by concatenating them together.
Example
'My name is Alan,' + ' I concatenate.'
Note: Watch out for spaces. Concatenation does not add spaces between concatenated strings, so you'll need to add them yourself.
Example:
const ourStr = "I come first. " + "I come second.";
The string I come first. I come second. would be displayed in the console.
Build myStr from the strings This is the start. and This is the end. using the + operator. Be sure to include a space between the two strings.

Concatenating Strings with the Plus Equals Operator
We can also use the += operator to concatenate a string onto the end of an existing string variable. This can be very helpful to break a long string over several lines.
Note: Watch out for spaces. Concatenation does not add spaces between concatenated strings, so you'll need to add them yourself.
Example:
let ourStr = "I come first. ";
ourStr += "I come second.";
ourStr now has a value of the string I come first. I come second..
Build myStr over several lines by concatenating these two strings: This is the first sentence. and This is the second sentence. using the += operator. Use the += operator similar to how it is shown in the example and be sure to include a space between the two strings. Start by assigning the first string to myStr, then add on the second string.

Constructing Strings with Variables
Sometimes you will need to build a string. By using the concatenation operator (+), you can insert one or more variables into a string you're building.
Example:
const ourName = "freeCodeCamp";
const ourStr = "Hello, our name is " + ourName + ", how are you?";
ourStr would have a value of the string Hello, our name is freeCodeCamp, how are you?.
Set myName to a string equal to your name and build myStr with myName between the strings My name is and and I am well!

Appending Variables to Strings
Just as we can build a string over multiple lines out of string literals, we can also append variables to a string using the plus equals (+=) operator.
Example:
const anAdjective = "awesome!";
let ourStr = "freeCodeCamp is ";
ourStr += anAdjective;
ourStr would have the value freeCodeCamp is awesome!.
Set someAdjective to a string of at least 3 characters and append it to myStr using the += operator.

*** bracket Notation

Use Bracket Notation to Find the First Character in a String
Bracket notation is a way to get a character at a specific index within a string.
Most modern programming languages, like JavaScript, don't start counting at 1 like humans do. They start at 0. This is referred to as Zero-based indexing.
For example, the character at index 0 in the word Charles is C. So if const firstName = "Charles", you can get the value of the first letter of the string by using firstName[0].
Example:
const firstName = "Charles";
const firstLetter = firstName[0];
firstLetter would have a value of the string C.
Use bracket notation to find the first character in the lastName variable and assign it to firstLetterOfLastName.

Understand String Immutability
In JavaScript, String values are immutable, which means that they cannot be altered once created.
For example, the following code:
let myStr = "Bob";
myStr[0] = "J";
cannot change the value of myStr to Job, because the contents of myStr cannot be altered. Note that this does not mean that myStr cannot be changed, just that the individual characters of a string literal cannot be changed. The only way to change myStr would be to assign it with a new string, like this:
let myStr = "Bob";
myStr = "Job";
Correct the assignment to myStr so it contains the string value of Hello World using the approach shown in the example above.

Use Bracket Notation to Find the Nth Character in a String
You can also use bracket notation to get the character at other positions within a string.
Remember that computers start counting at 0, so the first character is actually the zeroth character.
Example:
const firstName = "Ada";
const secondLetterOfFirstName = firstName[1];
secondLetterOfFirstName would have a value of the string d.
Let's try to set thirdLetterOfLastName to equal the third letter of the lastName variable using bracket notation.
Hint: Try looking at the example above if you get stuck.

Use Bracket Notation to Find the Last Character in a String
In order to get the last letter of a string, you can subtract one from the string's length.
For example, if const firstName = "Ada", you can get the value of the last letter of the string by using firstName[firstName.length - 1].
Example:
const firstName = "Ada";
const lastLetter = firstName[firstName.length - 1];
lastLetter would have a value of the string a.
Use bracket notation to find the last character in the lastName variable.
Hint: Try looking at the example above if you get stuck.

Use Bracket Notation to Find the Nth-to-Last Character in a String
You can use the same principle we just used to retrieve the last character in a string to retrieve the Nth-to-last character.
For example, you can get the value of the third-to-last letter of the const firstName = "Augusta" string by using firstName[firstName.length - 3]
Example:
const firstName = "Augusta";
const thirdToLastLetter = firstName[firstName.length - 3];
thirdToLastLetter would have a value of the string s.
Use bracket notation to find the second-to-last character in the lastName string.
Hint: Try looking at the example above if you get stuck.

*** String methods and properties

String methods help you to work with strings.

Primitive values, like "John Doe", cannot have properties or methods (because they are not objects).
But with JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties.

JavaScript String Methods

String methods help you to work with strings.
String Methods and Properties

Primitive values, like "John Doe", cannot have properties or methods (because they are not objects).

But with JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties.
JavaScript String Length

The length property returns the length of a string:
Example
let txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let length = txt.length;
Extracting String Parts

There are 3 methods for extracting a part of a string:

    slice(start, end)
    substring(start, end)
    substr(start, length)

JavaScript String slice()

slice() extracts a part of a string and returns the extracted part in a new string.

The method takes 2 parameters: the start position, and the end position (end not included).
Example

Slice out a portion of a string from position 7 to position 13 (13 not included):
let str = "Apple, Banana, Kiwi";
let part = str.slice(7, 13);
Note

JavaScript counts positions from zero.

First position is 0.

Second position is 1.

If a parameter is negative, the position is counted from the end of the string.

This example slices out a portion of a string from position -12 to position -6:
Example
let str = "Apple, Banana, Kiwi";
let part = str.slice(-12, -6);

If you omit the second parameter, the method will slice out the rest of the string:
Example
let part = str.slice(7);

or, counting from the end:
Example
let part = str.slice(-12);
JavaScript String substring()

substring() is similar to slice().

The difference is that start and end values less than 0 are treated as 0 in substring().
Example
let str = "Apple, Banana, Kiwi";
let part = str.substring(7, 13);

If you omit the second parameter, substring() will slice out the rest of the string.
JavaScript String substr()

substr() is similar to slice().

The difference is that the second parameter specifies the length of the extracted part.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(7, 6);

If you omit the second parameter, substr() will slice out the rest of the string.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(7);

If the first parameter is negative, the position counts from the end of the string.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(-4);
Replacing String Content

The replace() method replaces a specified value with another value in a string:
Example
let text = "Please visit Microsoft!";
let newText = text.replace("Microsoft", "W3Schools");
Note

The replace() method does not change the string it is called on.

The replace() method returns a new string.

The replace() method replaces only the first match

If you want to replace all matches, use a regular expression with the /g flag set. See examples below.

By default, the replace() method replaces only the first match:
Example
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace("Microsoft", "W3Schools");

By default, the replace() method is case sensitive. Writing MICROSOFT (with upper-case) will not work:
Example
let text = "Please visit Microsoft!";
let newText = text.replace("MICROSOFT", "W3Schools");

To replace case insensitive, use a regular expression with an /i flag (insensitive):
Example
let text = "Please visit Microsoft!";
let newText = text.replace(/MICROSOFT/i, "W3Schools");

Note

Regular expressions are written without quotes.

To replace all matches, use a regular expression with a /g flag (global match):
Example
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace(/Microsoft/g, "W3Schools");

Note

You will learn a lot more about regular expressions in the chapter JavaScript Regular Expressions.
Converting to Upper and Lower Case

A string is converted to upper case with toUpperCase():

A string is converted to lower case with toLowerCase():
JavaScript String toUpperCase()
Example
let text1 = "Hello World!";
let text2 = text1.toUpperCase();
JavaScript String toLowerCase()
Example
let text1 = "Hello World!";       // String
let text2 = text1.toLowerCase();  // text2 is text1 converted to lower
JavaScript String concat()

concat() joins two or more strings:
Example
let text1 = "Hello";
let text2 = "World";
let text3 = text1.concat(" ", text2);

The concat() method can be used instead of the plus operator. These two lines do the same:
Example
text = "Hello" + " " + "World!";
text = "Hello".concat(" ", "World!");
Note

All string methods return a new string. They don't modify the original string.

Formally said:

Strings are immutable: Strings cannot be changed, only replaced.
JavaScript String trim()

The trim() method removes whitespace from both sides of a string:
Example
let text1 = "      Hello World!      ";
let text2 = text1.trim();
JavaScript String Padding

ECMAScript 2017 added two String methods: padStart() and padEnd() to support padding at the beginning and at the end of a string.
JavaScript String padStart()

The padStart() method pads a string with another string:
Example
let text = "5";
let padded = text.padStart(4,"x");
Example
let text = "5";
let padded = text.padStart(4,"0");
Note

The padStart() method is a string method.

To pad a number, convert the number to a string first.

See the example below.
Example
let numb = 5;
let text = numb.toString();
let padded = text.padStart(4,"0");
Browser Support

padStart() is an ECMAScript 2017 feature.

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

padStart() is not supported in Internet Explorer.
JavaScript String padEnd()

The padEnd() method pads a string with another string:
Example
let text = "5";
let padded = text.padEnd(4,"x");
Example
let text = "5";
let padded = text.padEnd(4,"0");
Note

The padEnd() method is a string method.

To pad a number, convert the number to a string first.

See the example below.
Example
let numb = 5;
let text = numb.toString();
let padded = text.padEnd(4,"0");
Browser Support

padEnd() is an ECMAScript 2017 feature.

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

padEnd() is not supported in Internet Explorer.
Extracting String Characters

There are 3 methods for extracting string characters:

    charAt(position)
    charCodeAt(position)
    Property access [ ]

JavaScript String charAt()

The charAt() method returns the character at a specified index (position) in a string:
Example
let text = "HELLO WORLD";
let char = text.charAt(0);
JavaScript String charCodeAt()

The charCodeAt() method returns the unicode of the character at a specified index in a string:

The method returns a UTF-16 code (an integer between 0 and 65535).
Example
let text = "HELLO WORLD";
let char = text.charCodeAt(0);
Property Access

ECMAScript 5 (2009) allows property access [ ] on strings:
Example
let text = "HELLO WORLD";
let char = text[0];
Note

Property access might be a little unpredictable:

    It makes strings look like arrays (but they are not)
    If no character is found, [ ] returns undefined, while charAt() returns an empty string.
    It is read only. str[0] = "A" gives no error (but does not work!)

Example
let text = "HELLO WORLD";
text[0] = "A";    // Gives no error, but does not work
Converting a String to an Array

If you want to work with a string as an array, you can convert it to an array.
JavaScript String split()

A string can be converted to an array with the split() method:
Example
text.split(",")    // Split on commas
text.split(" ")    // Split on spaces
text.split("|")    // Split on pipe

If the separator is omitted, the returned array will contain the whole string in index [0].

If the separator is "", the returned array will be an array of single characters:
Example
text.split("")
Complete String Reference

For a complete String reference, go to our:

Complete JavaScript String Reference.

The reference contains descriptions and examples of all string properties and methods.





Method
A function that is attached to an object as one of the object's attributes

"STR".toLowerCase();
"str".replace("str", "Str");
toLowerCase(): This returns a string with all the letters lowercase.
toUpperCase(): This returns a string with all the letters capitalized.
trim(): This removes whitespace (spaces, tabs, and so forth) at the beginning and end of a string.
replace(): This replaces part of a string with another string
  replace(matchingString, newString)

  Extracting String Parts

There are 3 methods for extracting a part of a string:

    slice(start, end)
    substring(start, end)
    substr(start, length)

JavaScript String slice()

slice() extracts a part of a string and returns the extracted part in a new string.

The method takes 2 parameters: the start position, and the end position (end not included).
Example

Slice out a portion of a string from position 7 to position 13 (13 not included):
let str = "Apple, Banana, Kiwi";
let part = str.slice(7, 13);
Note

JavaScript counts positions from zero.

First position is 0.

Second position is 1.

If a parameter is negative, the position is counted from the end of the string.

This example slices out a portion of a string from position -12 to position -6:
Example
let str = "Apple, Banana, Kiwi";
let part = str.slice(-12, -6);

If you omit the second parameter, the method will slice out the rest of the string:
Example
let part = str.slice(7);

or, counting from the end:
Example
let part = str.slice(-12);
JavaScript String substring()

substring() is similar to slice().

The difference is that start and end values less than 0 are treated as 0 in substring().
Example
let str = "Apple, Banana, Kiwi";
let part = str.substring(7, 13);

If you omit the second parameter, substring() will slice out the rest of the string.
JavaScript String substr()

substr() is similar to slice().

The difference is that the second parameter specifies the length of the extracted part.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(7, 6);

If you omit the second parameter, substr() will slice out the rest of the string.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(7);

If the first parameter is negative, the position counts from the end of the string.
Example
let str = "Apple, Banana, Kiwi";
let part = str.substr(-4);
Replacing String Content

The replace() method replaces a specified value with another value in a string:
Example
let text = "Please visit Microsoft!";
let newText = text.replace("Microsoft", "W3Schools");
Note

The replace() method does not change the string it is called on.

The replace() method returns a new string.

The replace() method replaces only the first match

If you want to replace all matches, use a regular expression with the /g flag set. See examples below.

By default, the replace() method replaces only the first match:
Example
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace("Microsoft", "W3Schools");

By default, the replace() method is case sensitive. Writing MICROSOFT (with upper-case) will not work:
Example
let text = "Please visit Microsoft!";
let newText = text.replace("MICROSOFT", "W3Schools");

To replace case insensitive, use a regular expression with an /i flag (insensitive):
Example
let text = "Please visit Microsoft!";
let newText = text.replace(/MICROSOFT/i, "W3Schools");

Note

Regular expressions are written without quotes.

To replace all matches, use a regular expression with a /g flag (global match):
Example
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace(/Microsoft/g, "W3Schools");

Note

You will learn a lot more about regular expressions in the chapter JavaScript Regular Expressions.
Converting to Upper and Lower Case

A string is converted to upper case with toUpperCase():

A string is converted to lower case with toLowerCase():
JavaScript String toUpperCase()
Example
let text1 = "Hello World!";
let text2 = text1.toUpperCase();
JavaScript String toLowerCase()
Example
let text1 = "Hello World!";       // String
let text2 = text1.toLowerCase();  // text2 is text1 converted to lower
JavaScript String concat()

concat() joins two or more strings:
Example
let text1 = "Hello";
let text2 = "World";
let text3 = text1.concat(" ", text2);

The concat() method can be used instead of the plus operator. These two lines do the same:
Example
text = "Hello" + " " + "World!";
text = "Hello".concat(" ", "World!");
Note

All string methods return a new string. They don't modify the original string.

Formally said:

Strings are immutable: Strings cannot be changed, only replaced.
JavaScript String trim()

The trim() method removes whitespace from both sides of a string:
Example
let text1 = "      Hello World!      ";
let text2 = text1.trim();
JavaScript String Padding

ECMAScript 2017 added two String methods: padStart() and padEnd() to support padding at the beginning and at the end of a string.
JavaScript String padStart()

The padStart() method pads a string with another string:
Example
let text = "5";
let padded = text.padStart(4,"x");
Example
let text = "5";
let padded = text.padStart(4,"0");
Note

The padStart() method is a string method.

To pad a number, convert the number to a string first.

See the example below.
Example
let numb = 5;
let text = numb.toString();
let padded = text.padStart(4,"0");
Browser Support

padStart() is an ECMAScript 2017 feature.

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

padStart() is not supported in Internet Explorer.
JavaScript String padEnd()

The padEnd() method pads a string with another string:
Example
let text = "5";
let padded = text.padEnd(4,"x");
Example
let text = "5";
let padded = text.padEnd(4,"0");
Note

The padEnd() method is a string method.

To pad a number, convert the number to a string first.

See the example below.
Example
let numb = 5;
let text = numb.toString();
let padded = text.padEnd(4,"0");
Browser Support

padEnd() is an ECMAScript 2017 feature.

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

padEnd() is not supported in Internet Explorer.
Extracting String Characters

There are 3 methods for extracting string characters:

    charAt(position)
    charCodeAt(position)
    Property access [ ]

JavaScript String charAt()

The charAt() method returns the character at a specified index (position) in a string:
Example
let text = "HELLO WORLD";
let char = text.charAt(0);
JavaScript String charCodeAt()

The charCodeAt() method returns the unicode of the character at a specified index in a string:

The method returns a UTF-16 code (an integer between 0 and 65535).
Example
let text = "HELLO WORLD";
let char = text.charCodeAt(0);
Property Access

ECMAScript 5 (2009) allows property access [ ] on strings:
Example
let text = "HELLO WORLD";
let char = text[0];
Note

Property access might be a little unpredictable:

    It makes strings look like arrays (but they are not)
    If no character is found, [ ] returns undefined, while charAt() returns an empty string.
    It is read only. str[0] = "A" gives no error (but does not work!)

Example
let text = "HELLO WORLD";
text[0] = "A";    // Gives no error, but does not work
Converting a String to an Array

If you want to work with a string as an array, you can convert it to an array.
JavaScript String split()

A string can be converted to an array with the split() method:
Example
text.split(",")    // Split on commas
text.split(" ")    // Split on spaces
text.split("|")    // Split on pipe

If the separator is omitted, the returned array will contain the whole string in index [0].

If the separator is "", the returned array will be an array of single characters:
Example
text.split("")
Complete String Reference

For a complete String reference, go to our:

Complete JavaScript String Reference.

The reference contains descriptions and examples of all string properties and methods.

JavaScript String Reference
JavaScript Strings

A JavaScript string stores a series of characters like "John Doe".

A string can be any text inside double or single quotes:
let carName1 = "Volvo XC60";
let carName2 = 'Volvo XC60';

String indexes are zero-based:

The first character is in position 0, the second in 1, and so on.

For a tutorial about Strings, read our JavaScript String Tutorial.
String Properties and Methods

Normally, strings like "John Doe", cannot have methods or properties because they are not objects.

But with JavaScript, methods and properties are also available to strings, because JavaScript treats strings as objects when executing methods and properties.

JavaScript String Search
JavaScript Search Methods

    String indexOf()
    String lastIndexOf()
    String startsWith()
    String endsWith()

JavaScript String indexOf()

The indexOf() method returns the index of (the position of) the first occurrence of a specified text in a string:
Example
let str = "Please locate where 'locate' occurs!";
str.indexOf("locate");
Note

JavaScript counts positions from zero.

0 is the first position in a string, 1 is the second, 2 is the third, ...
JavaScript String lastIndexOf()

The lastIndexOf() method returns the index of the last occurrence of a specified text in a string:
Example
let str = "Please locate where 'locate' occurs!";
str.lastIndexOf("locate");

Both indexOf(), and lastIndexOf() return -1 if the text is not found:
Example
let str = "Please locate where 'locate' occurs!";
str.lastIndexOf("John");

Both methods accept a second parameter as the starting position for the search:
Example
let str = "Please locate where 'locate' occurs!";
str.indexOf("locate", 15);

The lastIndexOf() methods searches backwards (from the end to the beginning), meaning: if the second parameter is 15, the search starts at position 15, and searches to the beginning of the string.
Example
let str = "Please locate where 'locate' occurs!";
str.lastIndexOf("locate", 15);
JavaScript String search()

The search() method searches a string for a specified value and returns the position of the match:
Example
let str = "Please locate where 'locate' occurs!";
str.search("locate");
Did You Notice?

The two methods, indexOf() and search(), are equal?

They accept the same arguments (parameters), and return the same value?

The two methods are NOT equal. These are the differences:

    The search() method cannot take a second start position argument.
    The indexOf() method cannot take powerful search values (regular expressions).

You will learn more about regular expressions in a later chapter.
JavaScript String match()

The match() method searches a string for a match against a regular expression, and returns the matches, as an Array object.
Example 1

Search a string for "ain":
let text = "The rain in SPAIN stays mainly in the plain";
text.match(/ain/g);

Read more about regular expressions in the chapter JS RegExp.
Note

If a regular expression does not include the g modifier (to perform a global search), the match() method will return only the first match in the string.
Syntax
string.match(regexp)
regexp 	Required. The value to search for, as a regular expression.
Returns: 	An Array, containing the matches, one item for each match, or null if no match is found
Example 2

Perform a global, case-insensitive search for "ain":
let text = "The rain in SPAIN stays mainly in the plain";
text.match(/ain/gi);
JavaScript String includes()

The includes() method returns true if a string contains a specified value.
Example
let text = "Hello world, welcome to the universe.";
text.includes("world");
Syntax
string.includes(searchvalue, start)
searchvalue 	Required. The string to search for
start 	Optional. Default 0. Position to start the search
Returns: 	Returns true if the string contains the value, otherwise false
JS Version: 	ES6 (2015)

Check if a string includes "world", starting the search at position 12:
let text = "Hello world, welcome to the universe.";
text.includes("world", 12);
Browser Support

includes() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

includes() is not supported in Internet Explorer.
JavaScript String startsWith()

The startsWith() method returns true if a string begins with a specified value, otherwise false:
Example
let text = "Hello world, welcome to the universe.";

text.startsWith("Hello");
Syntax
string.startsWith(searchvalue, start)
Parameter Values
Parameter 	Description
searchvalue 	Required. The value to search for.
start 	Optional. Default 0. The position to start the search.
Examples
let text = "Hello world, welcome to the universe.";

text.startsWith("world")    // Returns false
let text = "Hello world, welcome to the universe.";

text.startsWith("world", 5)    // Returns false
let text = "Hello world, welcome to the universe.";

text.startsWith("world", 6)    // Returns true
Note

The startsWith() method is case sensitive.
Browser Support

startsWith() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

startsWith() is not supported in Internet Explorer.
JavaScript String endsWith()

The endsWith() method returns true if a string ends with a specified value, otherwise false:
Example

Check if a string ends with "Doe":
let text = "John Doe";
text.endsWith("Doe");
Syntax
string.endsWith(searchvalue, length)
Parameter Values
Parameter 	Description
searchvalue 	Required. The value to search for.
length 	Optional. The length to search.

Check if the 11 first characters of a string ends with "world":
let text = "Hello world, welcome to the universe.";
text.endsWith("world", 11);

Note

The endsWith() method is case sensitive.
Browser Support

endsWith() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

endsWith() is not supported in Internet Explorer.


JavaScript String Methods
Method 	Description
charAt() 	Returns the character at a specified index (position)
charCodeAt() 	Returns the Unicode of the character at a specified index
concat() 	Returns two or more joined strings

endsWith() method
+ The endsWith() method returns true if a string ends with a specified value.
+ Otherwise it returns false.
+ The endsWith() method is case sensitive.
+ string.endsWith(searchvalue, length)
+ searchvalue	Required. The string to search for.
+ length	Optional. The length of the string to search. Default value is the length of the string.
+ A boolean :	true if the string ends with the value, otherwise false.

#+begin_src js
let text = "Hello world";
// check if text ends with world
let result = text.endsWith("world"); // returns true
let text1 = "Hello World";
// check if text1 ends with world
let result1 = text1.endsWith("world"); // returns false; case sensitive

let text2 = "Hello world, welcome to the universe.";
let result2 = text2.endsWith("world", 11);
#+end_src

fromCharCode() 	Returns Unicode values as characters
includes() 	Returns if a string contains a specified value
indexOf() 	Returns the index (position) of the first occurrence of a value in a string
lastIndexOf() 	Returns the index (position) of the last occurrence of a value in a string
localeCompare() 	Compares two strings in the current locale
match() 	Searches a string for a value, or a regular expression, and returns the matches
repeat() 	Returns a new string with a number of copies of a string
replace() 	Searches a string for a value, or a regular expression, and returns a string where the values are replaced
search() 	Searches a string for a value, or regular expression, and returns the index (position) of the match
slice() 	Extracts a part of a string and returns a new string
split() 	Splits a string into an array of substrings
startsWith() 	Checks whether a string begins with specified characters
substr() 	Extracts a number of characters from a string, from a start index (position)
substring() 	Extracts characters from a string, between two specified indices (positions)
toLocaleLowerCase() 	Returns a string converted to lowercase letters, using the host's locale
toLocaleUpperCase() 	Returns a string converted to uppercase letters, using the host's locale
toLowerCase() 	Returns a string converted to lowercase letters
toString() 	Returns a string or a string object as a string
toUpperCase() 	Returns a string converted to uppercase letters
trim() 	Returns a string with removed whitespaces
valueOf() 	Returns the primitive value of a string or a string object

Note
All string methods return a new value.
They do not change the original variable.

**** JavaScript String Properties

constructor property
+ The constructor property returns the string's constructor function
+ The constructor property returns the function that created the String prototype.
+ constructor returns: function String() { [native code] }
+ string.constructor

length property
+ The length property returns the length of a string
+ The length property of an empty string is 0.
+ string.length
+ return value is number that's length of the string.

You can find the length of a String value by writing .length after the string variable or string literal.

#+begin_src js
let myStr = "foo"; // returns foo
// store the length of myStr into strLength
let strLength = myStr.length; // returns 3
let myStr = ""; // returns empty string
let strLength = myStr.length; // returns 0
print to console the string buzz length
console.log("buzz".length); // returns 4
#+end_src

The prototype property :: Allows you to add properties and methods to an object

**** String HTML Wrapper Methods

HTML wrapper methods return a string wrapped inside an HTML tag.

These are not standard methods, and may not work as expected.
Method 	Description
anchor() 	Displays a string as an anchor
big() 	Displays a string using a big font
blink() 	Displays a blinking string
bold() 	Displays a string in bold
fixed() 	Displays a string using a fixed-pitch font
fontcolor() 	Displays a string using a specified color
fontsize() 	Displays a string using a specified size
italics() 	Displays a string in italic
link() 	Displays a string as a hyperlink
small() 	Displays a string using a small font
strike() 	Displays a string with a strikethrough
sub() 	Displays a string as subscript text
sup() 	Displays a string as superscript text

*** JavaScript Template Literals

Synonyms:

    Template Literals
    Template Strings
    String Templates
    Back-Tics Syntax

Back-Tics Syntax

Template Literals use back-ticks (``) rather than the quotes ("") to define a string:
Example
let text = `Hello World!`;

Quotes Inside Strings

With template literals, you can use both single and double quotes inside a string:
Example
let text = `He's often called "Johnny"`;

Multiline Strings

Template literals allows multiline strings:
Example
let text =
`The quick
brown fox
jumps over
the lazy dog`;

Interpolation

Template literals provide an easy way to interpolate variables and expressions into strings.

The method is called string interpolation.

The syntax is:
${...}
Variable Substitutions

Template literals allow variables in strings:
Example
let firstName = "John";
let lastName = "Doe";

let text = `Welcome ${firstName}, ${lastName}!`;

Automatic replacing of variables with real values is called string interpolation.
Expression Substitution

Template literals allow expressions in strings:
Example
let price = 10;
let VAT = 0.25;

let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;

Automatic replacing of expressions with real values is called string interpolation.
HTML Templates
Example
let header = "Templates Literals";
let tags = ["template literals", "javascript", "es6"];

let html = `<h2>${header}</h2><ul>`;
for (const x of tags) {
  html += `<li>${x}</li>`;
}

html += `</ul>`;

Browser Support

Template Literals is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

Template Literals is not supported in Internet Explorer.
Complete String Reference

For a complete String reference, go to our:

Complete JavaScript String Reference.

The reference contains descriptions and examples of all string properties and methods.

*** strings thinkful

1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to access parts of a string with bracket notation and methods. You'll also be able to create an array from a string, join arrays into strings, and write strings that embed expressions using template literals.
Overview

In this lesson, you'll learn more about how to write strings in JavaScript and explore new ways to access different parts of a string. You'll also learn how to transform a string into an array.
Key Terms

Template literal
    A JavaScript feature that makes string concatenation, embedded expressions, and formatting easier

Remember when you first started learning about JavaScript data types? Now that you're familiar with some of the basics, you're ready to dive deeper into one specific data type: the string.
Accessing strings

As you know, a string data type is used to represent text. Strings are set off in quotes, and they can contain a variety of characters, such as letters, numbers, and symbols. So when it comes to accessing strings, you'll essentially be targeting individual characters in order to perform a specific task.

Take a look at the following string. What do you see?

const pangram = "The Five Boxing Wizards Jump Quickly.";

As you may have noticed, the pangram string uses every letter of the alphabet. The string is also written in Title Case—in other words, the first letter of every word is uppercase. Imagine you want to update this string so that it's in Sentence case, which means that only the first letter of the sentence is uppercase. How might you do that? You'd follow these general steps:

    Make sure that the first letter of the sentence is uppercase.

    Make all other letters lowercase.

To do this, you'll need to access individual characters in the string.
Characters: A refresher

Before moving forward, you may need a quick refresher on characters. As mentioned above, characters in strings can be alphanumeric characters, punctuation marks, spaces between words, or other types of symbols that increase the length of the string. Consider the example from above:

const pangram = "The Five Boxing Wizards Jump Quickly.";

pangram.length; //> 37

The pangram string is 37 characters long. That includes the period . and empty spaces between words, but not the double quotes (" and ") enclosing the string. You'll learn a bit more about how to work with quotes in strings below.
Bracket notation

Back to the task at hand: changing this string from title case into sentence case. One way that you could do this is by using bracket notation. Just like with arrays, bracket notation can be used to access individual characters at any given index of a string. Here's an example of how bracket notation can be used:

const word = "Wizards";

word[0]; //> "W"

word[2]; //> "z"

word[9]; //> undefined

Now, take a look at the following function, which will solve the case problem that you've been given. What do you notice?

function sentenceCase(sentence) {

  const firstCharacter = sentence[0];

  let result = firstCharacter.toUpperCase();


  for (let i = 1; i < sentence.length; i++) {

    const character = sentence[i];

    result += character.toLowerCase();

  }


  return result;

}

Take a moment to walk through the above code. Here's what it's doing:

    It creates a new variable called firstCharacter. It sets firstCharacter to be equal to the first character of the inputted sentence string, using bracket notation.

    It creates a new variable called result. It sets that variable to be equal to the firstCharacter variable, set to uppercase with the toUpperCase() method.

    It begins a for loop, which starts at an index of 1, thus skipping over the first character of the sentence.

    In the for loop, the variable character is created, which is set to be equal to sentence[i]. With bracket notation, you can access each character of a string, just like you would each item of an array.

    The code adds the character to the result variable, setting it to lowercase at the same time.

    Finally, return result will return the result for you.

The substr() method

But bracket notation is just one approach. You can also solve your casing problem using a built-in JavaScript method, called the substr() method, which will actually make this process a little easier. Check out the code sample below:

function sentenceCase(sentence) {

  const first = sentence.substr(0, 1);

  const rest = sentence.substr(1);


  return first.toUpperCase() + rest.toLowerCase();

}

The substr() method, also called the substring method, allows you to extract a specific section of characters in a string. It takes two arguments:

    The index of the first character to include in the substring

    The number of characters to extract

The above function works as follows:

    It sets the first variable to be equal to only the first character. In other words, substr(0, 1) means that the substring will begin on index 0 and only include 1 character.

    It sets the rest variable to be equal to every character starting from the first index. If you do not include a second argument, like in substr(1), the substring will consist of every character following the given index.

    It joins the two strings together, using toUpperCase() and toLowerCase() as appropriate.

Do this
Use substr()

Time to try it yourself. Take a look at the following examples of substr(). Before running the code on your own, evaluate the code in your head and predict what will happen.

const title = "Guards! Guards!";

// Use console.log(); to see the output

title.substr(3); //> ?

title.substr(6, 4); //> ?

title.substr(25); //> ?

Splitting and joining strings

Now that you've looked at a couple of ways to access string characters, take a step back to analyze the functions at work here.

As the name suggests, the sentenceCase() function could be described as one that capitalizes the first character in a string and sets all other characters to lowercase. That's what you were trying to do above. But you could also reuse this function to create a titleize() function in order to turn phrases into titles (with title case formatting). For example, you could expect the titleize() function to work like this:

const title = "the light FANTASTIC";

titleize(title); //> "The Light Fantastic";

There are a few ways to accomplish this task. Below is one approach that makes use of the split() and join() methods, seen below.

function titleize(title) {

  const words = title.split(" ");

  let result = [];


  for (let i = 0; i < words.length; i++) {

    const capitalized = sentenceCase(words[i]);

    result.push(capitalized);

  }


  return result.join(" ");

}


titleize("the light FANTASTIC"); //> "The Light Fantastic"

In the code sample above, the split() method separates the string based on the string given to it as an argument. Here's an example:

const title = "the light FANTASTIC";

title.split(" "); //> [ "the", "light", "FANTASTIC" ]

The argument given to split() is a string with a space. Therefore, an array is created in which each new item is separated by the string. Notice that in the resulting array above, all of the spaces have been removed.

Now, take a look at the join() method. The join() method is called on an array and joins all the elements in that array together with the supplied argument. In the case of the titleize() function, the join() joins all the capitalized words into a single string, separated by spaces.

const result = ["The", "Light", "Fantastic"];

result.join(" "); //> "The Light Fantastic";

If you want to learn more, check out the Mozilla Developer Network (MDN) resources on the split() method and the join() method.
Do this
Use split() and join()

Take a look at the following examples of split() and join(). Before running the code on your own, evaluate the code in your head and predict what will happen.

const title = "Guards! Guards!";

title.split("!"); //> ?

title.split(""); //> ?

title.split("guards"); //> ?


const titleArr = ["The", "Light", "Fantastic"];

titleArr.join("-"); //> ?

titleArr.join("_-_"); //> ?

titleArr.join(); //> ?

Template literals

Joining together multiple strings can end up looking pretty messy. Previously, you've had to concatenate multiple parts of a string with the + operator to accomplish this task. Take a look at how the following function concatenates strings.

function bookSale(title, priceInCents) {

  const price = (priceInCents / 100).toFixed(2);

  return titleize(title) + " is on sale for $" + price + ".";

}


bookSale("the light fantastic", 950); //> "The Light Fantastic is on sale for $9.50."

The above function works, but it doesn't look that great. Fortunately, JavaScript has a feature called template literals, which can help make this function look cleaner and clearer. Check it out:

function bookSale(title, priceInCents) {

  const price = (priceInCents / 100).toFixed(2);

  return `${titleize(title)} is on sale for $${price}.`;

}

Template literals allow you to embed expressions and avoid using multiple + operators just to join a string. The syntax of a template literal is seen here: `${titleize(title)} is on sale for $${price}.` Here are the key pieces:

    Begin and end your string using backticks, which look like this `. They are accessible on the tilde ~ key on your keyboard.

    Place variables or expressions inside of curly braces {}, which should be preceded by a dollar sign $. It should look like this: ${}.

Do this
Use template literals

Given the variables below, construct a string using template literals that results in the following sentence.

The price of 'Interesting Times' by Terry Pratchett is $8.99.

const title = "Interesting Times";

const author = "Terry Pratchett";

const price = 8.99;

If you're having trouble, you can peek at the answer below.

`The price of '${title}' by ${author} is $${price}.`;

Escaping strings

When reviewing older code, you may see examples like the snippet below:

const firstSentence = "Will tugged at his mother's hand and said, \"Come on, come on...\"";

This string was created with double quotes, but that there are also double quotes in the string. The backslash \ that you see here is used to escape the string.

Escaping a string means that you're providing a backslash to allow for the following character to be seen as part of the string rather than part of the syntax. In the example above, the \ tells JavaScript that it should treat this double quote as part of the string, not as the closing quotation.

The sample string above is just fine. But as you've learned, template literals offer a better way to write it:

const firstSentence = `Will tugged at his mother's hand and said, "Come on, come on..."`;

** js Numbers wip

Numbers are any number without quotes: 23.8879

JavaScript Numbers

JavaScript has only one type of number. Numbers can be written with or without decimals.
Example
let x = 3.14;    // A number with decimals
let y = 3;       // A number without decimals

Extra large or extra small numbers can be written with scientific (exponent) notation:
Example
let x = 123e5;    // 12300000
let y = 123e-5;   // 0.00123

JavaScript Numbers are Always 64-bit Floating Point

Unlike many other programming languages, JavaScript does not define different types of numbers, like integers, short, long, floating-point etc.

JavaScript numbers are always stored as double precision floating point numbers, following the international IEEE 754 standard.

This format stores numbers in 64 bits, where the number (the fraction) is stored in bits 0 to 51, the exponent in bits 52 to 62, and the sign in bit 63:
Value (aka Fraction/Mantissa) 	Exponent 	Sign
52 bits (0 - 51)  	11 bits (52 - 62) 	1 bit (63)
Integer Precision

Integers (numbers without a period or exponent notation) are accurate up to 15 digits.
Example
let x = 999999999999999;   // x will be 999999999999999
let y = 9999999999999999;  // y will be 10000000000000000

The maximum number of decimals is 17.
Floating Precision

Floating point arithmetic is not always 100% accurate:
let x = 0.2 + 0.1;

To solve the problem above, it helps to multiply and divide:
let x = (0.2 * 10 + 0.1 * 10) / 10;
Adding Numbers and Strings

WARNING !!

JavaScript uses the + operator for both addition and concatenation.

Numbers are added. Strings are concatenated.

If you add two numbers, the result will be a number:
Example
let x = 10;
let y = 20;
let z = x + y;

If you add two strings, the result will be a string concatenation:
Example
let x = "10";
let y = "20";
let z = x + y;

If you add a number and a string, the result will be a string concatenation:
Example
let x = 10;
let y = "20";
let z = x + y;

If you add a string and a number, the result will be a string concatenation:
Example
let x = "10";
let y = 20;
let z = x + y;

A common mistake is to expect this result to be 30:
Example
let x = 10;
let y = 20;
let z = "The result is: " + x + y;

A common mistake is to expect this result to be 102030:
Example
let x = 10;
let y = 20;
let z = "30";
let result = x + y + z;

The JavaScript interpreter works from left to right.

First 10 + 20 is added because x and y are both numbers.

Then 30 + "30" is concatenated because z is a string.
Numeric Strings

JavaScript strings can have numeric content:
let x = 100;         // x is a number

let y = "100";       // y is a string

JavaScript will try to convert strings to numbers in all numeric operations:

This will work:
let x = "100";
let y = "10";
let z = x / y;

This will also work:
let x = "100";
let y = "10";
let z = x * y;

And this will work:
let x = "100";
let y = "10";
let z = x - y;

But this will not work:
let x = "100";
let y = "10";
let z = x + y;

In the last example JavaScript uses the + operator to concatenate the strings.
NaN - Not a Number

NaN is a JavaScript reserved word indicating that a number is not a legal number.

Trying to do arithmetic with a non-numeric string will result in NaN (Not a Number):
Example
let x = 100 / "Apple";

However, if the string contains a numeric value , the result will be a number:
Example
let x = 100 / "10";

You can use the global JavaScript function isNaN() to find out if a value is a not a number:
Example
let x = 100 / "Apple";
isNaN(x);

Watch out for NaN. If you use NaN in a mathematical operation, the result will also be NaN:
Example
let x = NaN;
let y = 5;
let z = x + y;

Or the result might be a concatenation like NaN5:
Example
let x = NaN;
let y = "5";
let z = x + y;

NaN is a number: typeof NaN returns number:
Example
typeof NaN;
Infinity

Infinity (or -Infinity) is the value JavaScript will return if you calculate a number outside the largest possible number.
Example
let myNumber = 2;
// Execute until Infinity
while (myNumber != Infinity) {
  myNumber = myNumber * myNumber;
}

Division by 0 (zero) also generates Infinity:
Example
let x =  2 / 0;
let y = -2 / 0;

Infinity is a number: typeof Infinity returns number.
Example
typeof Infinity;
Hexadecimal

JavaScript interprets numeric constants as hexadecimal if they are preceded by 0x.
Example
let x = 0xFF;

Never write a number with a leading zero (like 07).
Some JavaScript versions interpret numbers as octal if they are written with a leading zero.

By default, JavaScript displays numbers as base 10 decimals.

But you can use the toString() method to output numbers from base 2 to base 36.

Hexadecimal is base 16. Decimal is base 10. Octal is base 8. Binary is base 2.
Example
let myNumber = 32;
myNumber.toString(32);
myNumber.toString(16);
myNumber.toString(12);
myNumber.toString(10);
myNumber.toString(8);
myNumber.toString(2);
JavaScript Numbers as Objects

Normally JavaScript numbers are primitive values created from literals:
let x = 123;

But numbers can also be defined as objects with the keyword new:
let y = new Number(123);
Example
let x = 123;
let y = new Number(123);

Do not create Number objects.

The new keyword complicates the code and slows down execution speed.

Number Objects can produce unexpected results:

When using the == operator, x and y are equal:
let x = 500;
let y = new Number(500);

When using the === operator, x and y are not equal.
let x = 500;
let y = new Number(500);

Note the difference between (x==y) and (x===y).

(x == y) true or false?
let x = new Number(500);
let y = new Number(500);

(x === y) true or false?
let x = new Number(500);
let y = new Number(500);

Comparing two JavaScript objects always returns false.
Complete JavaScript Number Reference

For a complete Number reference, visit our:

Complete JavaScript Number Reference.

The reference contains descriptions and examples of all Number properties and methods.

*** JavaScript Number Methods

Number methods help you work with numbers.
Number Methods and Properties

Primitive values (like 3.14 or 2014), cannot have properties and methods (because they are not objects).

But with JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties.
The toString() Method

The toString() method returns a number as a string.

All number methods can be used on any type of numbers (literals, variables, or expressions):
Example
let x = 123;
x.toString();
(123).toString();
(100 + 23).toString();
The toExponential() Method

toExponential() returns a string, with a number rounded and written using exponential notation.

A parameter defines the number of characters behind the decimal point:
Example
let x = 9.656;
x.toExponential(2);
x.toExponential(4);
x.toExponential(6);

The parameter is optional. If you don't specify it, JavaScript will not round the number.
The toFixed() Method

toFixed() returns a string, with the number written with a specified number of decimals:
Example
let x = 9.656;
x.toFixed(0);
x.toFixed(2);
x.toFixed(4);
x.toFixed(6);

toFixed(2) is perfect for working with money.
The toPrecision() Method

toPrecision() returns a string, with a number written with a specified length:
Example
let x = 9.656;
x.toPrecision();
x.toPrecision(2);
x.toPrecision(4);
x.toPrecision(6);
The valueOf() Method

valueOf() returns a number as a number.
Example
let x = 123;
x.valueOf();
(123).valueOf();
(100 + 23).valueOf();

In JavaScript, a number can be a primitive value (typeof = number) or an object (typeof = object).

The valueOf() method is used internally in JavaScript to convert Number objects to primitive values.

There is no reason to use it in your code.

All JavaScript data types have a valueOf() and a toString() method.
Converting Variables to Numbers

There are 3 JavaScript methods that can be used to convert variables to numbers:

    The Number() method
    The parseInt() method
    The parseFloat() method

These methods are not number methods, but global JavaScript methods.
Global JavaScript Methods

JavaScript global methods can be used on all JavaScript data types.

These are the most relevant methods, when working with numbers:
Method 	Description
Number() 	Returns a number, converted from its argument.
parseFloat() 	Parses its argument and returns a floating point number
parseInt() 	Parses its argument and returns an integer
The Number() Method

Number() can be used to convert JavaScript variables to numbers:
Example
Number(true);
Number(false);
Number("10");
Number("  10");
Number("10  ");
Number(" 10  ");
Number("10.33");
Number("10,33");
Number("10 33");
Number("John");

If the number cannot be converted, NaN (Not a Number) is returned.
The Number() Method Used on Dates

Number() can also convert a date to a number.
Example
Number(new Date("1970-01-01"))

The Number() method returns the number of milliseconds since 1.1.1970.

The number of milliseconds between 1970-01-02 and 1970-01-01 is 86400000:
Example
Number(new Date("1970-01-02"))
Example
Number(new Date("2017-09-30"))
The parseInt() Method

parseInt() parses a string and returns a whole number. Spaces are allowed. Only the first number is returned:
Example
parseInt("-10");
parseInt("-10.33");
parseInt("10");
parseInt("10.33");
parseInt("10 20 30");
parseInt("10 years");
parseInt("years 10");

If the number cannot be converted, NaN (Not a Number) is returned.
The parseFloat() Method

parseFloat() parses a string and returns a number. Spaces are allowed. Only the first number is returned:
Example
parseFloat("10");
parseFloat("10.33");
parseFloat("10 20 30");
parseFloat("10 years");
parseFloat("years 10");

If the number cannot be converted, NaN (Not a Number) is returned.
Number Properties
Property 	Description
MAX_VALUE 	Returns the largest number possible in JavaScript
MIN_VALUE 	Returns the smallest number possible in JavaScript
POSITIVE_INFINITY 	Represents infinity (returned on overflow)
NEGATIVE_INFINITY 	Represents negative infinity (returned on overflow)
NaN 	Represents a "Not-a-Number" value
JavaScript MIN_VALUE and MAX_VALUE

MAX_VALUE returns the largest possible number in JavaScript.
Example
let x = Number.MAX_VALUE;

MIN_VALUE returns the lowest possible number in JavaScript.
Example
let x = Number.MIN_VALUE;
JavaScript POSITIVE_INFINITY
Example
let x = Number.POSITIVE_INFINITY;

POSITIVE_INFINITY is returned on overflow:
Example
let x = 1 / 0;
JavaScript NEGATIVE_INFINITY
Example
let x = Number.NEGATIVE_INFINITY;

NEGATIVE_INFINITY is returned on overflow:
Example
let x = -1 / 0;
JavaScript NaN - Not a Number
Example
let x = Number.NaN;

NaN is a JavaScript reserved word indicating that a number is not a legal number.

Trying to do arithmetic with a non-numeric string will result in NaN (Not a Number):
Example
let x = 100 / "Apple";

Number Properties Cannot be Used on Variables

Number properties belongs to the JavaScript's number object wrapper called Number.

These properties can only be accessed as Number.MAX_VALUE.

Using myNumber.MAX_VALUE, where myNumber is a variable, expression, or value, will return undefined:
Example
let x = 6;
x.MAX_VALUE
Complete JavaScript Number Reference

For a complete Number reference, visit our:

Complete JavaScript Number Reference.

The reference contains descriptions and examples of all Number properties and methods.

** boolean

Understanding Boolean Values
Another data type is the Boolean. Booleans may only be one of two values: true or false. They are basically little on-off switches, where true is on and false is off. These two states are mutually exclusive.
Note: Boolean values are never written with quotes. The strings "true" and "false" are not Boolean and have no special meaning in JavaScript.
Modify the welcomeToBooleans function so that it returns true instead of false when the run button is clicked.


Mathematical assignment operators make it easy to calculate a new value and assign it to the same variable.
The + operator is used to concatenate strings including string values held in variables.
In ES6, template literals use backticks ` and ${} to interpolate values into a string.
The typeof keyword returns the data type (as a string) of a value.

JavaScript Booleans

A JavaScript Boolean represents one of two values: true or false.
Boolean Values

Very often, in programming, you will need a data type that can only have one of two values, like

    YES / NO
    ON / OFF
    TRUE / FALSE

For this, JavaScript has a Boolean data type. It can only take the values true or false.
The Boolean() Function

You can use the Boolean() function to find out if an expression (or a variable) is true:
Example
Boolean(10 > 9)

Or even easier:
Example
(10 > 9)
10 > 9
Comparisons and Conditions

The chapter JS Comparisons gives a full overview of comparison operators.

The chapter JS Conditions gives a full overview of conditional statements.

Here are some examples:
Operator 	Description 	Example
== 	equal to 	if (day == "Monday")
> 	greater than 	if (salary > 9000)
< 	less than 	if (age < 18)

The Boolean value of an expression is the basis for all JavaScript comparisons and conditions.
Everything With a "Value" is True
Examples
100

3.14

-15

"Hello"

"false"

7 + 1 + 3.14
Everything Without a "Value" is False

The Boolean value of 0 (zero) is false:
let x = 0;
Boolean(x);

The Boolean value of -0 (minus zero) is false:
let x = -0;
Boolean(x);

The Boolean value of "" (empty string) is false:
let x = "";
Boolean(x);

The Boolean value of undefined is false:
let x;
Boolean(x);

The Boolean value of null is false:
let x = null;
Boolean(x);

The Boolean value of false is (you guessed it) false:
let x = false;
Boolean(x);

The Boolean value of NaN is false:
let x = 10 / "Hallo";
Boolean(x);
JavaScript Booleans as Objects

Normally JavaScript booleans are primitive values created from literals:
let x = false;

But booleans can also be defined as objects with the keyword new:
let y = new Boolean(false);
Example
let x = false;
let y = new Boolean(false);

// typeof x returns boolean
// typeof y returns object

Do not create Boolean objects.

The new keyword complicates the code and slows down execution speed.

Boolean objects can produce unexpected results:

When using the == operator, x and y are equal:
let x = false;
let y = new Boolean(false);

When using the === operator, x and y are not equal:
let x = false;
let y = new Boolean(false);

Note the difference between (x==y) and (x===y).

(x == y) true of false?
let x = new Boolean(false);
let y = new Boolean(false);

(x === y) true of false?
let x = new Boolean(false);
let y = new Boolean(false);

Comparing two JavaScript objects always return false.
Complete Boolean Reference

For a complete reference, go to our Complete JavaScript Boolean Reference.

The reference contains descriptions and examples of all Boolean properties and methods.

** js array

an array is a special variable, that can store more than one value.
an element is a value in an array.
arrays use zero-based indexing

Store Multiple Values in one Variable using JavaScript Arrays
nested array
This is also called a multi-dimensional array.

An array is a special variable, which can hold more than one value:
An array can hold many values under a single name, and you can access the values by referring to an index number.


Mutation A change in the original data value


Arrays are Objects
Arrays are a special type of objects. The typeof operator in JavaScript returns "object" for arrays.


Associative Arrays
Many programming languages support arrays with named indexes.

Arrays with named indexes are called associative arrays (or hashes).

JavaScript does not support arrays with named indexes.

In JavaScript, arrays always use numbered indexes.
Example
const person = [];
person[0] = "John";
person[1] = "Doe";
person[2] = 46;
person.length;    // Will return 3
person[0];        // Will return "John"

WARNING !!
If you use named indexes, JavaScript will redefine the array to an object.

After that, some array methods and properties will produce incorrect results.
 Example:
const person = [];
person["firstName"] = "John";
person["lastName"] = "Doe";
person["age"] = 46;
person.length;     // Will return 0
person[0];         // Will return undefined

The Difference Between Arrays and Objects
In JavaScript, arrays use numbered indexes.
In JavaScript, objects use named indexes.

Arrays are a special kind of objects, with numbered indexes.
When to Use Arrays. When to use Objects.
    JavaScript does not support associative arrays.
    You should use objects when you want the element names to be strings (text).
    You should use arrays when you want the element names to be numbers.


How to Recognize an Array
A common question is: How do I know if a variable is an array?

The problem is that the JavaScript operator typeof returns "object":
const fruits = ["Banana", "Orange", "Apple"];
let type = typeof fruits;

The typeof operator returns object because a JavaScript array is an object.
Solution 1:

To solve this problem ECMAScript 5 (JavaScript 2009) defined a new method Array.isArray():
Array.isArray(fruits);
Solution 2:

The instanceof operator returns true if an object is created by a given constructor:
const fruits = ["Banana", "Orange", "Apple"];

fruits instanceof Array;

Stand in Line
In Computer Science a queue is an abstract Data Structure where items are kept in order. New items can be added at the back of the queue and old items are taken off from the front of the queue.
Write a function nextInLine which takes an array (arr) and a number (item) as arguments.
Add the number to the end of the array, then remove the first element of the array.
The nextInLine function should then return the element that was removed.
*** js array create

create/declare array/array literal


array Syntax:
const arrName = [ele1, ele2, ...];

It is a common practice to declare arrays with the const keyword.


Spaces and line breaks are not important. A declaration can span multiple lines:


Using the JavaScript Keyword new
The following example also creates an Array, and assigns values to it:
Example
const cars = new Array("Saab", "Volvo", "BMW");
The two examples above do exactly the same.
There is no need to use new Array().
For simplicity, readability and execution speed, use the array literal method.

*** js array access

Access Array Data with Indexes
arrayBracketnotation
array[0]

Modify Array Data With Indexes
Unlike strings, the entries of arrays are mutable and can be changed freely, even if the array was declared with const.
Note: There shouldn't be any spaces between the array name and the square brackets, like array [0]. Although JavaScript is able to process this correctly, this may confuse other programmers reading your code.

Access Multi-Dimensional Arrays With Indexes
One way to think of a multi-dimensional array, is as an array of arrays. When you use brackets to access your array, the first set of brackets refers to the entries in the outer-most (the first level) array, and each additional pair of brackets refers to the next level of entries inside.
Example
const arr = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [[10, 11, 12], 13, 14]
];
arr[3];
arr[3][0];
arr[3][0][1];
arr[3] is [[10, 11, 12], 13, 14], arr[3][0] is [10, 11, 12], and arr[3][0][1] is 11.
Note: There shouldn't be any spaces between the array name and the square brackets, like array [0][0] and even this array [0] [0] is not allowed. Although JavaScript is able to process this correctly, this may confuse other programmers reading your code.
Using bracket notation select an element from myArray such that myData is equal to 8.


Accessing Nested Arrays
As we have seen in earlier examples, objects can contain both nested objects and nested arrays. Similar to accessing nested objects, array bracket notation can be chained to access nested arrays.
Here is an example of how to access a nested array:
const ourPets = [
  {
    animalType: "cat",
    names: [
      "Meowzer",
      "Fluffy",
      "Kit-Cat"
    ]
  },
  {
    animalType: "dog",
    names: [
      "Spot",
      "Bowser",
      "Frankie"
    ]
  }
];
ourPets[0].names[1];
ourPets[1].names[0];
ourPets[0].names[1] would be the string Fluffy, and ourPets[1].names[0] would be the string Spot.
Using dot and bracket notation, set the variable secondTree to the second item in the trees list from the myPlants object.

Accessing Array Elements

You access an array element by referring to the index number:
const cars = ["Saab", "Volvo", "BMW"];
let car = cars[0];

Note: Array indexes start with 0.

[0] is the first element. [1] is the second element.
Changing an Array Element

This statement changes the value of the first element in cars:
cars[0] = "Opel";
Example
const cars = ["Saab", "Volvo", "BMW"];
cars[0] = "Opel";
Access the Full Array

With JavaScript, the full array can be accessed by referring to the array name:
Example
const cars = ["Saab", "Volvo", "BMW"];
document.getElementById("demo").innerHTML = cars;

*** js array examples
#+begin_src js
// const arrName = [ele1, ele2, ...];

// declare an empty array; named myArr
const myArr = [];
// declare an array; named myArr with strings foo, bar and buzz
const myArr = ["foo", "bar", "buzz"];
// declare an array that span multiple line
// array named myArr; element are strings foo, bar, buzz
const myArr = [
    "foo",
    "bar",
    "buzz"
];
const myArr []; // an empty array
// add strings foo, bar, buzz to myArr using bracket notation
myArr[0] = "foo";
myArr[1] = "bar";
myArr[2] = "buzz";
const myArr = [["Bulls", 23], ["White", 45]]; // nest array; multi-dimensional array.

// access myArr elements using bracket notation.
const myArr = [50, 60, 70];
// access first element
array[0]; // 50
// access second element
array[1]; // 60

#+end_src

*** JavaScript Array Methods


Adding Array Elements
The easiest way to add a new element to an array is using the push() method:
Example
const fruits = ["Banana", "Orange", "Apple"];
fruits.push("Lemon");  // Adds a new element (Lemon) to fruits

New element can also be added to an array using the length property:
Example
const fruits = ["Banana", "Orange", "Apple"];
fruits[fruits.length] = "Lemon";  // Adds "Lemon" to fruits

WARNING !

Adding elements with high indexes can create undefined "holes" in an array:
Example
const fruits = ["Banana", "Orange", "Apple"];
fruits[6] = "Lemon";  // Creates undefined "holes" in fruits

push(): This adds an item to the end of an array. It returns the new length of the array.
pop(): This removes the last item from the end of an array. It returns the last item.
length: Just like the string tool length, this gives the length of the array—in other words, the number of items. You'll notice that length doesn't need parentheses. That's because it's technically a property and not a method.

Array Properties and Methods
The real strength of JavaScript arrays are the built-in array properties and methods:
cars.length   // Returns the number of elements
cars.sort()   // Sorts the array

Array methods are covered in the next chapters.
The length Property

The length property of an array returns the length of an array (the number of array elements).
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let length = fruits.length;

The length property is always one more than the highest array index.
Accessing the First Array Element
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits[0];
Accessing the Last Array Element
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits[fruits.length - 1];

Manipulate Arrays With push()
An easy way to append data to the end of an array is via the push() function.
.push() takes one or more parameters and "pushes" them onto the end of the array.
Examples:
const arr1 = [1, 2, 3];
arr1.push(4);
const arr2 = ["Stimpson", "J", "cat"];
arr2.push(["happy", "joy"]);
arr1 now has the value [1, 2, 3, 4] and arr2 has the value ["Stimpson", "J", "cat", ["happy", "joy"]].
Push ["dog", 3] onto the end of the myArray variable.

Manipulate Arrays With pop()
Another way to change the data in an array is with the .pop() function.
.pop() is used to pop a value off of the end of an array. We can store this popped off value by assigning it to a variable. In other words, .pop() removes the last element from an array and returns that element.
Any type of entry can be popped off of an array - numbers, strings, even nested arrays.
const threeArr = [1, 4, 6];
const oneDown = threeArr.pop();
console.log(oneDown);
console.log(threeArr);
The first console.log will display the value 6, and the second will display the value [1, 4].
Use the .pop() function to remove the last item from myArray and assign the popped off value to a new variable, removedFromMyArray.

Manipulate Arrays With shift()
pop() always removes the last element of an array. What if you want to remove the first?
That's where .shift() comes in. It works just like .pop(), except it removes the first element instead of the last.
Example:
const ourArray = ["Stimpson", "J", ["cat"]];
const removedFromOurArray = ourArray.shift();
removedFromOurArray would have a value of the string Stimpson, and ourArray would have ["J", ["cat"]].
Use the .shift() function to remove the first item from myArray and assign the "shifted off" value to a new variable, removedFromMyArray.

Manipulate Arrays With unshift()
Not only can you shift elements off of the beginning of an array, you can also unshift elements to the beginning of an array i.e. add elements in front of the array.
.unshift() works exactly like .push(), but instead of adding the element at the end of the array, unshift() adds the element at the beginning of the array.
Example:
const ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();
ourArray.unshift("Happy");
After the shift, ourArray would have the value ["J", "cat"]. After the unshift, ourArray would have the value ["Happy", "J", "cat"].
Add ["Paul", 35] to the beginning of the myArray variable using unshift().

Converting Arrays to Strings

The JavaScript method toString() converts an array to a string of (comma separated) array values.
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits.toString();

Result:
Banana,Orange,Apple,Mango

The join() method also joins all array elements into a string.

It behaves just like toString(), but in addition you can specify the separator:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits.join(" * ");

Result:
Banana * Orange * Apple * Mango
Popping and Pushing

When you work with arrays, it is easy to remove elements and add new elements.

This is what popping and pushing is:

Popping items out of an array, or pushing items into an array.
JavaScript Array pop()

The pop() method removes the last element from an array:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.pop();

The pop() method returns the value that was "popped out":
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits.pop();
JavaScript Array push()

The push() method adds a new element to an array (at the end):
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.push("Kiwi");

The push() method returns the new array length:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let length = fruits.push("Kiwi");
Shifting Elements

Shifting is equivalent to popping, but working on the first element instead of the last.
JavaScript Array shift()

The shift() method removes the first array element and "shifts" all other elements to a lower index.
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.shift();

The shift() method returns the value that was "shifted out":
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fruit = fruits.shift();
JavaScript Array unshift()

The unshift() method adds a new element to an array (at the beginning), and "unshifts" older elements:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.unshift("Lemon");

The unshift() method returns the new array length.
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.unshift("Lemon");
Changing Elements

Array elements are accessed using their index number:

Array indexes start with 0:

[0] is the first array element
[1] is the second
[2] is the third ...
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits[0] = "Kiwi";
JavaScript Array length

The length property provides an easy way to append a new element to an array:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits[fruits.length] = "Kiwi";
JavaScript Array delete()
Warning !

Array elements can be deleted using the JavaScript operator delete.

Using delete leaves undefined holes in the array.

Use pop() or shift() instead.
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
delete fruits[0];
Merging (Concatenating) Arrays

The concat() method creates a new array by merging (concatenating) existing arrays:
Example (Merging Two Arrays)
const myGirls = ["Cecilie", "Lone"];
const myBoys = ["Emil", "Tobias", "Linus"];

const myChildren = myGirls.concat(myBoys);

The concat() method does not change the existing arrays. It always returns a new array.

The concat() method can take any number of array arguments:
Example (Merging Three Arrays)
const arr1 = ["Cecilie", "Lone"];
const arr2 = ["Emil", "Tobias", "Linus"];
const arr3 = ["Robin", "Morgan"];
const myChildren = arr1.concat(arr2, arr3);

The concat() method can also take strings as arguments:
Example (Merging an Array with Values)
const arr1 = ["Emil", "Tobias", "Linus"];
const myChildren = arr1.concat("Peter");
Splicing and Slicing Arrays

The splice() method adds new items to an array.

The slice() method slices out a piece of an array.
JavaScript Array splice()

The splice() method can be used to add new items to an array:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2, 0, "Lemon", "Kiwi");

The first parameter (2) defines the position where new elements should be added (spliced in).

The second parameter (0) defines how many elements should be removed.

The rest of the parameters ("Lemon" , "Kiwi") define the new elements to be added.

The splice() method returns an array with the deleted items:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2, 2, "Lemon", "Kiwi");
Using splice() to Remove Elements

With clever parameter setting, you can use splice() to remove elements without leaving "holes" in the array:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(0, 1);

The first parameter (0) defines the position where new elements should be added (spliced in).

The second parameter (1) defines how many elements should be removed.

The rest of the parameters are omitted. No new elements will be added.
JavaScript Array slice()

The slice() method slices out a piece of an array into a new array.

This example slices out a part of an array starting from array element 1 ("Orange"):
Example
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
const citrus = fruits.slice(1);
Note

The slice() method creates a new array.

The slice() method does not remove any elements from the source array.

This example slices out a part of an array starting from array element 3 ("Apple"):
Example
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
const citrus = fruits.slice(3);

The slice() method can take two arguments like slice(1, 3).

The method then selects elements from the start argument, and up to (but not including) the end argument.
Example
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
const citrus = fruits.slice(1, 3);

If the end argument is omitted, like in the first examples, the slice() method slices out the rest of the array.
Example
const fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
const citrus = fruits.slice(2);
Automatic toString()

JavaScript automatically converts an array to a comma separated string when a primitive value is expected.

This is always the case when you try to output an array.

These two examples will produce the same result:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits.toString();
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits;
Note

All JavaScript objects have a toString() method.
Finding Max and Min Values in an Array

There are no built-in functions for finding the highest or lowest value in a JavaScript array.

You will learn how you solve this problem in the next chapter of this tutorial.
Sorting Arrays

Sorting arrays are covered in the next chapter of this tutorial.
Complete Array Reference

For a complete Array reference, go to our:

Complete JavaScript Array Reference.

The reference contains descriptions and examples of all Array properties and methods.
Test Yourself With Exercises
Exercise:

Use the correct Array method to remove the last item of the fruits array.

const fruits = ["Banana", "Orange", "Apple"];
;


Start the Exercise

*** JavaScript Sorting Arrays
Sorting an Array

The sort() method sorts an array alphabetically:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();
Reversing an Array

The reverse() method reverses the elements in an array.

You can use it to sort an array in descending order:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();
fruits.reverse();
Numeric Sort

By default, the sort() function sorts values as strings.

This works well for strings ("Apple" comes before "Banana").

However, if numbers are sorted as strings, "25" is bigger than "100", because "2" is bigger than "1".

Because of this, the sort() method will produce incorrect result when sorting numbers.

You can fix this by providing a compare function:
Example
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return a - b});

Use the same trick to sort an array descending:
Example
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return b - a});
The Compare Function

The purpose of the compare function is to define an alternative sort order.

The compare function should return a negative, zero, or positive value, depending on the arguments:
function(a, b){return a - b}

When the sort() function compares two values, it sends the values to the compare function, and sorts the values according to the returned (negative, zero, positive) value.

If the result is negative a is sorted before b.

If the result is positive b is sorted before a.

If the result is 0 no changes are done with the sort order of the two values.

Example:

The compare function compares all the values in the array, two values at a time (a, b).

When comparing 40 and 100, the sort() method calls the compare function(40, 100).

The function calculates 40 - 100 (a - b), and since the result is negative (-60),  the sort function will sort 40 as a value lower than 100.

You can use this code snippet to experiment with numerically and alphabetically sorting:
<button onclick="myFunction1()">Sort Alphabetically</button>
<button onclick="myFunction2()">Sort Numerically</button>

<p id="demo"></p>

<script>
const points = [40, 100, 1, 5, 25, 10];
document.getElementById("demo").innerHTML = points;

function myFunction1() {
  points.sort();
  document.getElementById("demo").innerHTML = points;
}

function myFunction2() {
  points.sort(function(a, b){return a - b});
  document.getElementById("demo").innerHTML = points;
}
</script>
Sorting an Array in Random Order
Example
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return 0.5 - Math.random()});

The Fisher Yates Method

The above example, array.sort(), is not accurate, it will favor some numbers over the others.

The most popular correct method, is called the Fisher Yates shuffle, and was introduced in data science as early as 1938!

In JavaScript the method can be translated to this:
Example
const points = [40, 100, 1, 5, 25, 10];

for (let i = points.length -1; i > 0; i--) {
  let j = Math.floor(Math.random() * i)
  let k = points[i]
  points[i] = points[j]
  points[j] = k
}

Find the Highest (or Lowest) Array Value

There are no built-in functions for finding the max or min value in an array.

However, after you have sorted an array, you can use the index to obtain the highest and lowest values.

Sorting ascending:
Example
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return a - b});
// now points[0] contains the lowest value
// and points[points.length-1] contains the highest value

Sorting descending:
Example
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return b - a});
// now points[0] contains the highest value
// and points[points.length-1] contains the lowest value

Sorting a whole array is a very inefficient method if you only want to find the highest (or lowest) value.
Using Math.max() on an Array

You can use Math.max.apply to find the highest number in an array:
Example
function myArrayMax(arr) {
  return Math.max.apply(null, arr);
}

Math.max.apply(null, [1, 2, 3]) is equivalent to Math.max(1, 2, 3).
Using Math.min() on an Array

You can use Math.min.apply to find the lowest number in an array:
Example
function myArrayMin(arr) {
  return Math.min.apply(null, arr);
}

Math.min.apply(null, [1, 2, 3]) is equivalent to Math.min(1, 2, 3).
My Min / Max JavaScript Methods

The fastest solution is to use a "home made" method.

This function loops through an array comparing each value with the highest value found:
Example (Find Max)
function myArrayMax(arr) {
  let len = arr.length;
  let max = -Infinity;
  while (len--) {
    if (arr[len] > max) {
      max = arr[len];
    }
  }
  return max;
}

This function loops through an array comparing each value with the lowest value found:
Example (Find Min)
function myArrayMin(arr) {
  let len = arr.length;
  let min = Infinity;
  while (len--) {
    if (arr[len] < min) {
      min = arr[len];
    }
  }
  return min;
}

Sorting Object Arrays

JavaScript arrays often contain objects:
Example
const cars = [
  {type:"Volvo", year:2016},
  {type:"Saab", year:2001},
  {type:"BMW", year:2010}
];

Even if objects have properties of different data types, the sort() method can be used to sort the array.

The solution is to write a compare function to compare the property values:
Example
cars.sort(function(a, b){return a.year - b.year});

Comparing string properties is a little more complex:
Example
cars.sort(function(a, b){
  let x = a.type.toLowerCase();
  let y = b.type.toLowerCase();
  if (x < y) {return -1;}
  if (x > y) {return 1;}
  return 0;
});
Complete Array Reference

For a complete Array reference, go to our:

Complete JavaScript Array Reference.

The reference contains descriptions and examples of all Array properties and methods.
Test Yourself With Exercises
Exercise:

Use the correct Array method to sort the fruits array alphabetically.

const fruits = ["Banana", "Orange", "Apple", "Kiwi"];
;


Start the Exercise

*** JavaScript Array Iteration

Looping Array Elements
One way to loop through an array, is using a for loop:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fLen = fruits.length;

let text = "<ul>";
for (let i = 0; i < fLen; i++) {
  text += "<li>" + fruits[i] + "</li>";
}
text += "</ul>";

You can also use the Array.forEach() function:
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];

let text = "<ul>";
fruits.forEach(myFunction);
text += "</ul>";

function myFunction(value) {
  text += "<li>" + value + "</li>";
}

Array iteration methods operate on every array item.
JavaScript Array forEach()

The forEach() method calls a function (a callback function) once for each array element.
Example
const numbers = [45, 4, 9, 16, 25];
let txt = "";
numbers.forEach(myFunction);

function myFunction(value, index, array) {
  txt += value + "<br>";
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

The example above uses only the value parameter. The example can be rewritten to:
Example
const numbers = [45, 4, 9, 16, 25];
let txt = "";
numbers.forEach(myFunction);

function myFunction(value) {
  txt += value + "<br>";
}
JavaScript Array map()

The map() method creates a new array by performing a function on each array element.

The map() method does not execute the function for array elements without values.

The map() method does not change the original array.

This example multiplies each array value by 2:
Example
const numbers1 = [45, 4, 9, 16, 25];
const numbers2 = numbers1.map(myFunction);

function myFunction(value, index, array) {
  return value * 2;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

When a callback function uses only the value parameter, the index and array parameters can be omitted:
Example
const numbers1 = [45, 4, 9, 16, 25];
const numbers2 = numbers1.map(myFunction);

function myFunction(value) {
  return value * 2;
}
JavaScript Array filter()

The filter() method creates a new array with array elements that passes a test.

This example creates a new array from elements with a value larger than 18:
Example
const numbers = [45, 4, 9, 16, 25];
const over18 = numbers.filter(myFunction);

function myFunction(value, index, array) {
  return value > 18;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

In the example above, the callback function does not use the index and array parameters, so they can be omitted:
Example
const numbers = [45, 4, 9, 16, 25];
const over18 = numbers.filter(myFunction);

function myFunction(value) {
  return value > 18;
}
JavaScript Array reduce()

The reduce() method runs a function on each array element to produce (reduce it to) a single value.

The reduce() method works from left-to-right in the array. See also reduceRight().

The reduce() method does not reduce the original array.

This example finds the sum of all numbers in an array:
Example
const numbers = [45, 4, 9, 16, 25];
let sum = numbers.reduce(myFunction);

function myFunction(total, value, index, array) {
  return total + value;
}

Note that the function takes 4 arguments:

    The total (the initial value / previously returned value)
    The item value
    The item index
    The array itself

The example above does not use the index and array parameters. It can be rewritten to:
Example
const numbers = [45, 4, 9, 16, 25];
let sum = numbers.reduce(myFunction);

function myFunction(total, value) {
  return total + value;
}

The reduce() method can accept an initial value:
Example
const numbers = [45, 4, 9, 16, 25];
let sum = numbers.reduce(myFunction, 100);

function myFunction(total, value) {
  return total + value;
}
JavaScript Array reduceRight()

The reduceRight() method runs a function on each array element to produce (reduce it to) a single value.

The reduceRight() works from right-to-left in the array. See also reduce().

The reduceRight() method does not reduce the original array.

This example finds the sum of all numbers in an array:
Example
const numbers = [45, 4, 9, 16, 25];
let sum = numbers.reduceRight(myFunction);

function myFunction(total, value, index, array) {
  return total + value;
}

Note that the function takes 4 arguments:

    The total (the initial value / previously returned value)
    The item value
    The item index
    The array itself

The example above does not use the index and array parameters. It can be rewritten to:
Example
const numbers = [45, 4, 9, 16, 25];
let sum = numbers.reduceRight(myFunction);

function myFunction(total, value) {
  return total + value;
}
JavaScript Array every()

The every() method check if all array values pass a test.

This example check if all array values are larger than 18:
Example
const numbers = [45, 4, 9, 16, 25];
let allOver18 = numbers.every(myFunction);

function myFunction(value, index, array) {
  return value > 18;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

When a callback function uses the first parameter only (value), the other parameters can be omitted:
Example
const numbers = [45, 4, 9, 16, 25];
let allOver18 = numbers.every(myFunction);

function myFunction(value) {
  return value > 18;
}
JavaScript Array some()

The some() method check if some array values pass a test.

This example check if some array values are larger than 18:
Example
const numbers = [45, 4, 9, 16, 25];
let someOver18 = numbers.some(myFunction);

function myFunction(value, index, array) {
  return value > 18;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

JavaScript Array indexOf()

The indexOf() method searches an array for an element value and returns its position.

Note: The first item has position 0, the second item has position 1, and so on.
Example

Search an array for the item "Apple":
const fruits = ["Apple", "Orange", "Apple", "Mango"];
let position = fruits.indexOf("Apple") + 1;
Syntax
array.indexOf(item, start)
item 	Required. The item to search for.
start 	Optional. Where to start the search. Negative values will start at the given position counting from the end, and search to the end.

Array.indexOf() returns -1 if the item is not found.

If the item is present more than once, it returns the position of the first occurrence.
JavaScript Array lastIndexOf()

Array.lastIndexOf() is the same as Array.indexOf(), but returns the position of the last occurrence of the specified element.
Example

Search an array for the item "Apple":
const fruits = ["Apple", "Orange", "Apple", "Mango"];
let position = fruits.lastIndexOf("Apple") + 1;
Syntax
array.lastIndexOf(item, start)
item 	Required. The item to search for
start 	Optional. Where to start the search. Negative values will start at the given position counting from the end, and search to the beginning
JavaScript Array find()

The find() method returns the value of the first array element that passes a test function.

This example finds (returns the value of) the first element that is larger than 18:
Example
const numbers = [4, 9, 16, 25, 29];
let first = numbers.find(myFunction);

function myFunction(value, index, array) {
  return value > 18;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

Browser Support

find() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

find() is not supported in Internet Explorer.
JavaScript Array findIndex()

The findIndex() method returns the index of the first array element that passes a test function.

This example finds the index of the first element that is larger than 18:
Example
const numbers = [4, 9, 16, 25, 29];
let first = numbers.findIndex(myFunction);

function myFunction(value, index, array) {
  return value > 18;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

Browser Support

findIndex() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

findIndex() is not supported in Internet Explorer.

JavaScript Array.from()

The Array.from() method returns an Array object from any object with a length property or any iterable object.
Example

Create an Array from a String:
Array.from("ABCDEFG");
Browser Support

from() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

from() is not supported in Internet Explorer.
JavaScript Array Keys()

The Array.keys() method returns an Array Iterator object with the keys of an array.
Example

Create an Array Iterator object, containing the keys of the array:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
const keys = fruits.keys();

for (let x of keys) {
  text += x + "<br>";
}
Browser Support

keys() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

keys() is not supported in Internet Explorer.
Array entries()
Example

Create an Array Iterator, and then iterate over the key/value pairs:
const fruits = ["Banana", "Orange", "Apple", "Mango"];
const f = fruits.entries();

for (let x of f) {
  document.getElementById("demo").innerHTML += x;
}

The entries() method returns an Array Iterator object with key/value pairs:

[0, "Banana"]
[1, "Orange"]
[2, "Apple"]
[3, "Mango"]

The entries() method does not change the original array.
Browser Support

entries() is an ES6 feature (JavaScript 2015).

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

entries() is not supported in Internet Explorer.
JavaScript Array includes()

ECMAScript 2016 introduced Array.includes() to arrays. This allows us to check if an element is present in an array (including NaN, unlike indexOf).
Example
const fruits = ["Banana", "Orange", "Apple", "Mango"];

fruits.includes("Mango"); // is true
Syntax
array.includes(search-item)

Array.includes() allows to check for NaN values. Unlike Array.indexOf().

Array.includes() is not supported in Internet Explorer and Edge 12/13.

The first browser versions with full support are:
Browser Support

includes() is an ECMAScript 2016 feature.

It is supported in all modern browsers:

Chrome 	Edge 	Firefox 	Safari 	Opera
Yes 	Yes 	Yes 	Yes 	Yes

includes() is not supported in Internet Explorer.
Complete Array Reference

For a complete Array reference, go to our:

Complete JavaScript Array Reference.

The reference contains descriptions and examples of all Array properties and methods.

*** JavaScript Array Const
ECMAScript 2015 (ES6)

in 2015, JavaScript introduced an important new keyword: const.

It has become a common practice to declare arrays using const:
Example
const cars = ["Saab", "Volvo", "BMW"];
Cannot be Reassigned

An array declared with const cannot be reassigned:
Example
const cars = ["Saab", "Volvo", "BMW"];
cars = ["Toyota", "Volvo", "Audi"];    // ERROR
Arrays are Not Constants

The keyword const is a little misleading.

It does NOT define a constant array. It defines a constant reference to an array.

Because of this, we can still change the elements of a constant array.
Elements Can be Reassigned

You can change the elements of a constant array:
Example
// You can create a constant array:
const cars = ["Saab", "Volvo", "BMW"];

// You can change an element:
cars[0] = "Toyota";

// You can add an element:
cars.push("Audi");
Browser Support

The const keyword is not supported in Internet Explorer 10 or earlier.

The following table defines the first browser versions with full support for the const keyword:

Chrome 49 	IE 11 / Edge 	Firefox 36 	Safari 10 	Opera 36
Mar, 2016 	Oct, 2013 	Feb, 2015 	Sep, 2016 	Mar, 2016
Assigned when Declared

JavaScript const variables must be assigned a value when they are declared:

Meaning: An arrays declared with const must be initialized when it is declared.

Using const without initializing the array is a syntax error:
Example

This will not work:
const cars;
cars = ["Saab", "Volvo", "BMW"];

Arrays declared with var can be initialized at any time.

You can even use the array before it is declared:
Example

This is OK:
cars = ["Saab", "Volvo", "BMW"];
var cars;
Const Block Scope

An array declared with const has Block Scope.

An array declared in a block is not the same as an array declared outside the block:
Example
const cars = ["Saab", "Volvo", "BMW"];
// Here cars[0] is "Saab"
{
  const cars = ["Toyota", "Volvo", "BMW"];
  // Here cars[0] is "Toyota"
}
// Here cars[0] is "Saab"

An array declared with var does not have block scope:
Example
var cars = ["Saab", "Volvo", "BMW"];
// Here cars[0] is "Saab"
{
  var cars = ["Toyota", "Volvo", "BMW"];
  // Here cars[0] is "Toyota"
}
// Here cars[0] is "Toyota"

You can learn more about Block Scope in the chapter: JavaScript Scope.
Redeclaring Arrays

Redeclaring an array declared with var is allowed anywhere in a program:
Example
var cars = ["Volvo", "BMW"];   // Allowed
var cars = ["Toyota", "BMW"];  // Allowed
cars = ["Volvo", "Saab"];      // Allowed

Redeclaring or reassigning an array to const, in the same scope, or in the same block, is not allowed:
Example
var cars = ["Volvo", "BMW"];     // Allowed
const cars = ["Volvo", "BMW"];   // Not allowed
{
  var cars = ["Volvo", "BMW"];   // Allowed
  const cars = ["Volvo", "BMW"]; // Not allowed
}

Redeclaring or reassigning an existing const array, in the same scope, or in the same block, is not allowed:
Example
const cars = ["Volvo", "BMW"];   // Allowed
const cars = ["Volvo", "BMW"];   // Not allowed
var cars = ["Volvo", "BMW"];     // Not allowed
cars = ["Volvo", "BMW"];         // Not allowed

{
  const cars = ["Volvo", "BMW"]; // Allowed
  const cars = ["Volvo", "BMW"]; // Not allowed
  var cars = ["Volvo", "BMW"];   // Not allowed
  cars = ["Volvo", "BMW"];       // Not allowed
}

Redeclaring an array with const, in another scope, or in another block, is allowed:
Example
const cars = ["Volvo", "BMW"];   // Allowed
{
  const cars = ["Volvo", "BMW"]; // Allowed
}
{
  const cars = ["Volvo", "BMW"]; // Allowed
}
Complete Array Reference

For a complete Array reference, go to our:

Complete JavaScript Array Reference.

The reference contains descriptions and examples of all Array properties and methods.


JavaScript new Array()
JavaScript has a built in array constructor new Array().

But you can safely use [] instead.

These two different statements both create a new empty array named points:
const points = new Array();
const points = [];

These two different statements both create a new array containing 6 numbers:
const points = new Array(40, 100, 1, 5, 25, 10);
const points = [40, 100, 1, 5, 25, 10];

The new keyword can produce some unexpected results:
// Create an array with three elements:
const points = new Array(40, 100, 1);
// Create an array with two elements:
const points = new Array(40, 100);
// Create an array with one element ???
const points = new Array(40);
A Common Error
const points = [40];

is not the same as:
const points = new Array(40);
// Create an array with one element:
const points = [40];
// Create an array with 40 undefined elements:
const points = new Array(40);

** objects

Build JavaScript Objects
You may have heard the term object before.
Objects are similar to arrays, except that instead of using indexes to access and modify their data, you access the data in objects through what are called properties.
Objects are useful for storing data in a structured way, and can represent real world objects, like a cat.
Here's a sample cat object:
const cat = {
  "name": "Whiskers",
  "legs": 4,
  "tails": 1,
  "enemies": ["Water", "Dogs"]
};
In this example, all the properties are stored as strings, such as name, legs, and tails. However, you can also use numbers as properties. You can even omit the quotes for single-word string properties, as follows:
const anotherObject = {
  make: "Ford",
  5: "five",
  "model": "focus"
};
However, if your object has any non-string properties, JavaScript will automatically typecast them as strings.
Make an object that represents a dog called myDog which contains the properties name (a string), legs, tails and friends.
You can set these object properties to whatever values you want, as long as name is a string, legs and tails are numbers, and friends is an array.

Accessing Object Properties with Dot Notation
There are two ways to access the properties of an object: dot notation (.) and bracket notation ([]), similar to an array.
Dot notation is what you use when you know the name of the property you're trying to access ahead of time.
Here is a sample of using dot notation (.) to read an object's property:
const myObj = {
  prop1: "val1",
  prop2: "val2"
};
const prop1val = myObj.prop1;
const prop2val = myObj.prop2;
prop1val would have a value of the string val1, and prop2val would have a value of the string val2.
Read in the property values of testObj using dot notation. Set the variable hatValue equal to the object's property hat and set the variable shirtValue equal to the object's property shirt.

Accessing Object Properties with Bracket Notation
The second way to access the properties of an object is bracket notation ([]). If the property of the object you are trying to access has a space in its name, you will need to use bracket notation.
However, you can still use bracket notation on object properties without spaces.
Here is a sample of using bracket notation to read an object's property:
const myObj = {
  "Space Name": "Kirk",
  "More Space": "Spock",
  "NoSpace": "USS Enterprise"
};
myObj["Space Name"];
myObj['More Space'];
myObj["NoSpace"];
myObj["Space Name"] would be the string Kirk, myObj['More Space'] would be the string Spock, and myObj["NoSpace"] would be the string USS Enterprise.
Note that property names with spaces in them must be in quotes (single or double).
Read the values of the properties an entree and the drink of testObj using bracket notation and assign them to entreeValue and drinkValue respectively.

Accessing Object Properties with Variables
Another use of bracket notation on objects is to access a property which is stored as the value of a variable. This can be very useful for iterating through an object's properties or when accessing a lookup table.
Here is an example of using a variable to access a property:
const dogs = {
  Fido: "Mutt",
  Hunter: "Doberman",
  Snoopie: "Beagle"
};
const myDog = "Hunter";
const myBreed = dogs[myDog];
console.log(myBreed);
The string Doberman would be displayed in the console.
Another way you can use this concept is when the property's name is collected dynamically during the program execution, as follows:
const someObj = {
  propName: "John"
};
function propPrefix(str) {
  const s = "prop";
  return s + str;
}
const someProp = propPrefix("Name");
console.log(someObj[someProp]);
someProp would have a value of the string propName, and the string John would be displayed in the console.
Note that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name.
Set the playerNumber variable to 16. Then, use the variable to look up the player's name and assign it to player.

Updating Object Properties
After you've created a JavaScript object, you can update its properties at any time just like you would update any other variable. You can use either dot or bracket notation to update.
For example, let's look at ourDog:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
Since he's a particularly happy dog, let's change his name to the string Happy Camper. Here's how we update his object's name property: ourDog.name = "Happy Camper"; or ourDog["name"] = "Happy Camper"; Now when we evaluate ourDog.name, instead of getting Camper, we'll get his new name, Happy Camper.
Update the myDog object's name property. Let's change her name from Coder to Happy Coder. You can use either dot or bracket notation.

Add New Properties to a JavaScript Object
You can add new properties to existing JavaScript objects the same way you would modify them.
Here's how we would add a bark property to ourDog:
ourDog.bark = "bow-wow";
or
ourDog["bark"] = "bow-wow";
Now when we evaluate ourDog.bark, we'll get his bark, bow-wow.
Example:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
ourDog.bark = "bow-wow";
Add a bark property to myDog and set it to a dog sound, such as "woof". You may use either dot or bracket notation.

Delete Properties from a JavaScript Object
We can also delete properties from objects like this:
delete ourDog.bark;
Example:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"],
  "bark": "bow-wow"
};
delete ourDog.bark;
After the last line shown above, ourDog looks like:

{
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
}
Delete the tails property from myDog. You may use either dot or bracket notation.

Using Objects for Lookups
Objects can be thought of as a key/value storage, like a dictionary. If you have tabular data, you can use an object to lookup values rather than a switch statement or an if/else chain. This is most useful when you know that your input data is limited to a certain range.
Here is an example of a simple reverse alphabet lookup:
const alpha = {
  1:"Z",
  2:"Y",
  3:"X",
  4:"W",
  ...
  24:"C",
  25:"B",
  26:"A"
};
alpha[2];
alpha[24];
const value = 2;
alpha[value];
alpha[2] is the string Y, alpha[24] is the string C, and alpha[value] is the string Y.
Convert the switch statement into an object called lookup. Use it to look up val and assign the associated string to the result variable.

Manipulating Complex Objects
Sometimes you may want to store data in a flexible Data Structure. A JavaScript object is one way to handle flexible data. They allow for arbitrary combinations of strings, numbers, booleans, arrays, functions, and objects.
Here's an example of a complex data structure:
const ourMusic = [
  {
    "artist": "Daft Punk",
    "title": "Homework",
    "release_year": 1997,
    "formats": [
      "CD",
      "Cassette",
      "LP"
    ],
    "gold": true
  }
];
This is an array which contains one object inside. The object has various pieces of metadata about an album. It also has a nested formats array. If you want to add more album records, you can do this by adding records to the top level array. Objects hold data in a property, which has a key-value format. In the example above, "artist": "Daft Punk" is a property that has a key of artist and a value of Daft Punk.
Note: You will need to place a comma after every object in the array, unless it is the last object in the array.
Add a new album to the myMusic array. Add artist and title strings, release_year number, and a formats array of strings.

Accessing Nested Objects
The sub-properties of objects can be accessed by chaining together the dot or bracket notation.
Here is a nested object:
const ourStorage = {
  "desk": {
    "drawer": "stapler"
  },
  "cabinet": {
    "top drawer": {
      "folder1": "a file",
      "folder2": "secrets"
    },
    "bottom drawer": "soda"
  }
};
ourStorage.cabinet["top drawer"].folder2;
ourStorage.desk.drawer;
ourStorage.cabinet["top drawer"].folder2 would be the string secrets, and ourStorage.desk.drawer would be the string stapler.
Access the myStorage object and assign the contents of the glove box property to the gloveBoxContents variable. Use dot notation for all properties where possible, otherwise use bracket notation.


JavaScript object
A collection of values and their associated keys
An object is a type of collection that holds information, just like an array.
An object makes it possible to store data using key-value pairs, as a dictionary does.

empty object {};
key-value pairs key: value

{
key1: val2,
...
key3: ["foo", "bar"],
};

dot notation
objName.key

arr = [
  { key0: "val0", key1: "val1"}
]
arr[0].key1

adding key-value pairs
objName.newKey = "newValue";
updating key-value pairs
objName.oldKey = "newValue";

bracket notation
objName[key]
sometimes need to use bracket notation when the key that you wish to access is a string with a space in it.
obj["str"]

adding key-value pairs
objName["newKey"] = "newValue";
updating key-value pairs
objName["oldKey"] = "newValue";

bracket variables
let var = "oldKey";
obj[var]; // oldValue

objects loop

nested objects

var = {
  key0: {
  "nestedKey": {
    foo: 111
  }
  }
}
var.key0.nestedKey.foo
var["key0"]["nestedKey"].foo
var.key0.nestedKey["foo"] = 222;


JavaScript Objects
Real Life Objects, Properties, and Methods

In real life, a car is an object.

A car has properties like weight and color, and methods like start and stop:
Object 	Properties 	Methods

car.name = Fiat

car.model = 500

car.weight = 850kg

car.color = white
car.start()

car.drive()

car.brake()

car.stop()

All cars have the same properties, but the property values differ from car to car.

All cars have the same methods, but the methods are performed at different times.
JavaScript Objects

You have already learned that JavaScript variables are containers for data values.

This code assigns a simple value (Fiat) to a variable named car:
let car = "Fiat";

Objects are variables too. But objects can contain many values.

This code assigns many values (Fiat, 500, white) to a variable named car:
const car = {type:"Fiat", model:"500", color:"white"};

The values are written as name:value pairs (name and value separated by a colon).

It is a common practice to declare objects with the const keyword.

Learn more about using const with objects in the chapter: JS Const.
Object Definition

You define (and create) a JavaScript object with an object literal:
Example
const person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};

Spaces and line breaks are not important. An object definition can span multiple lines:
Example
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};
Object Properties

The name:values pairs in JavaScript objects are called properties:
Property 	Property Value
firstName 	John
lastName 	Doe
age 	50
eyeColor 	blue
Accessing Object Properties

You can access object properties in two ways:
objectName.propertyName

or
objectName["propertyName"]
Example1
person.lastName;
Example2
person["lastName"];

JavaScript objects are containers for named values called properties.
Object Methods

Objects can also have methods.

Methods are actions that can be performed on objects.

Methods are stored in properties as function definitions.
Property 	Property Value
firstName 	John
lastName 	Doe
age 	50
eyeColor 	blue
fullName 	function() {return this.firstName + " " + this.lastName;}

A method is a function stored as a property.
Example
const person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

In the example above, this refers to the person object.

I.E. this.firstName means the firstName property of this.

I.E. this.firstName means the firstName property of person.
What is this?

In JavaScript, the this keyword refers to an object.

Which object depends on how this is being invoked (used or called).

The this keyword refers to different objects depending on how it is used:
In an object method, this refers to the object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.
In an event, this refers to the element that received the event.
Methods like call(), apply(), and bind() can refer this to any object.
Note
this is not a variable. It is a keyword. You cannot change the value of this.
See Also:

The JavaScript this Tutorial
The this Keyword

In a function definition, this refers to the "owner" of the function.

In the example above, this is the person object that "owns" the fullName function.

In other words, this.firstName means the firstName property of this object.

Learn more about this in The JavaScript this Tutorial.
Accessing Object Methods

You access an object method with the following syntax:
objectName.methodName()
Example
name = person.fullName();

If you access a method without the () parentheses, it will return the function definition:
Example
name = person.fullName;
Do Not Declare Strings, Numbers, and Booleans as Objects!

When a JavaScript variable is declared with the keyword "new", the variable is created as an object:
x = new String();        // Declares x as a String object
y = new Number();        // Declares y as a Number object
z = new Boolean();       // Declares z as a Boolean object

Avoid String, Number, and Boolean objects. They complicate your code and slow down execution speed.

You will learn more about objects later in this tutorial.
Test Yourself With Exercises
Exercise:

Alert "John" by extracting information from the person object.

const person = {
  firstName: "John",
  lastName: "Doe"
};

alert();


Start the Exercise

Prevent Object Mutation

As seen in the previous challenge, const declaration alone doesn't really protect your data from mutation. To ensure your data doesn't change, JavaScript provides a function Object.freeze to prevent data mutation.

Any attempt at changing the object will be rejected, with an error thrown if the script is running in strict mode.

let obj = {
  name:"FreeCodeCamp",
  review:"Awesome"
};
Object.freeze(obj);
obj.review = "bad";
obj.newProp = "Test";
console.log(obj);

The obj.review and obj.newProp assignments will result in errors, because our editor runs in strict mode by default, and the console will display the value { name: "FreeCodeCamp", review: "Awesome" }.

In this challenge you are going to use Object.freeze to prevent mathematical constants from changing. You need to freeze the MATH_CONSTANTS object so that no one is able to alter the value of PI, add, or delete properties.

*** destructuring and rest thinkful

Deep destructuring The process of destructuring multiple levels of an array or other object
Destructuring The process of unpacking the properties or values in an array or other object and assigning them into distinct variables
Rest operator An operator that condenses entries in arrays and other objects

Destructuring objects


Now, take a moment to examine the object in the code sample below.
const product = {
  title: "The Golden Compass",
  priceInCents: 799,
  author: {
    firstName: "Philip",
    surname: "Pullman",
  },
};

When working with an object, you'll often need to use some, but not all, of the available keys.

Consider this example:
function printAuthorAndTitle(product) {
  return `${product.title} by ${product.author.firstName} ${product.author.surname}`;
}

The above function works just fine.
However, the return statement ends up being a bit long because you have to repeat the product variable multiple times.
In this case, you might update the above function to the one below, hoping to make it easier to read:

function printAuthorAndTitle(product) {
  const author = product.author;
  const title = product.title;
  return `${title} by ${author.firstName} ${author.surname}`;
}

The second function is more legible than the first.
But it still looks clunky; after all, the product variable continues to be repeated multiple times.
Fortunately, there's another option: destructuring.
When you destructure an object or array, you're unpacking the properties or values and assigning them into distinct variables.

Take a look at the following version of the function above, which makes use of destructuring. What do you notice?

function printAuthorAndTitle(product) {

  const { author, title } = product;

  return `${title} by ${author.firstName} ${author.surname}`;

}

In this example, two new const variables are being created: author and title.

Notice how these new variables are wrapped in curly brackets {} before the = sign.
This is the destructuring syntax.
Those variables are set to whatever keys can be found inside of the product object.
If a key isn't found, it will be set to undefined.

Take a look:
const { yearPublished } = product;
console.log(yearPublished); //> undefined
Because product doesn't contain a yearPublished key, undefined would be logged to the console.

And what's more, you can destructure multiple levels into an object. Check it out.

function printAuthorAndTitle(product) {
  const {
    author: { firstName, surname },
    title,
  } = product;
  return `${title} by ${firstName} ${surname}`;
}

In the above function, the author key, which also points to an object, is further destructured to access the firstName and surname keys.
Note that there is no author variable in this function.
The only variables that are created are firstName, surname, and title.

Do this
Destructure an object

Take a look at the following object. Practice destructuring all of the keys from this object.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

When you're done, you can compare your work to this solution:

const {name} = author;

const firstName = name.firstName;

const surname = name.surname

console.log(firstName); //> 'Philip'

console.log(surname); //> 'Pullman'

Missing keys

Review the following code. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};


const { firstName } = author;

console.log(firstName);

As you can see, firstName ends up being undefined because the author object doesn't have a key called firstName. The firstName key belongs to the nested object that the name key points to.

Deep destructuring
Examine the code sample below. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;
console.log(firstName);
console.log(name);

In this case, firstName will be printed out as "Philip". But trying to print name will cause a ReferenceError.

When you use the syntax above to do deep destructuring, you're able to dive into and unpack multiple levels of an object. However, you won't have access to every value along the way. Furthermore, deep destructuring can cause some issues if the key is missing.

For example, take a look at the code below.

const author = {
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;

If you run this code, you will receive the following error:

Uncaught TypeError: Cannot read property 'firstName' of undefined

If you use deep destructuring, you'll need to make sure that the inputted object or array is of the right shape. This will help prevent errors like this one.
Destructuring arrays

As you know, objects are accessed by their keys. Arrays, on the other hand, are accessed by their index. In the above example, object keys were used to destructure objects and create variables. The process for arrays is similar, except that you'll use those specific positions in the array to create the variables. To begin, check out the array below:

const genres = [
  "Fantasy",
  "Fiction",
  "Nonfiction",
  "Science Fiction",
  "Young Adult",
];

You can destructure this array by doing the following:

const [first, second] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'

In the above example, two new variables are created: first and second. Those variable names are set to the elements at index 0 and index 1. The rest of the elements are ignored.
Do this
Destructure an array

Take a look at the following array. Practice destructuring the first, second, and third values from this array.

const authors = [
  "Ursula K. Le Guin",
  "Brandon Sanderson",
  "Terry Pratchett",
  "Neil Gaiman",
  "J. R. R. Tolkien",
];

const [first, second, third] = authors;

The rest operator

As you've seen, destructuring is an extremely valuable tool. But that being said, destructuring an array on its own is only so useful. It's much more useful when it pairs up with another tool: the rest operator.
Take a look at the code sample below. What do you notice?

const [first, second, ...otherGenres] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'
console.log(otherGenres); //> [ 'Nonfiction', 'Science Fiction', 'Young Adult' ]

In this example, there are two variables: first and second. Those are followed by the syntax that makes up the rest operator: the three periods ... and a variable name, which in this case is otherGenres. The variable that follows ... will contain all of the remaining array elements that weren't destructured. This can be very useful for splitting apart an array.
Destructuring parameters

You can also use destructuring in functions in order to destructure the parameters. Take a look at this example:

function printAuthorAndTitle({ author, title }) {

  return `${title} by ${author.firstName} ${author.surname}`;

}


printAuthorAndTitle(product); //> 'The Golden Compass by Philip Pullman'

The above syntax, once understood, is useful for at least two reasons:

    You know that the expected input into the function is an object.

    The function is concise and easy to read.

However, there is a downside to this approach: if you need to access the entire inputted object, you have no way to do so.

object destructuring
quickly extract prop values from objects and assign to local variable.
commonly used to aid readability.
const car = {
  make: "Toyota",
  model: "Corolla",
  drive() {
    console.log("The car is driving!");
  }
}

// Destructure values from car
const {make, model, drive, numberOfWheels} = car;

console.log(make); // "Toyota"
console.log(model); // "Corolla"
drive(); // The care is driving!
console.log(numberOfWheels); // undefined

peculiarities of accessing objects
const littleYacht = {
  floorColor: "red",
  maximumLbs: 1000,
  inOperation: true,
  christened: false,
  hornSound: "Ride of the Walkeries",
  "Dock Name": "oceania",
  //Dock Name: "oceania",

  playHorn: function() {
    console.log(littleYacht.hornSound);
  }
};

console.log(littleYacht.floorColor);
console.log(littleYacht["floorColor"]);
// console.log(littleYacht[floorColor]);

console.log(littleYacht["Dock Name"]);
// console.log(littleYacht.Dock Name);

the in operator
check existence of a key in an object:
const myObj = {
  color: "red",
  shape: "circle",
  size: "4cm"
}

console.log("shape" in myObj); // => true
console.log("height" in myObj); // => false

methods are properties of objects which are functions
const car = {
  make: "Toyota",
  model: "Corolla",
  // this is a method
  drive() {
    console.log("The car is driving!");
  },
  // it's shorthand for this
  useHorn: function() {
    console.log("Beep");
  }
}

car.drive(); // Logs out "The car is driving!"
car.useHorn(); // Logs out "Beep"

*** object shorthand and spread thinkful

Object shorthand JavaScript syntax that supports the creation of objects using values stored in variables, where the variable name becomes the key and the stored value becomes the value in the key-value pair
Spread operator An operator that expands entries in arrays and other objects

Object shorthand
Newer versions of JavaScript have made it even easier for you to streamline your code by allowing you to create object shorthands.
Object shorthand syntax means that you can create objects using values that you've stored in variables.

Take a look:
const title = "Infernal Devices";
const author = "K.W. Jeter";
const book = { title, author };

Notice that in the above code, there is no colon : symbol to distinguish a key from a value. So, what are the keys and values of this object?

console.log(book); //> { title: "Infernal Devices", author: "K.W. Jeter" }

Here, JavaScript takes the name of the variable and sets that to be the key. It then sets the value to be whatever is stored in that variable. This works with more complicated data types, as well.

const product = { book, priceInCents: 1950 };

With this shorthand tool, you can write cleaner code. The above code would result in the following:

{
  book: {
    title: "Infernal Devices",
    author: "K.W. Jeter",
  },
  priceInCents: 1950,
};

The spread operator
The spread operator allows you to easily combine arrays and objects without a lot of complicated code.
For example, with what you know now, how would you go about combining the following two arrays?

const ownedBooks = ["Infernal Devices", "Foundation"];
const wishlist = ["Good Omens", "Guards! Guards!"];

At first glance, you'd probably see that you could loop through one array and push each item into the other, or you could use the concat() method, which you can learn more about in MDN's array documentation.
And yet, it can be even easier than that.

Review the code below. What do you notice?

const allBooks = [...ownedBooks, ...wishlist];
//> [ "Infernal Devices", "Foundation", "Good Omens", "Guards! Guards!" ]

Do you see the three periods ...?
When ... is used with an existing array on the right side of the = sign, it will expand the entries inside of that array.
In the above case, both arrays are expanded into a new array, so that all of the array elements appear next to one another.

This can also be accomplished with objects, as follows:

const salesTax = { state: "Washington", tax: 0.065 };
const sale = { ...product, ...salesTax };
/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 1950,
    state: "Washington",
    tax: 0.065
  };
*/

In the example above, the product object contains the book key and the priceInCents key.
The salesTax object contains the state and tax keys.
Those keys are all placed into a new object in the variable sale.
Note how the book object wasn't expanded; the spread operator expands only one level deep.

You also can overwrite keys in an object where you're using shorthand. You can do this by simply using the key once again. Take a look:

const sale = {
  ...product,
  ...salesTax,
  priceInCents: product.priceInCents * (1 + salesTax.tax),
};

/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 2076.75,
    state: "Washington",
    tax: 0.065
  };
*/

In the above example, the product and salesTax values are expanded with the spread operator, just like before. But this time, the priceInCents key is added to overwrite the priceInCents key that was stored in the product variable.


Property value shorthand (for Objects)
A convenient shorthand method for creating an object if your local variable name matches the new object's key

// Function that returns a new 'cat' object:
function createCat(name) {
  const color = getRandomColor();

  return {
    eyes: 2,
    legs: 4,
    name,     // same as name: name
    color,    // same as color: color
  };
}

const myCat = createCat('tabby');

example:
{
  eyes: 2,
  legs: 4,
  name: 'tabby',
  color: 'blue'
}


Spread operator (...) with objects
    Helps us manage merging objects
    Creates a new object
    Be aware of the order in which merging is done

const littleYacht = {
    "Dock Name": "oceania",
    floorColor: "red",
    christened: false,
    hornSound: "Ride of the Walkeries",
    playHorn() {
        console.log(littleYacht.hornSound);
    }
};

const littleYacht2 = {
    roofColor: "green",  // new key, will be added
    christened: true     // duplicate key, will be overwritten
};

const newYacht = { ...littleYacht, ...littleYacht2 };

The this keyword
    (Generally) used in methods to refer to properties of an object
    Don't need to know the variable name of the object itself

const littleYacht = {
    hornSound: "Ride of the Walkeries",
    playHorn: function() {
      // Equivalent to littleYacht.hornSound
      console.log(this.hornSound);
    }
};

littleYacht.playHorn(); // Ride of the Walkeries


What does this refer to?
    this is assigned a value at the moment the method is invoked, and not when it is defined
    this is assigned to the object to the left of the dot when the function was called

const littleYacht = {
  hornSound: "Ride of the Walkeries",
  playHorn: function() {
    console.log(this.hornSound);
  }
};

littleYacht.playHorn(); // Ride of the Walkeries

const biggerYacht = {
  hornSound: "Fog Horn",
  playHorn: littleYacht.playHorn
};

biggerYacht.playHorn(); // Fog Horn

** Undefined
** operator

JavaScript Operators
Example

Assign values to variables and add them together:
let x = 5;         // assign the value 5 to x
let y = 2;         // assign the value 2 to y
let z = x + y;     // assign the value 7 to z (5 + 2)

The assignment operator (=) assigns a value to a variable.
Assignment
let x = 10;

The addition operator (+) adds numbers:
Adding
let x = 5;
let y = 2;
let z = x + y;

The multiplication operator (*) multiplies numbers.
Multiplying
let x = 5;
let y = 2;
let z = x * y;
JavaScript Arithmetic Operators

Arithmetic operators are used to perform arithmetic on numbers:
Operator 	Description
+ + 	Addition
+ - 	Subtraction
+ * 	Multiplication
+ ** 	Exponentiation (ES2016)
+ / 	Division
+ % 	Modulus (Division Remainder)
+ ++ 	Increment
+ -- 	Decrement

Arithmetic operators are fully described in the JS Arithmetic chapter.
JavaScript Assignment Operators

Assignment operators assign values to JavaScript variables.
Operator 	Example 	Same As
= 	x = y 	x = y
+= 	x += y 	x = x + y
-= 	x -= y 	x = x - y
*= 	x *= y 	x = x * y
/= 	x /= y 	x = x / y
%= 	x %= y 	x = x % y
**= 	x **= y 	x = x ** y

The addition assignment operator (+=) adds a value to a variable.
Assignment
let x = 10;
x += 5;

Assignment operators are fully described in the JS Assignment chapter.
JavaScript String Operators

The + operator can also be used to add (concatenate) strings.
Example
let text1 = "John";
let text2 = "Doe";
let text3 = text1 + " " + text2;

The result of text3 will be:
John Doe

The += assignment operator can also be used to add (concatenate) strings:
Example
let text1 = "What a very ";
text1 += "nice day";

The result of text1 will be:
What a very nice day

When used on strings, the + operator is called the concatenation operator.
Adding Strings and Numbers

Adding two numbers, will return the sum, but adding a number and a string will return a string:
Example
let x = 5 + 5;
let y = "5" + 5;
let z = "Hello" + 5;

The result of x, y, and z will be:
10
55
Hello5

If you add a number and a string, the result will be a string!
JavaScript Comparison Operators
Operator 	Description
== 	equal to
=== 	equal value and equal type
!= 	not equal
!== 	not equal value or not equal type
> 	greater than
< 	less than
>= 	greater than or equal to
<= 	less than or equal to
? 	ternary operator

Comparison operators are fully described in the JS Comparisons chapter.
JavaScript Logical Operators
Operator 	Description
&& 	logical and
|| 	logical or
! 	logical not

Logical operators are fully described in the JS Comparisons chapter.
JavaScript Type Operators
Operator 	Description
typeof 	Returns the type of a variable
instanceof 	Returns true if an object is an instance of an object type

Type operators are fully described in the JS Type Conversion chapter.
JavaScript Bitwise Operators

Bit operators work on 32 bits numbers.
Any numeric operand in the operation is converted into a 32 bit number. The result is converted back to a JavaScript number.
Operator 	Description 	Example 	Same as 	Result 	Decimal
& 	AND 	5 & 1 	0101 & 0001 	0001 	 1
| 	OR 	5 | 1 	0101 | 0001 	0101 	 5
~ 	NOT 	~ 5 	 ~0101 	1010 	 10
^ 	XOR 	5 ^ 1 	0101 ^ 0001 	0100 	 4
<< 	left shift 	5 << 1 	0101 << 1 	1010 	 10
>> 	right shift 	5 >> 1 	0101 >> 1 	0010 	  2
>>> 	unsigned right shift 	5 >>> 1 	0101 >>> 1 	0010 	  2

The examples above uses 4 bits unsigned examples. But JavaScript uses 32-bit signed numbers.
Because of this, in JavaScript, ~ 5 will not return 10. It will return -6.
~00000000000000000000000000000101 will return 11111111111111111111111111111010

Bitwise operators are fully described in the JS Bitwise chapter.
Test Yourself With Exercises
Exercise:

Multiply 10 with 5, and alert the result.

alert(10  5);


Start the Exercise

Operator
  A symbol that performs an operation on one or more variables and values
  operators connect pieces of codes.
Mathematical operator
  An operator that performs an arithmetic calculation with one or more operands
Assignment operator
  An operator that assigns specific values in code
  it assigns the vaule of the right operand to the left operand.


arithmetic expression is a combination of:
  operands (values, variables, etc.)
  operators (+ - * / %)
  that can be evaluated to a value
  ex. y = x + 5

JavaScript Operators
JavaScript uses arithmetic operators ( + - * / ) to compute values:
(5 + 6) * 10
JavaScript uses an assignment operator ( = ) to assign values to variables:
let x, y;
x = 5;
y = 6;

Add Two Numbers with JavaScript
Number is a data type in JavaScript which represents numeric data.
Now let's try to add two numbers using JavaScript.
JavaScript uses the + symbol as an addition operator when placed between two numbers.
Example:
const myVar = 5 + 10;
myVar now has the value 15.
Change the 0 so that sum will equal 20.

Subtract One Number from Another with JavaScript
We can also subtract one number from another.
JavaScript uses the - symbol for subtraction.
Example
const myVar = 12 - 6;
myVar would have the value 6.
Change the 0 so the difference is 12.

Multiply Two Numbers with JavaScript
We can also multiply one number by another.
JavaScript uses the * symbol for multiplication of two numbers.
Example
const myVar = 13 * 13;
myVar would have the value 169.
Change the 0 so that product will equal 80.

We can also divide one number by another.
JavaScript uses the / symbol for division.
Example
const myVar = 16 / 2;
myVar now has the value 8.
Change the 0 so that the quotient is equal to 2.

Increment a Number with JavaScript
You can easily increment or add one to a variable with the ++ operator.
i++;
is the equivalent of
i = i + 1;
Note: The entire line becomes i++;, eliminating the need for the equal sign.
Change the code to use the ++ operator on myVar.

Decrement a Number with JavaScript
You can easily decrement or decrease a variable by one with the -- operator.
i--;
is the equivalent of
i = i - 1;
Note: The entire line becomes i--;, eliminating the need for the equal sign.
Change the code to use the -- operator on myVar.

Multiply Two Decimals with JavaScript
In JavaScript, you can also perform calculations with decimal numbers, just like whole numbers.
Let's multiply two decimals together to get their product.

Divide One Decimal by Another with JavaScript
Now let's divide one decimal by another.
Change the 0.0 so that quotient will equal to 2.2.

Finding a Remainder in JavaScript
The remainder operator % gives the remainder of the division of two numbers.
Example
5 % 2 = 1 because
Math.floor(5 / 2) = 2 (Quotient)
2 * 2 = 4
5 - 4 = 1 (Remainder)
Usage
In mathematics, a number can be checked to be even or odd by checking the remainder of the division of the number by 2.
17 % 2 = 1 (17 is Odd)
48 % 2 = 0 (48 is Even)
Note: The remainder operator is sometimes incorrectly referred to as the modulus operator. It is very similar to modulus, but does not work properly with negative numbers.
Set remainder equal to the remainder of 11 divided by 3 using the remainder (%) operator.

Compound Assignment With Augmented Addition
In programming, it is common to use assignments to modify the contents of a variable. Remember that everything to the right of the equals sign is evaluated first, so we can say:
myVar = myVar + 5;
to add 5 to myVar. Since this is such a common pattern, there are operators which do both a mathematical operation and assignment in one step.
One such operator is the += operator.
let myVar = 1;
myVar += 5;
console.log(myVar);
6 would be displayed in the console.
Convert the assignments for a, b, and c to use the += operator.

Compound Assignment With Augmented Subtraction
Like the += operator, -= subtracts a number from a variable.
myVar = myVar - 5;
will subtract 5 from myVar. This can be rewritten as:
myVar -= 5;
Convert the assignments for a, b, and c to use the -= operator.

Compound Assignment With Augmented Multiplication
The *= operator multiplies a variable by a number.
myVar = myVar * 5;
will multiply myVar by 5. This can be rewritten as:
myVar *= 5;
Convert the assignments for a, b, and c to use the *= operator.

Compound Assignment With Augmented Division
The /= operator divides a variable by another number.
myVar = myVar / 5;
Will divide myVar by 5. This can be rewritten as:
myVar /= 5;
Convert the assignments for a, b, and c to use the /= operator.

Comparison with the Equality Operator
There are many comparison operators in JavaScript. All of these operators return a boolean true or false value.
The most basic operator is the equality operator ==. The equality operator compares two values and returns true if they're equivalent or false if they are not. Note that equality is different from assignment (=), which assigns the value on the right of the operator to a variable on the left.
function equalityTest(myVal) {
  if (myVal == 10) {
    return "Equal";
  }
  return "Not Equal";
}
If myVal is equal to 10, the equality operator returns true, so the code in the curly braces will execute, and the function will return Equal. Otherwise, the function will return Not Equal. In order for JavaScript to compare two different data types (for example, numbers and strings), it must convert one type to another. This is known as Type Coercion. Once it does, however, it can compare terms as follows:
1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
Add the equality operator to the indicated line so that the function will return the string Equal when val is equivalent to 12.

Comparison with the Strict Equality Operator
Strict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator, which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion.
If the values being compared have different types, they are considered unequal, and the strict equality operator will return false.
Examples
3 ===  3  // true
3 === '3' // false
In the second example, 3 is a Number type and '3' is a String type.
Use the strict equality operator in the if statement so the function will return the string Equal when val is strictly equal to 7.

Practice comparing different values
In the last two challenges, we learned about the equality operator (==) and the strict equality operator (===). Let's do a quick review and practice using these operators some more.
If the values being compared are not of the same type, the equality operator will perform a type conversion, and then evaluate the values. However, the strict equality operator will compare both the data type and value as-is, without converting one type to the other.
Examples
3 == '3' returns true because JavaScript performs type conversion from string to number. 3 === '3' returns false because the types are different and type conversion is not performed.
Note: In JavaScript, you can determine the type of a variable or a value with the typeof operator, as follows:
typeof 3
typeof '3'
typeof 3 returns the string number, and typeof '3' returns the string string.
The compareEquality function in the editor compares two values using the equality operator. Modify the function so that it returns the string Equal only when the values are strictly equal.

Comparison with the Inequality Operator
The inequality operator (!=) is the opposite of the equality operator. It means not equal and returns false where equality would return true and vice versa. Like the equality operator, the inequality operator will convert data types of values while comparing.
Examples
1 !=  2    // true
1 != "1"   // false
1 != '1'   // false
1 != true  // false
0 != false // false
Add the inequality operator != in the if statement so that the function will return the string Not Equal when val is not equivalent to 99.

Comparison with the Strict Inequality Operator
The strict inequality operator (!==) is the logical opposite of the strict equality operator. It means "Strictly Not Equal" and returns false where strict equality would return true and vice versa. The strict inequality operator will not convert data types.
Examples
3 !==  3  // false
3 !== '3' // true
4 !==  3  // true
Add the strict inequality operator to the if statement so the function will return the string Not Equal when val is not strictly equal to 17

Comparison with the Greater Than Operator
The greater than operator (>) compares the values of two numbers. If the number to the left is greater than the number to the right, it returns true. Otherwise, it returns false.
Like the equality operator, the greater than operator will convert data types of values while comparing.
Examples
5   >  3  // true
7   > '3' // true
2   >  3  // false
'1' >  9  // false
Add the greater than operator to the indicated lines so that the return statements make sense.

Use the Conditional (Ternary) Operator
The conditional operator, also called the ternary operator, can be used as a one line if-else expression.
The syntax is a ? b : c, where a is the condition, b is the code to run when the condition returns true, and c is the code to run when the condition returns false.
The following function uses an if/else statement to check a condition:
function findGreater(a, b) {
  if(a > b) {
    return "a is greater";
  }
  else {
    return "b is greater or equal";
  }
}
This can be re-written using the conditional operator:
function findGreater(a, b) {
  return a > b ? "a is greater" : "b is greater or equal";
}
Use the conditional operator in the checkEqual function to check if two numbers are equal or not. The function should return either the string Equal or the string Not Equal.

Use Multiple Conditional (Ternary) Operators
In the previous challenge, you used a single conditional operator. You can also chain them together to check for multiple conditions.
The following function uses if, else if, and else statements to check multiple conditions:
function findGreaterOrEqual(a, b) {
  if (a === b) {
    return "a and b are equal";
  }
  else if (a > b) {
    return "a is greater";
  }
  else {
    return "b is greater";
  }
}
The above function can be re-written using multiple conditional operators:
function findGreaterOrEqual(a, b) {
  return (a === b) ? "a and b are equal"
    : (a > b) ? "a is greater"
    : "b is greater";
}
It is considered best practice to format multiple conditional operators such that each condition is on a separate line, as shown above. Using multiple conditional operators without proper indentation may make your code hard to read. For example:
function findGreaterOrEqual(a, b) {
  return (a === b) ? "a and b are equal" : (a > b) ? "a is greater" : "b is greater";
}
In the checkSign function, use multiple conditional operators - following the recommended format used in findGreaterOrEqual - to check if a number is positive, negative or zero. The function should return positive, negative or zero.

Logical operators
Operators that test whether a given condition is met
  and &&, or ||, not !
  && evaluates to true if the values on both sides are true.
  || evaluates to true if either one of the values is true.
  ! works on just one value, and gives the opposite of a value. Therefore, !true evaluates to false, and !false evaluates to true.
  short-circuiting
    && (and) returns the first falsy value, or the last value if no values are falsy.
    || (or) returns the first truthy value, or the last value if no values are truthy.

Comparison operators
Mathematical symbols that compare two values
  strict equality =====
  loose equality ====
  relational operators
  greater than >
  less than <
  greater than >=
  less than <=
  not equal !==


Storing Values with the Assignment Operator
In JavaScript, you can store a value in a variable with the assignment operator (=).
myVariable = 5;
This assigns the Number value 5 to myVariable.
If there are any calculations to the right of the = operator, those are performed before the value is assigned to the variable on the left of the operator.
var myVar;
myVar = 5;
First, this code creates a variable named myVar. Then, the code assigns 5 to myVar. Now, if myVar appears again in the code, the program will treat it as if it is 5.

JavaScript Arithmetic
JavaScript Arithmetic Operators

Arithmetic operators perform arithmetic on numbers (literals or variables).
Operator 	Description
+ 	Addition
- 	Subtraction

Use the Spread Operator to Evaluate Arrays In-Place
ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.
The ES5 code below uses apply() to compute the maximum value in an array:
var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr);
maximus would have a value of 89.
We had to use Math.max.apply(null, arr) because Math.max(arr) returns NaN. Math.max() expects comma-separated arguments, but not an array. The spread operator makes this syntax much better to read and maintain.
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
maximus would have a value of 89.
...arr returns an unpacked array. In other words, it spreads the array. However, the spread operator only works in-place, like in an argument to a function or in an array literal. The following code will not work:
const spreaded = ...arr;
Copy all contents of arr1 into another array arr2 using the spread operator.

Use Destructuring Assignment to Extract Values from Objects
Destructuring assignment is special syntax introduced in ES6, for neatly assigning values taken directly from an object.
Consider the following ES5 code:
const user = { name: 'John Doe', age: 34 };
const name = user.name;
const age = user.age;
name would have a value of the string John Doe, and age would have the number 34.
Here's an equivalent assignment statement using the ES6 destructuring syntax:
const { name, age } = user;
Again, name would have a value of the string John Doe, and age would have the number 34.
Here, the name and age variables will be created and assigned the values of their respective values from the user object. You can see how much cleaner this is.
You can extract as many or few values from the object as you want.
Replace the two assignments with an equivalent destructuring assignment. It should still assign the variables today and tomorrow the values of today and tomorrow from the HIGH_TEMPERATURES object.

Use Destructuring Assignment to Assign Variables from Objects
Destructuring allows you to assign a new variable name when extracting values. You can do this by putting the new name after a colon when assigning the value.
Using the same object from the last example:
const user = { name: 'John Doe', age: 34 };
Here's how you can give new variable names in the assignment:
const { name: userName, age: userAge } = user;
You may read it as "get the value of user.name and assign it to a new variable named userName" and so on. The value of userName would be the string John Doe, and the value of userAge would be the number 34.
Replace the two assignments with an equivalent destructuring assignment. It should still assign the variables highToday and highTomorrow the values of today and tomorrow from the HIGH_TEMPERATURES object.
** control flow

Control flow Also called flow of execution,
the tools provided by a programming language to conditionally determine which set of instructions runs

Conditional statement
A statement that tells the code to perform different tasks based on different kinds of information

if statement
if (condition) {
  statement
}
#+begin_src js
if (1 === 1) {
    console.log("hello")
}
#+end_src

if else statement
if (condition) {
  statement1
} else {
  statement2
}

#+begin_src js
if (1 === 2) {
    console.log("hello");
} else {
    console.log("world");
}
#+end_src

if else if statement
if (condition) {
  statement1
} else if {
  statement2
} else {
  statement3
}

#+begin_src js
if (1 === 2) {
    console.log("hello");
} else if  ( 2 === 2 ){
    console.log("foo");
} else {
    console.log("world");
}
#+end_src

Use Conditional Logic with If Statements
if statements are used to make decisions in code. The keyword if tells JavaScript to execute the code in the curly braces under certain conditions, defined in the parentheses. These conditions are known as Boolean conditions and they may only be true or false.
When the condition evaluates to true, the program executes the statement inside the curly braces. When the Boolean condition evaluates to false, the statement inside the curly braces will not execute.
Pseudocode
if (condition is true) {
  statement is executed
}
Example
function test (myCondition) {
  if (myCondition) {
    return "It was true";
  }
  return "It was false";
}
test(true);
test(false);
test(true) returns the string It was true, and test(false) returns the string It was false.
When test is called with a value of true, the if statement evaluates myCondition to see if it is true or not. Since it is true, the function returns It was true. When we call test with a value of false, myCondition is not true and the statement in the curly braces is not executed and the function returns It was false.
Create an if statement inside the function to return Yes, that was true if the parameter wasThatTrue is true and return No, that was false otherwise.

Comparison with the Greater Than Or Equal To Operator
The greater than or equal to operator (>=) compares the values of two numbers. If the number to the left is greater than or equal to the number to the right, it returns true. Otherwise, it returns false.
Like the equality operator, the greater than or equal to operator will convert data types while comparing.
Examples
6   >=  6  // true
7   >= '3' // true
2   >=  3  // false
'7' >=  9  // false
Add the greater than or equal to operator to the indicated lines so that the return statements make sense.

Comparison with the Less Than Operator
The less than operator (<) compares the values of two numbers. If the number to the left is less than the number to the right, it returns true. Otherwise, it returns false. Like the equality operator, the less than operator converts data types while comparing.
Examples
2   < 5 // true
'3' < 7 // true
5   < 5 // false
3   < 2 // false
'8' < 4 // false
Add the less than operator to the indicated lines so that the return statements make sense.

Comparison with the Less Than Or Equal To Operator
The less than or equal to operator (<=) compares the values of two numbers. If the number to the left is less than or equal to the number to the right, it returns true. If the number on the left is greater than the number on the right, it returns false. Like the equality operator, the less than or equal to operator converts data types.
Examples
4   <= 5 // true
'7' <= 7 // true
5   <= 5 // true
3   <= 2 // false
'8' <= 4 // false
Add the less than or equal to operator to the indicated lines so that the return statements make sense.

Comparisons with the Logical And Operator
Sometimes you will need to test more than one thing at a time. The logical and operator (&&) returns true if and only if the operands to the left and right of it are true.
The same effect could be achieved by nesting an if statement inside another if:
if (num > 5) {
  if (num < 10) {
    return "Yes";
  }
}
return "No";
will only return Yes if num is greater than 5 and less than 10. The same logic can be written as:
if (num > 5 && num < 10) {
  return "Yes";
}
return "No";
Replace the two if statements with one statement, using the && operator, which will return the string Yes if val is less than or equal to 50 and greater than or equal to 25. Otherwise, will return the string No.

Comparisons with the Logical Or Operator
The logical or operator (||) returns true if either of the operands is true. Otherwise, it returns false.
The logical or operator is composed of two pipe symbols: (||). This can typically be found between your Backspace and Enter keys.
The pattern below should look familiar from prior waypoints:
if (num > 10) {
  return "No";
}
if (num < 5) {
  return "No";
}
return "Yes";
will return Yes only if num is between 5 and 10 (5 and 10 included). The same logic can be written as:
if (num > 10 || num < 5) {
  return "No";
}
return "Yes";
Combine the two if statements into one statement which returns the string Outside if val is not between 10 and 20, inclusive. Otherwise, return the string Inside.

Introducing Else Statements
When a condition for an if statement is true, the block of code following it is executed. What about when that condition is false? Normally nothing would happen. With an else statement, an alternate block of code can be executed.
if (num > 10) {
  return "Bigger than 10";
} else {
  return "10 or Less";
}
Combine the if statements into a single if/else statement.

Introducing Else If Statements
If you have multiple conditions that need to be addressed, you can chain if statements together with else if statements.
if (num > 15) {
  return "Bigger than 15";
} else if (num < 5) {
  return "Smaller than 5";
} else {
  return "Between 5 and 15";
}
Convert the logic to use else if statements.

Logical Order in If Else Statements
Order is important in if, else if statements.
The function is executed from top to bottom so you will want to be careful of what statement comes first.
Take these two functions as an example.
Here's the first:
function foo(x) {
  if (x < 1) {
    return "Less than one";
  } else if (x < 2) {
    return "Less than two";
  } else {
    return "Greater than or equal to two";
  }
}
And the second just switches the order of the statements:
function bar(x) {
  if (x < 2) {
    return "Less than two";
  } else if (x < 1) {
    return "Less than one";
  } else {
    return "Greater than or equal to two";
  }
}
While these two functions look nearly identical if we pass a number to both we get different outputs.
foo(0)
bar(0)
foo(0) will return the string Less than one, and bar(0) will return the string Less than two.
Change the order of logic in the function so that it will return the correct statements in all cases.

Chaining If Else Statements
if/else statements can be chained together for complex logic. Here is pseudocode of multiple chained if / else if statements:
if (condition1) {
  statement1
} else if (condition2) {
  statement2
} else if (condition3) {
  statement3
. . .
} else {
  statementN
}
Write chained if/else if statements to fulfill the following conditions:
num < 5 - return Tiny
num < 10 - return Small
num < 15 - return Medium
num < 20 - return Large
num >= 20 - return Huge

Selecting from Many Options with Switch Statements
If you have many options to choose from, use a switch statement. A switch statement tests a value and can have many case statements which define various possible values. Statements are executed from the first matched case value until a break is encountered.
Here is an example of a switch statement:
switch (lowercaseLetter) {
  case "a":
    console.log("A");
    break;
  case "b":
    console.log("B");
    break;
}
case values are tested with strict equality (===). The break tells JavaScript to stop executing statements. If the break is omitted, the next statement will be executed.
Write a switch statement which tests val and sets answer for the following conditions:
1 - alpha
2 - beta
3 - gamma
4 - delta

Adding a Default Option in Switch Statements
In a switch statement you may not be able to specify all possible values as case statements. Instead, you can add the default statement which will be executed if no matching case statements are found. Think of it like the final else statement in an if/else chain.
A default statement should be the last case.
switch (num) {
  case value1:
    statement1;
    break;
  case value2:
    statement2;
    break;
...
  default:
    defaultStatement;
    break;
}
Write a switch statement to set answer for the following conditions:
a - apple
b - bird
c - cat
default - stuff

Multiple Identical Options in Switch Statements
If the break statement is omitted from a switch statement's case, the following case statement(s) are executed until a break is encountered. If you have multiple inputs with the same output, you can represent them in a switch statement like this:
let result = "";
switch (val) {
  case 1:
  case 2:
  case 3:
    result = "1, 2, or 3";
    break;
  case 4:
    result = "4 alone";
}
Cases for 1, 2, and 3 will all produce the same result.
Write a switch statement to set answer for the following ranges:
1-3 - Low
4-6 - Mid
7-9 - High
Note: You will need to have a case statement for each number in the range.

Replacing If Else Chains with Switch
If you have many options to choose from, a switch statement can be easier to write than many chained if/else if statements. The following:
if (val === 1) {
  answer = "a";
} else if (val === 2) {
  answer = "b";
} else {
  answer = "c";
}
can be replaced with:
switch (val) {
  case 1:
    answer = "a";
    break;
  case 2:
    answer = "b";
    break;
  default:
    answer = "c";
}
Change the chained if/else if statements into a switch statement.

Control flow
    Also called flow of execution, the tools provided by a programming language to conditionally determine which set of instructions runs

JavaScript if, else, and else if

Conditional statements are used to perform different actions based on different conditions.
Conditional Statements

Very often when you write code, you want to perform different actions for different decisions.

You can use conditional statements in your code to do this.

In JavaScript we have the following conditional statements:

    Use if to specify a block of code to be executed, if a specified condition is true
    Use else to specify a block of code to be executed, if the same condition is false
    Use else if to specify a new condition to test, if the first condition is false
    Use switch to specify many alternative blocks of code to be executed

The switch statement is described in the next chapter.
The if Statement

Use the if statement to specify a block of JavaScript code to be executed if a condition is true.
Syntax
if (condition) {
  //  block of code to be executed if the condition is true
}

Note that if is in lowercase letters. Uppercase letters (If or IF) will generate a JavaScript error.
Example

Make a "Good day" greeting if the hour is less than 18:00:
if (hour < 18) {
  greeting = "Good day";
}

The result of greeting will be:
Good day
The else Statement

Use the else statement to specify a block of code to be executed if the condition is false.
if (condition) {
  //  block of code to be executed if the condition is true
} else {
  //  block of code to be executed if the condition is false
}
Example

If the hour is less than 18, create a "Good day" greeting, otherwise "Good evening":
if (hour < 18) {
  greeting = "Good day";
} else {
  greeting = "Good evening";
}

The result of greeting will be:
Good day
The else if Statement

Use the else if statement to specify a new condition if the first condition is false.
Syntax
if (condition1) {
  //  block of code to be executed if condition1 is true
} else if (condition2) {
  //  block of code to be executed if the condition1 is false and condition2 is true
} else {
  //  block of code to be executed if the condition1 is false and condition2 is false
}
Example

If time is less than 10:00, create a "Good morning" greeting, if not, but time is less than 20:00, create a "Good day" greeting, otherwise a "Good evening":
if (time < 10) {
  greeting = "Good morning";
} else if (time < 20) {
  greeting = "Good day";
} else {
  greeting = "Good evening";
}

The result of greeting will be:
Good day
More Examples

Random link
This example will write a link to either W3Schools or to the World Wildlife Foundation (WWF). By using a random number, there is a 50% chance for each of the links.
Test Yourself With Exercises
Exercise:

Fix the if statement to alert "Hello World" if x is greater than y.

if x > y
  alert("Hello World");


Start the Exercise

JavaScript Switch Statement

The switch statement is used to perform different actions based on different conditions.
The JavaScript Switch Statement

Use the switch statement to select one of many code blocks to be executed.
Syntax
switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}

This is how it works:

    The switch expression is evaluated once.
    The value of the expression is compared with the values of each case.
    If there is a match, the associated block of code is executed.
    If there is no match, the default code block is executed.

Example

The getDay() method returns the weekday as a number between 0 and 6.

(Sunday=0, Monday=1, Tuesday=2 ..)

This example uses the weekday number to calculate the weekday name:
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
     day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
}

The result of day will be:
Saturday
The break Keyword

When JavaScript reaches a break keyword, it breaks out of the switch block.

This will stop the execution inside the switch block.

It is not necessary to break the last case in a switch block. The block breaks (ends) there anyway.

Note: If you omit the break statement, the next case will be executed even if the evaluation does not match the case.
The default Keyword

The default keyword specifies the code to run if there is no case match:
Example

The getDay() method returns the weekday as a number between 0 and 6.

If today is neither Saturday (6) nor Sunday (0), write a default message:
switch (new Date().getDay()) {
  case 6:
    text = "Today is Saturday";
    break;
  case 0:
    text = "Today is Sunday";
    break;
  default:
    text = "Looking forward to the Weekend";
}

The result of text will be:
Today is Saturday

The default case does not have to be the last case in a switch block:
Example
switch (new Date().getDay()) {
  default:
    text = "Looking forward to the Weekend";
    break;
  case 6:
    text = "Today is Saturday";
    break;
  case 0:
    text = "Today is Sunday";
}

If default is not the last case in the switch block, remember to end the default case with a break.
Common Code Blocks

Sometimes you will want different switch cases to use the same code.

In this example case 4 and 5 share the same code block, and 0 and 6 share another code block:
Example
switch (new Date().getDay()) {
  case 4:
  case 5:
    text = "Soon it is Weekend";
    break;
  case 0:
  case 6:
    text = "It is Weekend";
    break;
  default:
    text = "Looking forward to the Weekend";
}
Switching Details

If multiple cases matches a case value, the first case is selected.

If no matching cases are found, the program continues to the default label.

If no default label is found, the program continues to the statement(s) after the switch.
Strict Comparison

Switch cases use strict comparison (===).

The values must be of the same type to match.

A strict comparison can only be true if the operands are of the same type.

In this example there will be no match for x:
Example
let x = "0";
switch (x) {
  case 0:
    text = "Off";
    break;
  case 1:
    text = "On";
    break;
  default:
    text = "No value found";
}
Test Yourself With Exercises
Exercise:

Create a switch statement that will alert "Hello" if fruits is "banana", and "Welcome" if fruits is "apple".

(fruits) {
  "Banana":
    alert("Hello")
    break;
  "Apple":
    alert("Welcome")
    break;
}


Start the Exercise

*** control flow thinkful

Control flow
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to write if/else statements concisely. You'll also be able to use switch statements to control the flow of programs.

Overview
You already know how to use if/else statements to control the flow of code. And although you can always effectively control the flow of the code with the if/else statements that you've learned so far, there are some additional tools that can make your code simpler. In this lesson, you will explore different ways of writing if/else statements. You'll also learn about switch statements, which offer another way of controlling the flow of programs.

It's important to know the various tools that you have available as a developer. Ultimately, the tool that you'll use in specific cases will likely come down to your personal preferences.

Start by watching the video below, which provides a brief introduction to simple if statements and the switch statement. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


Single-line if statements
There's a lot of talk about if/else statements. And with good reason—they're pretty useful. But sometimes you don't need an else statement as part of your conditional. Take a look:

function getPrice(product) {
  let price = product.priceInCents;
  if (product.onSale) {
    price = price * 0.9;
  }

  return price;
}

const product = {
  priceInCents: 2100,
  name: "Red Beanie",
  size: "L",
  onSale: true,
};
getPrice(product); //> 1890
Here, the getPrice() function applies a 10% discount to any item that has onSale set to a truthy value. And although the above code sample is perfectly fine, you may also see the following:

function getPrice(product) {
  let price = product.priceInCents;
  if (product.onSale) price = price * 0.9;

  return price;
}
This function definition, by contrast, has removed that set of curly brackets {} and has instead added the remaining line, price=price*0.9, to the line above it. However, you should only consolidate lines like this in your own code if the content inside the block is very short. Otherwise, it will be too difficult to read.

It's important to note that there is no substantive difference between these two options. They simply look different.

The conditional operator
The conditional operator, also commonly called the ternary operator, is a way to write a short if/else statement. It should be used only if the overall if/else statement is very short. The syntax works like this:

(conditional expression) ? (expression if true) : (expression if false)
Take a look at the following rewrite of the getPrice() function. As you can see, this function is now much more concise, which makes it cleaner and easier to read.

function getPrice(product) {
  return product.onSale ? product.priceInCents * 0.9 : product.priceInCents;
}
To make sure you understand what is happening here, take a moment to break this down. The expression before the question mark is the conditional. If it evaluates to a truthy value, the expression after the ? will be returned. But if the conditional evaluates to a falsy value, the expression after the colon : will be returned.

When it comes to comparing the options discussed here, there's no one best approach. The single-line if statement, the conditional operator, and a full if/else statement can all work for you. Over time, you'll develop preferences based on which method you find to be clearest and easiest to read. However, because you're still learning the ropes, you should default to writing out the full statement for the time being. This will help you become comfortable with the process before you start abbreviating it.

To learn more, check out MDN's page about the conditional operator.

The switch statement
Sometimes, like in the cases noted above, your if/else statements can be quite short. But sometimes, they can be very long.

Take a look at this example. What do you think this code does?

function getStateSalesTax(stateAbbreviation) {
  let result;
  if (stateAbbreviation === "CA") {
    result = 0.0725;
  } else if (stateAbbreviation === "CO") {
    result = 0.029;
  } else if (stateAbbreviation === "GA") {
    result = 0.04;
  } else if (stateAbbreviation === "VT") {
    result = 0.06;
  } else {
    result = 0;
  }

  return result;
}
The code above is actually pretty straightforward—depending on the state that is inputted, a different value (in this case, a sales tax amount) is returned. But this might feel a bit clunky. Fortunately, there's another way that you could write the function above: with the switch statement.

function getStateSalesTax(stateAbbreviation) {
  let result;
  switch (stateAbbreviation) {
    case "CA":
      result = 0.0725;
      break;
    case "CO":
      result = 0.029;
      break;
    case "GA":
      result = 0.04;
      break;
    case "VT":
      result = 0.06;
      break;
    default:
      result = 0;
  }

  return result;
}
So, what's happening here? Right after the switch keyword is introduced, the given expression is evaluated. Then, a matching case is searched for using strict equality. If anything matches, it runs the code in that case. The break keyword stops the current switch statement, preventing the code from running for any more cases. If no matching value is found, the default runs.

Usually, case statements will use break between each case. This can help you avoid getting behavior or results that you don't expect.

Sometimes, the fallthrough behavior is helpful. For example, look at this code sample:

function getStateSalesTax(stateAbbreviation) {
  let result;
  switch (stateAbbreviation) {
    case "CA":
      result = 0.0725;
      break;
    case "CO":
      result = 0.029;
      break;
    case "GA":
      result = 0.04;
      break;
    case "MD":
    case "VT":
    case "WV":
      result = 0.06;
      break;
    default:
      result = 0;
  }

  return result;
}
In this example, "MD", "VT", and "WV" all have the same sales tax. Entering any one of those values will set the result to the same value.

The two functions discussed above will work in similar ways. Ultimately, it'll be up to you when you want to use a switch statement instead of a longer if/else statement.

If you want to learn more, consult MDN's page on the switch statement.

** js function wip

A Function is a block of code that describes a repeatable process or behavior

function syntax

A function delaration is a statement that creates a new named function.
A function body is a set of instructions contained within a function.


The function keyword defines a function
The function identifier is the function name
  how you refer to the function later.
The function body goes inside curly brackets {}


  functionDeclaration functionIdentifier(para1, para2){}
Function body

Function call runs the function; run/call/invoke the function
  functionIdentifier();
  functionIdentifier(arg1, arg2);


All of the code between the curly braces will be executed every time the function is called.

javascript function:
  Reuse code
  Transform inputs into outputs
  Solve pieces of a problem

function nameFunc(input) {
  body;
  return output;
}

call a function, running or invoking a function
funcName();



Input: Parameters and arguments

function favFood(food) {
  console.log(food);
}
favFood(pizza);

multiple parameters
function funcName(para1, para2){
}
funcName("foo", "bar")

return
function add(num1, num2) {
  return num1 + num2;
}


Function scope
    The "bubble" in which a variable is accessible or visible

Helper function
A function that helps clean up code by handling a section of a larger function

// create findItems takes two args items and type return an array
function findItems(items, matchType){
  let matches = [];
  // check if items is empty
  if ( items.length === 0){
    return "Your cart does not have any items in it."
  }
  // matching items with type
  for (let i = 0; i < items.length; i++){
    if (items[i].type.includes(matchType)){
      matches.push(items[i]);
    }
  }
  // check if matches is empty
  if ( matches.length === 0){
    return "No items found of that type. Please search for a different item."
  }
  // return matches
  return matches.length == 0 ? "No items found of that type. Please search for a
different item" : matches
}



JavaScript Functions

A JavaScript function is a block of code designed to perform a particular task.

A JavaScript function is executed when "something" invokes it (calls it).

JavaScript Function Syntax
A JavaScript function is defined with the function keyword, followed by a name, followed by parentheses ().

Function names can contain letters, digits, underscores, and dollar signs (same rules as variables).

The parentheses may include parameter names separated by commas:
(parameter1, parameter2, ...)

The code to be executed, by the function, is placed inside curly brackets: {}
function name(parameter1, parameter2, parameter3) {
  // code to be executed
}

Function parameters are listed inside the parentheses () in the function definition.

Function arguments are the values received by the function when it is invoked.

Inside the function, the arguments (the parameters) behave as local variables.

A Function is much the same as a Procedure or a Subroutine, in other programming languages.

Function Invocation
The code inside the function will execute when "something" invokes (calls) the function:

    When an event occurs (when a user clicks a button)
    When it is invoked (called) from JavaScript code
    Automatically (self invoked)

You will learn a lot more about function invocation later in this tutorial.


Why Functions?

You can reuse code: Define the code once, and use it many times.

You can use the same code many times with different arguments, to produce different results.
Example

Convert Fahrenheit to Celsius:
function toCelsius(fahrenheit) {
  return (5/9) * (fahrenheit-32);
}
document.getElementById("demo").innerHTML = toCelsius(77);
The () Operator Invokes the Function

Using the example above, toCelsius refers to the function object, and toCelsius() refers to the function result.

Accessing a function without () will return the function object instead of the function result.
Example
function toCelsius(fahrenheit) {
  return (5/9) * (fahrenheit-32);
}
document.getElementById("demo").innerHTML = toCelsius;

Functions Used as Variable Values

Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations.
Example

Instead of using a variable to store the return value of a function:
let x = toCelsius(77);
let text = "The temperature is " + x + " Celsius";

You can use the function directly, as a variable value:
let text = "The temperature is " + toCelsius(77) + " Celsius";

You will learn a lot more about functions later in this tutorial.
Local Variables

Variables declared within a JavaScript function, become LOCAL to the function.

Local variables can only be accessed from within the function.
Example
// code here can NOT use carName

function myFunction() {
  let carName = "Volvo";
  // code here CAN use carName
}

// code here can NOT use carName

Since local variables are only recognized inside their functions, variables with the same name can be used in different functions.

Local variables are created when a function starts, and deleted when the function is completed.
Test Yourself With Exercises
Exercise:

Execute the function named myFunction.

function myFunction() {
  alert("Hello World!");
}
;

*** js function parameters and arguments

A Parameter is a placeholder variable listed in a function declaration.
An argument is a value or other input thats passed into a called function.

Parameters are the function's inputs.
Arguments are the values inbetween the parentheses, when you invoke a function
  its the input to function.
  functionIdentifier(arg1, arg2);
Call the function.

Passing Values to Functions with Arguments
Parameters are variables that act as placeholders for the values that are to be input to a function when it is called.
The actual values that are input (or "passed") into a function when it is called are known as arguments.

Here is a function with two parameters, param1 and param2:
function testFun(param1, param2) {
  console.log(param1, param2);
}
Then we can call testFun like this: testFun("Hello", "World");.
We have passed two string arguments, Hello and World.
Inside the function, param1 will equal the string Hello and param2 will equal the string World.
Set Default Parameters for Your Functions
In order to help us create more flexible functions, ES6 introduces default parameters for functions.
Check out this code:
const greeting = (name = "Anonymous") => "Hello " + name;
console.log(greeting("John"));
console.log(greeting());
The console will display the strings Hello John and Hello Anonymous.
The default parameter kicks in when the argument is not specified (it is undefined). As you can see in the example above, the parameter name will receive its default value Anonymous when you do not provide a value for the parameter. You can add default values for as many parameters as you want.
Modify the function increment by adding default parameters so that it will add 1 to number if value is not specified.

Use the Rest Parameter with Function Parameters
In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function.
Check out this code:
function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));
console.log(howMany("string", null, [1, 2, 3], { }));
The console would display the strings You have passed 3 arguments. and You have passed 4 arguments..
The rest parameter eliminates the need to check the args array and allows us to apply map(), filter() and reduce() on the parameters array.
Modify the function sum using the rest parameter in such a way that the function sum is able to take any number of arguments and return their sum.
*** js function returns

The return value is the value that a function outputs, as specified by the return keyword.

Whenever JavaScript sees return in a function, it does the following:
+ Stops running the code in that function
+ Takes the value to the right of return
+ Swaps in the return value where the function was called

A function returns undefined by default.
A function without return keyword, returns undefined.
A function can only return one value.
returns keyword is use for function's output
the function's output is what the function sends back.
functions stop running when the see return.
function can only return one value.
Return a Value from a Function with Return
We can pass values into a function with arguments. You can use a return statement to send a value back out of a function.
Example
function plusThree(num) {
  return num + 3;
}
const answer = plusThree(5);
answer has the value 8.
plusThree takes an argument for num and returns a value equal to num + 3.
Create a function timesFive that accepts one argument, multiplies it by 5, and returns the new value.
Understanding Undefined Value returned from a Function
A function can include the return statement but it does not have to. In the case that the function doesn't have a return statement, when you call it, the function processes the inner code but the returned value is undefined.
Example
let sum = 0;
function addSum(num) {
  sum = sum + num;
}
addSum(3);
addSum is a function without a return statement. The function will change the global sum variable but the returned value of the function is undefined.
Create a function addFive without any arguments. This function adds 5 to the sum variable, but its returned value is undefined.

Assignment with a Returned Value
If you'll recall from our discussion of Storing Values with the Assignment Operator, everything to the right of the equal sign is resolved before the value is assigned. This means we can take the return value of a function and assign it to a variable.
Assume we have pre-defined a function sum which adds two numbers together, then:
ourSum = sum(5, 12);
will call the sum function, which returns a value of 17 and assigns it to the ourSum variable.
Call the processArg function with an argument of 7 and assign its return value to the variable processed.
Returning Boolean Values from Functions
You may recall from Comparison with the Equality Operator that all comparison operators return a boolean true or false value.
Sometimes people use an if/else statement to do a comparison, like this:
function isEqual(a, b) {
  if (a === b) {
    return true;
  } else {
    return false;
  }
}
But there's a better way to do this. Since === returns true or false, we can return the result of the comparison:

function isEqual(a, b) {
  return a === b;
}
Fix the function isLess to remove the if/else statements.

Return Early Pattern for Functions
When a return statement is reached, the execution of the current function stops and control returns to the calling location.
Example
function myFun() {
  console.log("Hello");
  return "World";
  console.log("byebye")
}
myFun();
The above will display the string Hello in the console, and return the string World. The string byebye will never display in the console, because the function exits at the return statement.
Modify the function abTest so that if a or b are less than 0 the function will immediately exit with a value of undefined.
Hint
Remember that undefined is a keyword, not a string.
Function Return
When JavaScript reaches a return statement, the function will stop executing.

If the function was invoked from a statement, JavaScript will "return" to execute the code after the invoking statement.

Functions often compute a return value. The return value is "returned" back to the "caller":
Example

Calculate the product of two numbers, and return the result:
let x = myFunction(4, 3);   // Function is called, return value will end up in x

function myFunction(a, b) {
  return a * b;             // Function returns the product of a and b
}

The result in x will be:
12
*** js function example
#+begin_src js
let array = [1 , 2 , 3 , 4];
// return length of an array
function arrayLength(array){
    return array.length;
}
console.log(arrayLength(array));

// add numbers in array
function arraySum(array){
    sum = 0;
    for (let i = 0; i < array.length; i++){
        sum += array[i];
    }
    return sum;
}
console.log(arraySum(array));
#+end_src

function functionName() {
  console.log("Hello World");
}
*** default parameter thinkful

Setting defaults
Take a look at the following function. What do you notice?

function calculatePriceInDollars(priceInCents) {
  return priceInCents / 100;
}

This simple function converts cents to dollars.
It takes a number—in this case, a specific amount of money—and then divides it by 100.
However, if no argument is entered when the function is called, it will result in NaN.
This can be seen below.

calculatePriceInDollars(100); //> 1  (Returns 1 because 100 cents = 1 dollar)
calculatePriceInDollars(250); //> 2.5
calculatePriceInDollars(); //> NaN

But imagine that you want the value to be 0 instead of NaN if no argument is entered.
In this case, you can set 0 as the default for the priceInCents parameter.
Setting a default means that you've identified a value to be there even if a specific value is missing from the function call.

function calculatePriceInDollars(priceInCents = 0) {
  return priceInCents / 100;
}

calculatePriceInDollars(); //> 0

To set a default, place an equals sign = after the parameter name, followed by whatever value you want to use as the default. This value can be anything valid in JavaScript.

If the value of that parameter is undefined when the function is called, it will be replaced with the value that you've provided.

Why use defaults?
At this point, you may be wondering: instead of using default parameters, shouldn't you just make sure that your functions are always called correctly?
Indeed, in the above example of the calculatePriceInDollars() function, it might seem like it would make more sense to just always use an argument.
And in general, this is true—it is better to simply use your functions as intended rather than set numerous defaults.

However, defaults can be particularly useful in a few circumstances:
    If there is a typical case for your function, but you want to allow for certain options, you might use defaults.
    If one or more of the argument values that you're using come from an outside source, you might use defaults because you won't necessarily be able to control the input values.

Consider the example below.

function welcomeMessage(name, isReturnCustomer = false) {
  const message = isReturnCustomer ? "Welcome back" : "Welcome";
  return `${message}, ${name}!`;
}

You may expect the above function to pass in only a single argument typically. However, if the customer is a returning customer, you could easily change the message by adding a second argument. In this case, the function could use defaults to allow for a typical case with some options.

Object defaults
Now, you'll investigate object defaults.

Code setup
You'll use the code below for the following examples. So take a moment to review this function and figure out how it's used.

// Function definition
function calculateTotal(products, { discountPercentage, salesTax }) {
  let result = 0;
  for (let i = 0; i < products.length; i++) {
    const { priceInCents, quantity } = products[i];
    result += priceInCents * quantity;
  }

  if (discountPercentage) result *= 1 - discountPercentage;
  return result * (1 + salesTax);
}

// Inputs
const products = [
  {
    name: "Black Longline T-Shirt",
    priceInCents: 1500,
    size: "M",
    quantity: 2,
  },
  {
    name: "Light Wash Stretch Skinny Jeans",
    priceInCents: 6000,
    size: 32,
    quantity: 1,
  },
];
const options = { discountPercentage: 0.1, salesTax: 0.0825 };

// Function call
calculateTotal(products, options); //> 8768.25

The above function takes in an array of products and calculates the total. If discountPercentage is included in the options parameter, it will apply a discount. It will then add salesTax to the total.

Do this
Run calculateTotal()

Copy the function above and paste it into a place or program, such as a code editor, where you can edit it and then run the function. Try changing the quantities and options to see what happens.
Set an object as a default

Now, in the case of the function above, imagine that there are no discounts, and you just want to use a standard sales tax. In this situation, you may want to just call the function without passing anything in. However, this will result in an error.

calculateTotal(products);
//> Uncaught TypeError:
//> Cannot destructure property 'discountAmount' of 'undefined' as it is undefined.

The issue above is that there is no object to destructure, so the code fails to create those variables. But just like you saw above, you can set a default parameter by adding an = sign followed by the default value.

function calculateTotal(products, { discountPercentage, salesTax } = {}) {
  // ...
}

What is happening in the function signature above? Take a look:
    If there is an object passed in as the second argument, the code will destructure that argument and assign the discountPercentage and salesTax variables.
    If there isn't an object passed in as the second argument, the code will default to an object. Then it will attempt to destructure that empty object. The variables will exist, but they will both be set to undefined.

Update calculateTotal()
Update the calculateTotal() function with the above code. Try running it once more, only passing in products as an argument. Is the result what you expected? Or is it different?

Default key values
If you run the function above without a second argument, it will run. But it will give you an undesirable result.

calculateTotal(products); //> NaN

In this case, the result will be NaN because salesTax is undefined. This problem can be solved by using more defaults.

function calculateTotal(products, { discountPercentage, salesTax = 0.0825 } = {}) {
  // ...
}

The code above sets a default value for the key in the object. If salesTax is undefined, salesTax will in fact be set to the value of 0.0825.
Now, if you call this function with products as the only argument, it will work correctly.

calculateTotal(products); //> 9742.5

Do this
Include default values

Update your calculateTotal() function so that it includes a default for the salesTax value. Try running the function once again. What is the result?

Setting a default array
With this practice under your belt, you're ready for one final modification. You can update the code so that if products happens to be undefined, the function will just return 0. Specifically, you would change the function signature to look like the one below:

function calculateTotal(products = [], { discountPercentage, salesTax } = {}) {
  // ...
}

The above code sets the default for products to be an empty array. This means that the for loop will still be able to run.

calculateTotal(); //> 0

The entire updated function is below.

function calculateTotal(products = [], { discountPercentage, salesTax = 0.0825 } = {}) {
  let result = 0;
  for (let i = 0; i < products.length; i++) {
    const { priceInCents, quantity } = products[i];
    result += priceInCents * quantity;
  }

  if (discountPercentage) result *= 1 - discountPercentage;
  return result * (1 + salesTax);
}


An aside: Pass by reference or value?

    Primitives (string, number, boolean) are passed by value
    Complex data types (arrays, objects) are passed by reference

let myNumber = 10;

function passedPrimitive(num) {
  num = 20;
}

passedPrimitive(myNumber);
console.log(myNumber);   // => 10

function receives a copy of the value - local scope cannot impact the original variable

const mySequence = [1,2,3];

function passedComplex(arr) {
  arr.push(4);
}

passedComplex(mySequence);
console.log(mySequence);  // => [1,2,3,4]

function receives a reference to the item - the local variable assigned to this item is impacting the original item

** JavaScript Arrow Function

Arrow functions were introduced in ES6.

Arrow functions allow us to write shorter function syntax:

let myFunction = (a, b) => a * b;

Before:
hello = function() {
  return "Hello World!";
}

With Arrow Function:
hello = () => {
  return "Hello World!";
}

It gets shorter! If the function has only one statement, and the statement returns a value, you can remove the brackets and the return keyword:

Arrow Functions Return Value by Default:
hello = () => "Hello World!";

Note: This works only if the function has only one statement.

If you have parameters, you pass them inside the parentheses:

Arrow Function With Parameters:
hello = (val) => "Hello " + val;

In fact, if you have only one parameter, you can skip the parentheses as well:

Arrow Function Without Parentheses:
hello = val => "Hello " + val;

What About this?
The handling of this is also different in arrow functions compared to regular functions.

In short, with arrow functions there are no binding of this.

In regular functions the this keyword represented the object that called the function, which could be the window, the document, a button or whatever.

With arrow functions the this keyword always represents the object that defined the arrow function.

Let us take a look at two examples to understand the difference.

Both examples call a method twice, first when the page loads, and once again when the user clicks a button.

The first example uses a regular function, and the second example uses an arrow function.

The result shows that the first example returns two different objects (window and button), and the second example returns the window object twice, because the window object is the "owner" of the function.

Example
With a regular function this represents the object that calls the function:

// Regular Function:
hello = function() {
  document.getElementById("demo").innerHTML += this;
}

// The window object calls the function:
window.addEventListener("load", hello);

// A button object calls the function:
document.getElementById("btn").addEventListener("click", hello);

Example
With an arrow function this represents the owner of the function:

// Arrow Function:
hello = () => {
  document.getElementById("demo").innerHTML += this;
}

// The window object calls the function:
window.addEventListener("load", hello);

// A button object calls the function:
document.getElementById("btn").addEventListener("click", hello);

Remember these differences when you are working with functions. Sometimes the behavior of regular functions is what you want, if not, use arrow functions.

Browser Support
The following table defines the first browser versions with full support for Arrow Functions in JavaScript:

Chrome 45	Edge 12	Firefox 22	Safari 10	Opera 32
Sep, 2015	Jul, 2015	May, 2013	Sep, 2016	Sep, 2015

Use Arrow Functions to Write Concise Anonymous Functions
In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don't need to name these functions because we do not reuse them anywhere else.
To achieve this, we often use the following syntax:
const myFunc = function() {
  const myVar = "value";
  return myVar;
}
ES6 provides us with the syntactic sugar to not have to write anonymous functions this way. Instead, you can use arrow function syntax:
const myFunc = () => {
  const myVar = "value";
  return myVar;
}
When there is no function body, and only a return value, arrow function syntax allows you to omit the keyword return as well as the brackets surrounding the code. This helps simplify smaller functions into one-line statements:
const myFunc = () => "value";
This code will still return the string value by default.
Rewrite the function assigned to the variable magic which returns a new Date() to use arrow function syntax. Also, make sure nothing is defined using the keyword var.

Write Arrow Functions with Parameters
Just like a regular function, you can pass arguments into an arrow function.
const doubler = (item) => item * 2;
doubler(4);
doubler(4) would return the value 8.
If an arrow function has a single parameter, the parentheses enclosing the parameter may be omitted.
const doubler = item => item * 2;
It is possible to pass more than one argument into an arrow function.
const multiplier = (item, multi) => item * multi;
multiplier(4, 2);
multiplier(4, 2) would return the value 8.
Rewrite the myConcat function which appends contents of arr2 to arr1 so that the function uses arrow function syntax.

** advanced functions
*** overview: advanced functions

JavaScript allows you to pass functions as if they were objects.
With this ability, you will learn how to implement the accumulator pattern that you learned early on, using different native array methods.

*** function expressions and arrow functions

Key Terms
Function expression A function created in a place where there would otherwise be a value
Anonymous function A function that doesn't have a name
Arrow syntax A way to write a compact function expression by using an arrow => to define the function
Arrow functions are shorter than the functions that you've written so far, and they can make it easier to see what's happening when there are lots of functions. They're also used frequently in higher-order functions, asynchronous code, and React. These are topics that you'll learn about later on.

Different types of functions
Read through this lesson and complete the practice work required. This will give you a full understanding of these concepts.

In JavaScript, there are two different ways to create functions: function declarations and function expressions.

A function declaration (also called a function definition or function statement) is JavaScript code that creates a new function with a name. This is the most common way to create functions, and it's the approach that you've seen so far in this program.

A function expression is a function created in a place where there would otherwise be a value. Functions created this way may or may not have a name.

Suppose that you wish to create a function that accepts a park object in the form { name: "Biscayne", rating: 4.2 } and returns "Excellent!" if the rating was greater than 4 and "Good" otherwise. Here are three different ways to implement that same function:

// Function declaration
function ratingAsText(park) {
  console.log("This is a function declaration.");
  return park.rating > 4 ? "Excellent!" : "Good";
}

// Function expression
const ratingAsTextNamed = function ratingToWord(park) {
  console.log("This is a function expression that has a name.");
  return park.rating > 4 ? "Excellent!" : "Good";
};

// Anonymous function expression
const ratingAsTextAnonymous = function (park) {
  console.log("This is an anonymous function that does not have a name.");
  return park.rating > 4 ? "Excellent!" : "Good";
};
The first function is a function declaration. It is the typical way to define functions. If you wanted to call this function, you would use the name of the function along with the argument list. For example, you could call ratingAsText(park).

The second function consists of two parts: the constant (ratingAsTextNamed ) and the function expression (ratingToWord(park)). Notice that the ratingToWord(park) function expression uses exactly the same syntax as a function declaration. The only difference is that the function is being assigned to a variable. You can call this function with ratingAsTextNamed(park). However, you cannot call the function using ratingToWord(park) unless the function is calling itself (you will learn more about this later).

The last function does not have a name, meaning that it is an anonymous function. It is an expression that is assigned to the variable ratingAsTextAnonymous, and it can be called with ratingAsTextAnonymous(park).

Arrow functions
Now, take a look at the following function expression:

const location = {
  name: "Arches",
  state: "Utah",
  geo: {
    lat: 38.68,
    lon: -109.57,
  },
};

const getLocationState = function (location) {
  return location.state;
};
The above function will return the state value of a given location object. Recall the different parts of the function syntax:

Labeled function syntax
You can rewrite this function using arrow syntax, like this:

Labeled arrow syntax
Instead of using the function keyword, this syntax uses an arrow => to define the function. Notice that the rest of the syntax is essentially the same.

const getLocationState = (location) => {
  return location.state;
};
There are a couple of important facts to keep in mind when using an arrow function:

If there is only one parameter, the parentheses () around the parameter are optional. For example, the function above accepts just one parameter, location, so you can leave out the parentheses around the parameter and write it like this:

const getLocationState = location => {
  return location.state;
};
If the function consists of just a single return statement, you can omit the curly brackets {} and just have the arrow point to the value being returned. For example, the body of the above function consists of just the statement return location.state, you can drop the return keyword and the {}. This means that you can write the function in an even more concise way:

const getLocationState = location => location.state;
Next, take a look at some more examples of arrow functions and their equivalent function declarations.

Get location name
// Arrow function
const getLocationName = (location) => location.name;

// Function declaration
function getLocationName(location) {
  return location.name;
}
Get Google Map URL
Tip
The return value in this function is quite long. If you still want to avoid using the return keyword, you can use parentheses.

// Arrow function
const getGoogleMapURL = ({ geo: { lat, lon } }, zoom = 10) => (
  `https://www.google.com/maps/@${lat},${lon},${zoom}z`
);

// Function declaration
function getLocationCoordinates({ geo: { lat, lon } }, zoom = 10) {
  return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
}
Which is better?
At the moment, there is no "right" answer as to whether you should use a function declaration or a function expression. Arrow functions are a newer feature of JavaScript, and you will see them often in upcoming lessons.

Note: Later on, you'll learn another reason to use arrow functions. This reason will have to do with the this keyword and something called execution context.

const cal = (length) => length ** 3;

*** higher-order functions

Callback function Also called a callback, a function that is passed into another function as an argument

Previously, you've learned to use loops to deal with data in arrays.
For example, you may have looped through an array to find a particular item, or to find all the items within a particular constraint.

These kinds of problems aren't unique. JavaScript has built-in array methods that can help you accomplish common data-manipulation tasks.

Higher-order functions


The built-in array methods that you will learn in this lesson and the next few are all called higher-order functions.

Key Term
Higher-order function: Any function that either accepts a function as one of its incoming arguments or returns a function

Higher-order functions are incredibly powerful, and they are used a lot in JavaScript.
Allowing for a function as an input or an output can lead to some very customizable tools.

For example, suppose that you created a shop and wished to give discounts on some items. You could create a function to calculate the discounted price as follows:

#+begin_src js
// using arrow function
// declaring constant variable with two parameters price and discount
// then times price by discount
const discountedPrice = (price, discount) => price * discount;
#+end_src

const discountedPrice = (price, discount) => price * discount;

Then you could call the function to calculate final prices for some items with a 10% discount, like this:
const finalPriceBed = discountedPrice(200, 0.9); // 90% of $200
const finalPricePillow = discountedPrice(52, 0.9); // 90% of $52
const finalPriceCurtain = discountedPrice(32, 0.9); // 90% of 32

Did you notice that in each case, you are passing the same value of 0.9? Instead, you could simply make a new function that calculates the 10% discount, and then you wouldn't need to pass that argument each time. But what if you sometimes wanted to give 25% discounts? You would then need another function that calculates the 25% discount.

You can use a higher-order function that generates the functions that you need. For example, consider the following function. What does it return?
const discountedPrice = (discount) => {
  return (price) => price * discount;
}
The function above returns a function that accepts a single parameter price and multiplies the price by the discount provided. You can use it to first create a function that calculates the 10% discount, and then use the generated function to calculate the discounts.

const tenPercentDiscount = discountedPrice(0.9);
const finalPriceBed = tenPercentDiscount(200); // 90% of $200
const finalPricePillow = tenPercentDiscount(52); // 90% of $52
const finalPriceCurtain = tenPercentDiscount(32); // 90% of 32
And if you wanted to, you could later modify this function to calculate a 25% discount, like this:

const twentyFivePercentDiscount = discountedPrice(0.75);
const finalPriceBed = twentyFivePercentDiscount(200); // 75% of $200
const finalPricePillow = twentyFivePercentDiscount(52); // 75% of $52
const finalPriceCurtain = twentyFivePercentDiscount(32); // 75% of 32
This example is quite trivial, but over time, you will encounter many examples of higher-order functions that behave in a similar manner.

One final note on this example: the discountedPrice() function above was deliberately written with an explicit return statement. Because this function returns a single value, you can use a more concise syntax and drop the return statement. In other words, you could rewrite this function as follows:

const discountedPrice = discount => price => price * discount;
Despite the simple definition, higher-order functions can be difficult to understand and write. For now, you will learn about existing higher-order functions that are built into JavaScript. Later on, you will write your own.

The forEach() method
You can use the following Replit to follow along with the lesson and run code examples for the forEach() method:


Take a look at the following array of park information:

let parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];
It's common to write a loop to do something for each element in an array, like this:

for (let i = 0; i < parks.length; i++) {
  console.log(parks[i].name);
}
// Biscayne
// Grand Canyon
// Gateway Arch
// Indiana Dunes
Because you are doing the same thing to each element of the array, you can write a function to perform that same task with each element. Then you can call that function repeatedly in the loop.

const logPark = (park) => console.log(park.name);

for (let i = 0; i < parks.length; i++) {
  logPark(parks[i]);
}
You can think of the for loop as applying this function to each element of the array, one at a time. The function gets each item in succession. In this example, the function parameter park is called, because that's helpful for remembering what the item is.

The forEach() method lets you do this without a for loop. This lets you think about the items themselves, instead of counting indexes.

To see the syntax, take a look at the following example, which is equivalent to the loop above.

parks.forEach(logPark);
// Biscayne
// Grand Canyon
// Gateway Arch
// Indiana Dunes
The forEach() method accepts a function as an argument. The function that you pass to the method is referred to as a callback function. In other words, a callback function is a function that is passed into another function as an argument.

How forEach() works
Where does park come from? That is, how does forEach() know what to put there? The forEach() method is a higher-order function, in that it takes a callback function as its argument.

So you provide forEach() with a callback function. Then, internally, forEach() executes that callback function once for each element of the array.

In some instances, you may use an anonymous function as the callback. Take a look at the following example. This is equivalent to the code above, but it has been rewritten to use an anonymous function.

parks.forEach((park) => console.log(park.name));
// Biscayne
// Grand Canyon
// Gateway Arch
// Indiana Dunes
In the example above, you aren't passing a named function to forEach(); rather, you are defining an anonymous function in the invocation of forEach().

Customizing forEach()
Just like for any other function, you could call the argument anything that you want, and you would get the same results. You can see this in action below:

parks.forEach((element) => {
  console.log(element.name);
});
// Biscayne
// Grand Canyon
// Gateway Arch
// Indiana Dunes
But naming the argument after what the item means is more helpful to other developers, so the examples in this program will stick to that.

The forEach() method also gives you access to other arguments that you can use in the function, including the index and the original collection.

parks.forEach((park, index, collection) => {
  console.log(`(${index + 1}/${collection.length}) ${park.name}`);
});
// (1/4) Biscayne
// (2/4) Grand Canyon
// (3/4) Gateway Arch
// (4/4) Indiana Dunes
In the above example, you can see that you have access to the individual element at each point in the array, the index at that point, and then the entire collection.

*** find, filter

By the end of this lesson, you will be able to use find(), filter(), map(), some(), and every() to solve various problems.

Overview
Now that you have some understanding of how to use forEach(), you are ready to learn other array methods that work in a similar fashion. In this lesson, you'll learn how to use the built-in array methods find(), filter(), map(), some(), and every().

Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


The find() method
In this lesson, you'll work with the parks data again.

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];
Sometimes, you'll want to write a loop to find an item in an array. Here's an example that uses a loop to find a park that has a specific name:

let found = null;
for (let i = 0; i < parks.length; i++) {
  const park = parks[i];
  if (park.name === "Biscayne") found = park;
}
console.log(found); //> { name: "Biscayne", rating: 4.2 }
Once again, you can extract the logic from this loop into a function. Take a look at the function below. This function, parkNameIsBiscayne(), accepts a single park object and returns true if the name of the park is "Biscayne" and false otherwise. You can then call that function in the loop.

const parkNameIsBiscayne = (park) => park.name === "Biscayne";

let found = null;
for (let i = 0; i < parks.length; i++) {
  const park = parks[i];
  if (parkNameIsBiscayne(park)) found = park;
}
console.log(found); //> { name: "Biscayne", rating: 4.2 }
Here, you are using the loop to visit each element in the array and perform a comparison. If the comparison is true, you select that item from the array. And if the comparison never returns true, you don't select anything from the array.

You could also use a built-in array method to do this; the find() method encapsulates this functionality. With find(), you can provide a callback function that implements the comparison that you wish to perform. Then, find() will apply this comparison to each element of the array.

Take a look at how you could perform the above task using the find() method:

let found = parks.find((park) => park.name === "Biscayne");
console.log(found); //> { name: "Biscayne", rating: 4.2 }
The find() method uses the callback function to decide whether each item matches, and it does the rest of the work from the loop. It returns the first item that matches the condition, even if more than one item matches. If there is no match, find() returns undefined.

Here's a visual summary of this method:

The find() method
The find() method operates on an array of items and returns a single item.

Do this
Use find()
Using the above parks dataset, use the find() function to write code that finds the park with a rating of 4.1.

The filter() method
const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];
Sometimes, you'll want to build up a new list of items that meet a particular condition. Take a look at some code that does that with a for loop:

let result = [];
for (let i = 0; i < parks.length; i++) {
  const park = parks[i];
  if (park.rating >= 4.5) result.push(park);
}
console.log(result); // [ { name: "Grand Canyon", rating: 5 }, { name: "Gateway Arch", rating: 4.5 } ]
You can use the filter() method to achieve the same goal. This method builds a new array of only the items that match a certain condition. Take a look at the example below to see how this works. Once again, the comparison that was done in the body of the loop has been refactored into a callback function.

let result = parks.filter((park) => park.rating >= 4.5);
console.log(result); // [ { name: "Grand Canyon", rating: 5 }, { name: "Gateway Arch", rating: 4.5 } ]
This method filters the array so that you have only some of the items. It's pretty similar to find(), except that it returns an array of all the matching items, instead of just the first match.

Keep in mind that filter() returns a new array. The old array will still have the same items. It is also possible for the returned array to be empty, if no element matches the criterion that's given in the function.

Here's a quick summary of this method:

The filter() method
The filter() method operates on an array of items and returns a new array of items that match the criterion.

Do this
Use filter()
Using the above parks dataset, write code using the filter() function to find the parks with names that begin with the letter "G".

The map() method
The loop below creates a new array that just contains the names of all of the parks.

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];

const result = [];
for (let i = 0; i < parks.length; i++) {
  result.push(parks[i].name);
}
console.log(result); // [ "Biscayne", "Grand Canyon", "Gateway Arch", "Indiana Dunes" ]
Basically, this code processes each item in the array and creates a new value for each item in the original array. Each item in the original array maps to an item in the new array.

You can achieve this same goal with the built-in map() method, as follows:

const result = parks.map((park) => park.name);
console.log(result); // [ "Biscayne", "Grand Canyon", "Gateway Arch", "Indiana Dunes" ]
Just like the other array methods that you've been looking at, map() will run the callback function for each of the items in the array. The map() method uses the callback function to create the items for the new array. In this case, the code adds the park.name for each park to the new array.

The map() method works in lots of situations—not just ones where you want to pick one value from each of a list of objects. This method works in any situation where you want to transform each value of an array into another value.

Here's a quick summary of this method:

The map() method
The map() method operates on an array of items and creates a new array of items the same size as the original array.

Do this
Use map()
Using the above parks dataset, use the map() method to write code that returns an array of strings, where each string is the name of the park next to its rating. The end result should look something like this:

["Biscayne: 4.2", "Grand Canyon: 5", "Gateway Arch: 4.5", "Indiana Dunes: 4.1"];
When you're done, compare your work to this solution:

const result = parks.map((park) => `${park.name}: ${park.rating}`);
console.log(result); // ["Biscayne: 4.2", "Grand Canyon: 5", "Gateway Arch: 4.5", "Indiana Dunes: 4.1"];
The some() method
Sometimes, you'll just want to check if some condition is met in your array. The following code checks whether or not any of the parks have a rating of greater than 4.

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];

let result = false;
for (let i = 0; i < parks.length; i++) {
  if (parks[i].rating > 4) result = true;
}
console.log(result); // true
You can achieve this same goal with the built-in some() method, like this:

const result = parks.some((park) => park.rating > 4);
console.log(result); // true
The some() method accepts a callback function that implements a comparison that is executed for each item in the array, similar to the previous methods. If the callback function returns true for any item in the array, then the entire some() method returns true.

This method is more efficient than the for loop shown above, in that it returns immediately as soon as the condition is met. The some() method is useful for quick checks like this, and it's different from the other methods in this lesson in that it returns a boolean value instead of an array.

Here's a quick summary of this method:

The some() method
The some() method operates on an array of items and returns a boolean value.

Do this
Use some()
Using the above parks dataset, use the some() function to write code that returns whether or not the "Grand Arches" park is included in the array.

The every() method
At times, you may want to check whether every item in an array matches some condition. The every() method has you covered. Take a look:

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];

const result = parks.every((park) => park.rating > 4);
console.log(result); // true
The every() method works by checking the condition given against every item in the array. If that condition ever fails, it will return false. Otherwise, it will return true. Once again, the comparator is implemented in the callback function passed to the method.

Here's a quick summary of this method:

The every() method
The every() method operates on an array of items and returns a boolean value.

Do this
Use every()
Using the above parks dataset, use the every() function to write code that returns whether or not every park has a rating between 4.2 and 4.6.

Iteration over objects
Another way that you could store the parks data is with the following object:

let parks = {
  "Biscayne": 4.2,
  "Grand Canyon": 5,
  "Gateway Arch": 4.5,
  "Indiana Dunes": 4.1,
};
How might you use the methods that you've learned with an object? If you want to get all the keys as an array, you can use the built-in JavaScript method Object.keys(), like this:

Object.keys(parks); // => ["Biscayne", "Grand Canyon", "Gateway Arch", "Indiana Dunes"];
With the keys as an array, you can use the array methods that you've learned, like this:

Object.keys(parks).filter((name) => {
  const rating = parks[name];
  return rating >= 4.5;
}); // => ["Grand Canyon", "Gateway Arch"]
Note: There's also a method to get the values from an object. To learn more, check out the MDN documentation on Object.values().

Don't forget to return!
All of these methods require that you return some value inside the callback function. Not doing so could have unintended consequences, as demonstrated here:

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];

const result = parks.map((park) => {
  park.name; // This value isn't returned by the callback
});
console.log(result); // [ undefined, undefined, undefined, undefined ]
In the above code, because park.name isn't being returned, the inner function's return value is undefined. This means that undefined will take the place of each item.

So if you are seeing strange results, make sure that you are returning within the callback function.

*** reduce

Learning Objective
By the end of this lesson, you will be able to use reduce() to solve different problems.

Overview
You've seen several powerful array methods so far. In this lesson, you'll learn another: reduce(). As you'll see, reduce() is a tool that generalizes the accumulator pattern that you learned earlier in this program.

Overview of the reduce() method
Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


The basics of reduce()
Earlier in this program, you learned about the accumulator pattern. In this pattern, you use a loop to build up a new value. Each step of the loop gets one item from the array and combines it with an accumulator, like a running total.

Take a look at an example with a for loop:

const areas = [768, 1004.2, 433.1];
let result = 0;
for (let i = 0; i < areas.length; i++) {
  result += areas[i];
}
console.log(result); //> 2205.3
The reduce() method is another way to express the accumulator pattern. This method turns an array of values into a single value. Like many of the other methods here, it will pass each value into a function, step by step. The reduce() method will also pass in the return value from the previous step.

For example, take a look at the following code. This code uses reduce() to achieve the same results as the code above.

const areas = [768, 1004.2, 433.1];
let result = areas.reduce((total, area) => total + area);
console.log(result); //> 2205.3
The reduce() method takes two arguments: a function and an optional starting value. In the example above, the optional initial value isn't used. However, consider that there may be different scenarios where setting an initial value may be useful. For example, if you have an initial area that you want to add, you can simply add it as an argument, as shown below.

const areas = [768, 1004.2, 433.1];
let initialValue = 200;
let result = areas.reduce((total, area) => total + area, initialValue);
console.log(result); //> 2405.3
The function passed into the reduce() function is similar to the other functions that you've seen, except that it includes an additional parameter: the initialValue. The initial value parameter represents the following:

On the first iteration, the accumulator value (total in the above function) is set to the second parameter (200 in the above function).

On every subsequent iteration, the accumulator value is set to whatever was returned from the previous iteration.

So, the above code works as follows:

The areas and initialValue values are defined.

The reduce() method takes a function that adds the accumulator and the current element. The first iteration will add 200 and 768.

The result of the first iteration will become the accumulator in the next iteration.

Once all iterations are finished, the value is stored in the result variable.

The result is logged out.

Do this
Add logging for understanding
The reduce() method can be difficult to understand. Try running the following code, and look at the logged statements.

const areas = [768, 1004.2, 433.1];
let initialValue = 200;
let result = areas.reduce((total, area, index) => {
  console.log(`index: ${index}`, `total: ${total}`, `area: ${area}`);
  return total + area;
}, initialValue);
console.log(result); //> 2405.3
You will see something like this:

index: 0 total: 200 area: 768
index: 1 total: 968 area: 1004.2
index: 2 total: 1972.2 area: 433.1
2405.3
As you can see above, the value of area is added to total at each step.

Remove the initial value
The second argument in reduce() is optional. So, what happens if it is removed? Try running the following code to find out.

const areas = [768, 1004.2, 433.1];
let result = areas.reduce((total, area, index) => {
  console.log(`index: ${index}`, `total: ${total}`, `area: ${area}`);
  return total + area;
});
console.log(result); //> 2205.3
You will see something like this:

index: 1 total: 768 area: 1004.2
index: 2 total: 1772.2 area: 433.1
2205.3
Notice that for the first iteration, total is set to the first value of the areas array, and area is set to the second value.

Complex usage
The initial value that reduce() uses can be any data type, just like how the accumulator could be anything when you're using the accumulator pattern. This allows for some pretty powerful but complex usage of the reduce() method.

For example, take a look at the code below. This code accumulates array values into an object.

const parks = [
  { name: "Acadia", areaInSquareKm: 198.6 },
  { name: "Crater Lake", areaInSquareKm: 741.5 },
  { name: "Kenai Fjords", areaInSquareKm: 2710 },
  { name: "Zion", areaInSquareKm: 595.9 },
];

const parkToAreasObject = parks.reduce((result, park) => {
  result[park.name] = park.areaInSquareKm;
  return result;
}, {});
Running the code above produces the following value for the result variable:

{
  Acadia: 198.6,
  'Crater Lake': 741.5,
  'Kenai Fjords': 2710,
  Zion: 595.9
}
At each step in the function given to reduce(), a new key is created in the given object. The value assigned to that key is the areaInSquareKm value. Then, the overall object is returned so that it can serve as the accumulator (result) in the next iteration.

*** sort

Learning Objective
By the end of this lesson, you will be able to use sort() to sort arrays in various ways.

Overview
Sorting is often a starting step when you're solving other problems. But sorting can be a deep and difficult topic on its own. Until you're ready to dive into building your own sorting function, you can use JavaScript's built-in sort() method. You'll learn how to do just that in this lesson.

Basics of sort()
Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


The sort() method takes a function and uses that function to sort an array based on the given criteria. For example, take a look at the function below. This function sorts the parks based on the rating of each park.

const parks = [
  { name: "Biscayne", rating: 4.2 },
  { name: "Grand Canyon", rating: 5 },
  { name: "Gateway Arch", rating: 4.5 },
  { name: "Indiana Dunes", rating: 4.1 },
];

parks.sort((parkA, parkB) => (parkA.rating > parkB.rating ? 1 : -1));
console.log(parks);
In the above code, you can see that the function passed in to sort() has two parameters. Each parameter, on the first iteration, represents the first and second element of the array. The ratings are then compared for each park.

If the number returned is negative, the first item (parkA) will be moved before the second item (parkB). The opposite is true if the number is positive. This iteration then continues, but with the second and third items.

If 0 is returned, the items won't change places.

You may also see code that follows the format shown below, particularly when you're sorting based on a number. The effect of this code is similar to that of the previous code sample.

parks.sort((parkA, parkB) => parkA.rating - parkB.rating);
console.log(parks);
Sorting strings
You can compare strings with the greater-than > and less-than < symbols in JavaScript.

"Biscayne" < "Grand Canyon"; //> true
The above code returns true because the letter B comes before the letter G. However, it isn't quite as simple as it seems. For example, look at this code:

"biscayne" < "Grand Canyon"; //> false
Strings do not get compared alphabetically; instead, they're compared based on their character value. This means that sorting strings can be a bit more unreliable than you might expect. Still, with some ingenuity, it is possible to do a passable job of sorting strings. For example, you could modify your function as follows:

parks.sort((parkA, parkB) =>
  parkA.name.toLowerCase() > parkB.name.toLowerCase() ? 1 : -1
);
console.log(parks);
Caveats for using sort()
Be careful with sort(). It has several peculiarities that can lead to bugs. Here are a few to watch out for:

It expects you to return a negative number for items that should be earlier in the list, and a positive number for items that should be later in the list.

It changes the array in place. In other words, it doesn't return a new array—it mutates the existing array. The parks dataset changed its order in the above example.

It has a default behavior if you don't pass in a function, but this default behavior might not be what you want.

For more insight into the default behavior, take a look at the following code.

["Biscayne", "grand canyon", "Gateway arch"].sort();
//> [ 'Biscayne', 'Gateway arch', 'grand canyon' ]
This could be what you want, but it is almost always better to provide a function so that you can determine the effect of sort().

*** assessment
** js Modules wip

Modules
JavaScript modules allow you to break up your code into separate files.

This makes it easier to maintain the code-base.

JavaScript modules rely on the import and export statements.

Export
You can export a function or variable from any file.

Let us create a file named person.js, and fill it with the things we want to export.

There are two types of exports: Named and Default.

Named Exports
You can create named exports two ways. In-line individually, or all at once at the bottom.

In-line individually:
person.js

export const name = "Jesse";
export const age = 40;
All at once at the bottom:
person.js

const name = "Jesse";
const age = 40;

export {name, age};
Default Exports
Let us create another file, named message.js, and use it for demonstrating default export.

You can only have one default export in a file.

Example
message.js

const message = () => {
const name = "Jesse";
const age = 40;
return name + ' is ' + age + 'years old.';
};

export default message;
Import
You can import modules into a file in two ways, based on if they are named exports or default exports.

Named exports are constructed using curly braces. Default exports are not.

Import from named exports
Import named exports from the file person.js:

import { name, age } from "./person.js";

Import from default exports
Import a default export from the file message.js:

import message from "./message.js";

Note
Modules only work with the HTTP(s) protocol.

A web-page opened via the file:// protocol cannot use import / export.

** Scope

Global Scope and Functions
In JavaScript, scope refers to the visibility of variables. Variables which are defined outside of a function block have Global scope. This means, they can be seen everywhere in your JavaScript code.
Variables which are declared without the let or const keywords are automatically created in the global scope. This can create unintended consequences elsewhere in your code or when running a function again. You should always declare your variables with let or const.
Using let or const, declare a global variable named myGlobal outside of any function. Initialize it with a value of 10.
Inside function fun1, assign 5 to oopsGlobal without using the let or const keywords.

Local Scope and Functions
Variables which are declared within a function, as well as the function parameters, have local scope. That means they are only visible within that function.
Here is a function myTest with a local variable called loc.
function myTest() {
  const loc = "foo";
  console.log(loc);
}
myTest();
console.log(loc);
The myTest() function call will display the string foo in the console. The console.log(loc) line (outside of the myTest function) will throw an error, as loc is not defined outside of the function.
The editor has two console.logs to help you see what is happening. Check the console as you code to see how it changes. Declare a local variable myVar inside myLocalScope and run the tests.
Note: The console will still display ReferenceError: myVar is not defined, but this will not cause the tests to fail.

Global vs. Local Scope in Functions
It is possible to have both local and global variables with the same name. When you do this, the local variable takes precedence over the global variable.
In this example:
const someVar = "Hat";
function myFun() {
  const someVar = "Head";
  return someVar;
}
The function myFun will return the string Head because the local version of the variable is present.
Add a local variable to myOutfit function to override the value of outerWear with the string sweater.

Global scope
    The scope that contains all other scopes

variables created outside of functions are global
variables created inside of functions are local
Function parameters act like variables created inside a function
each time call function it creates a new scope.

shadowing javascript looks for a scope inside function then outside
  inside beat outside

 Summary: Scope rules
Here's a summary of the scope rules that you've learned so far:
Every variable is part of a scope.
If the variable is created outside of any function, it's stored in the global scope.
Variables in the global scope are visible everywhere.
Each time that a function is called, it creates a new scope.
If the variable is created inside a function, it gets stored inside the function's scope.
Variables in a function scope are only visible inside the function.
The function scope disappears when the function ends.
Parameters get assigned function scope, as if they were variables created inside the function.
Parameters get assigned the values from the arguments when the function is called.
Scope is pretty complicated. In this lesson, you learned some essential scope rules. But there are still more scope rules, and you'll learn those later.

JavaScript Scope

Scope determines the accessibility (visibility) of variables.

JavaScript has 3 types of scope:

    Block scope
    Function scope
    Global scope

Block Scope

Before ES6 (2015), JavaScript had only Global Scope and Function Scope.

ES6 introduced two important new JavaScript keywords: let and const.

These two keywords provide Block Scope in JavaScript.

Variables declared inside a { } block cannot be accessed from outside the block:
Example
{
  let x = 2;
}
// x can NOT be used here

Variables declared with the var keyword can NOT have block scope.

Variables declared inside a { } block can be accessed from outside the block.
Example
{
  var x = 2;
}
// x CAN be used here
Local Scope

Variables declared within a JavaScript function, become LOCAL to the function.
Example
// code here can NOT use carName

function myFunction() {
  let carName = "Volvo";
  // code here CAN use carName
}

// code here can NOT use carName

Local variables have Function Scope:

They can only be accessed from within the function.

Since local variables are only recognized inside their functions, variables with the same name can be used in different functions.

Local variables are created when a function starts, and deleted when the function is completed.
Function Scope

JavaScript has function scope: Each function creates a new scope.

Variables defined inside a function are not accessible (visible) from outside the function.

Variables declared with var, let and const are quite similar when declared inside a function.

They all have Function Scope:
function myFunction() {
  var carName = "Volvo";   // Function Scope
}
function myFunction() {
  let carName = "Volvo";   // Function Scope
}
function myFunction() {
  const carName = "Volvo";   // Function Scope
}
Global JavaScript Variables

A variable declared outside a function, becomes GLOBAL.
Example
let carName = "Volvo";
// code here can use carName

function myFunction() {
// code here can also use carName
}

A global variable has Global Scope:

All scripts and functions on a web page can access it.
Global Scope

Variables declared Globally (outside any function) have Global Scope.

Global variables can be accessed from anywhere in a JavaScript program.

Variables declared with var, let and const are quite similar when declared outside a block.

They all have Global Scope:
var x = 2;       // Global scope
let x = 2;       // Global scope
const x = 2;       // Global scope
JavaScript Variables

In JavaScript, objects and functions are also variables.

Scope determines the accessibility of variables, objects, and functions from different parts of the code.
Automatically Global

If you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.

This code example will declare a global variable carName, even if the value is assigned inside a function.
Example
myFunction();

// code here can use carName

function myFunction() {
  carName = "Volvo";
}
Strict Mode

All modern browsers support running JavaScript in "Strict Mode".

You will learn more about how to use strict mode in a later chapter of this tutorial.

In "Strict Mode", undeclared variables are not automatically global.
Global Variables in HTML

With JavaScript, the global scope is the JavaScript environment.

In HTML, the global scope is the window object.

Global variables defined with the var keyword belong to the window object:
Example
var carName = "Volvo";
// code here can use window.carName

Global variables defined with the let keyword do not belong to the window object:
Example
let carName = "Volvo";
// code here can not use window.carName
Warning

Do NOT create global variables unless you intend to.

Your global variables (or functions) can overwrite window variables (or functions).
Any function, including the window object, can overwrite your global variables and functions.
The Lifetime of JavaScript Variables

The lifetime of a JavaScript variable starts when it is declared.

Function (local) variables are deleted when the function is completed.

In a web browser, global variables are deleted when you close the browser window (or tab).
Function Arguments

Function arguments (parameters) work as local variables inside functions.

*** scope thinkful

Sibling scopes Two or more scopes that share a common parent scope

Complex scope
The following video breaks down how to evaluate functions with complicated scope and diagram the scope of programs.
Start by watching the video, and then read through the rest of the lesson and complete the practice work required.
This will give you a full understanding of these concepts.

When you use let and const, you can easily separate scope by simply looking for the curly brackets {}.
Each pair of curly brackets gives you a new level of scope.

Additionally, anything inside of a set of curly brackets can access reference variables that are set outside of it.
See if you can separate the scopes in the code sample below:

const DISCOUNT_PERCENTAGE = 0.15;
function discountPricesInCents(products) {
  const result = [];

  for (let i = 0; i < products.length; i++) {
    const product = products[i];
    let price = product.priceInCents;
    if (DISCOUNT_PERCENTAGE > 0) {
      const multiplier = 1 - DISCOUNT_PERCENTAGE;
      price = product.priceInCents * multiplier;
    }
    result.push(price);
  }

  return result;
}

The above code relies on different rules for block scope and global scope. Here are the details:

    In the discountPricesInCents() function, you can access DISCOUNT_PERCENTAGE because it's part of the global scope.
    Later on, if you were to call discountPricesInCents(), you would be accessing it from the global scope.
    In the for loop statement, you're able to access the products parameter because it is shared inside the function scope. If you tried to log products outside of the function, you would get an error.
    Inside of the for loop, you're able to access products and DISCOUNT_PERCENTAGE because they are both in outer scopes.
    However, i, product, and price are accessible only within the for loop. You can't access those variables outside of the curly brackets.
    Finally, multiplier is accessible only inside of the if statement. It can't be accessed outside of that statement.

Diagramming scope
As you can see above, a complex scope can be hard to understand. To gain some clarity, developers often find it useful to diagram out the scope for a particular function or program. Here's one way to diagram scope:
Diagramming scope

The above diagram demonstrates the following:
    Each distinct background color represents a level of scope. For example, the if statement scope is enclosed inside of the for loop scope.
    At each arrow, a new scope is introduced. For example, inside of the function scope is a for loop scope.
    Each scope has access to the variables of its containers. For example, the function scope has access to the global scope, and the if statement scope has access to all other scopes.

Reminder: Variable declarations and scope
As you know, variables declared with let and const can only ever be declared once.
But there's one exception to this rule: you may declare variables that are in sibling scopes.
For example, pay attention to the price variable in the following code sample:

const DISCOUNT_PERCENTAGE = 0.15;
const product = {
  name: "Black Longline T-Shirt",
  priceInCents: 1500,
  availableSizes: ["XS", "S", "XL", "XXL"],
};


if (DISCOUNT_PERCENTAGE > 0) {
  const multiplier = 1 - DISCOUNT_PERCENTAGE;
  const price = product.priceInCents * multiplier;
  console.log(price);
} else {
  const price = product.priceInCents;
  console.log(price);
}

In the case above, price is declared twice as a const variable, but the scopes are separate. That means that they can both be declared successfully on their own.

** iterate wip

Accumulator pattern
Pseudocoding
The process of writing the steps and logic that you would implement in code, but in normal language rather than in commands that a programming language could execute
Accumulator pattern
A chunk of code that uses a loop to accumulate data

let sum = 0; // accumulator
for () {
  sum += i;
}

Loop
    A construct that allows you to repeat a set of instructions a specific number of times, or until a specific condition is true

*** JavaScript For Loop

Loops can execute a block of code a number of times.
JavaScript Loops

Loops are handy, if you want to run the same code over and over again, each time with a different value.

Often this is the case when working with arrays:
Instead of writing:
text += cars[0] + "<br>";
text += cars[1] + "<br>";
text += cars[2] + "<br>";
text += cars[3] + "<br>";
text += cars[4] + "<br>";
text += cars[5] + "<br>";
You can write:
for (let i = 0; i < cars.length; i++) {
  text += cars[i] + "<br>";
}
Different Kinds of Loops

JavaScript supports different kinds of loops:

    for - loops through a block of code a number of times
    for/in - loops through the properties of an object
    for/of - loops through the values of an iterable object
    while - loops through a block of code while a specified condition is true
    do/while - also loops through a block of code while a specified condition is true

The For Loop

The for loop has the following syntax:
for (statement 1; statement 2; statement 3) {
  // code block to be executed
}

Statement 1 is executed (one time) before the execution of the code block.

Statement 2 defines the condition for executing the code block.

Statement 3 is executed (every time) after the code block has been executed.
Example
for (let i = 0; i < 5; i++) {
  text += "The number is " + i + "<br>";
}

From the example above, you can read:

Statement 1 sets a variable before the loop starts (let i = 0).

Statement 2 defines the condition for the loop to run (i must be less than 5).

Statement 3 increases a value (i++) each time the code block in the loop has been executed.
Statement 1

Normally you will use statement 1 to initialize the variable used in the loop (let i = 0).

This is not always the case, JavaScript doesn't care. Statement 1 is optional.

You can initiate many values in statement 1 (separated by comma):
Example
for (let i = 0, len = cars.length, text = ""; i < len; i++) {
  text += cars[i] + "<br>";
}

And you can omit statement 1 (like when your values are set before the loop starts):
Example
let i = 2;
let len = cars.length;
let text = "";
for (; i < len; i++) {
  text += cars[i] + "<br>";
}
Statement 2

Often statement 2 is used to evaluate the condition of the initial variable.

This is not always the case, JavaScript doesn't care. Statement 2 is also optional.

If statement 2 returns true, the loop will start over again, if it returns false, the loop will end.

If you omit statement 2, you must provide a break inside the loop. Otherwise the loop will never end. This will crash your browser. Read about breaks in a later chapter of this tutorial.
Statement 3

Often statement 3 increments the value of the initial variable.

This is not always the case, JavaScript doesn't care, and statement 3 is optional.

Statement 3 can do anything like negative increment (i--), positive increment (i = i + 15), or anything else.

Statement 3 can also be omitted (like when you increment your values inside the loop):
Example
let i = 0;
let len = cars.length;
let text = "";
for (; i < len; ) {
  text += cars[i] + "<br>";
  i++;
}
Loop Scope

Using var in a loop:
Example
var i = 5;

for (var i = 0; i < 10; i++) {
  // some code
}

// Here i is 10

Using let in a loop:
Example
let i = 5;

for (let i = 0; i < 10; i++) {
  // some code
}

// Here i is 5

In the first example, using var, the variable declared in the loop redeclares the variable outside the loop.

In the second example, using let, the variable declared in the loop does not redeclare the variable outside the loop.

When let is used to declare the i variable in a loop, the i variable will only be visible within the loop.
For/Of and For/In Loops

The for/in loop and the for/of loop are explained in the next chapter.
While Loops

The while loop and the do/while are explained in the next chapters.
Test Yourself With Exercises
Exercise:

Create a loop that runs from 0 to 9.

let i;
 ( = ;  < ; ) {
  console.log(i);
}


Start the Exercise

Iterate with JavaScript For Loops
You can run the same code multiple times by using a loop.
The most common type of JavaScript loop is called a for loop because it runs for a specific number of times.
For loops are declared with three optional expressions separated by semicolons:
for (a; b; c), where a is the initialization statement, b is the condition statement, and c is the final expression.
The initialization statement is executed one time only before the loop starts. It is typically used to define and setup your loop variable.
The condition statement is evaluated at the beginning of every loop iteration and will continue as long as it evaluates to true. When the condition is false at the start of the iteration, the loop will stop executing. This means if the condition starts as false, your loop will never execute.
The final expression is executed at the end of each loop iteration, prior to the next condition check and is usually used to increment or decrement your loop counter.
In the following example we initialize with i = 0 and iterate while our condition i < 5 is true. We'll increment i by 1 in each loop iteration with i++ as our final expression.
const ourArray = [];
for (let i = 0; i < 5; i++) {
  ourArray.push(i);
}
ourArray will now have the value [0, 1, 2, 3, 4].
Use a for loop to push the values 1 through 5 onto myArray.
Iterate Odd Numbers With a For Loop
For loops don't have to iterate one at a time. By changing our final-expression, we can count by even numbers.
We'll start at i = 0 and loop while i < 10. We'll increment i by 2 each loop with i += 2.
const ourArray = [];
for (let i = 0; i < 10; i += 2) {
  ourArray.push(i);
}
ourArray will now contain [0, 2, 4, 6, 8]. Let's change our initialization so we can count by odd numbers.
Push the odd numbers from 1 through 9 to myArray using a for loop.
Count Backwards With a For Loop
A for loop can also count backwards, so long as we can define the right conditions.
In order to decrement by two each iteration, we'll need to change our initialization, condition, and final expression.
We'll start at i = 10 and loop while i > 0. We'll decrement i by 2 each loop with i -= 2.
const ourArray = [];
for (let i = 10; i > 0; i -= 2) {
  ourArray.push(i);
}
ourArray will now contain [10, 8, 6, 4, 2]. Let's change our initialization and final expression so we can count backwards by twos to create an array of descending odd numbers.
Push the odd numbers from 9 through 1 to myArray using a for loop.

Iterate Through an Array with a For Loop
A common task in JavaScript is to iterate through the contents of an array. One way to do that is with a for loop. This code will output each element of the array arr to the console:
const arr = [10, 9, 8, 7, 6];
for (let i = 0; i < arr.length; i++) {
   console.log(arr[i]);
}
Remember that arrays have zero-based indexing, which means the last index of the array is length - 1. Our condition for this loop is i < arr.length, which stops the loop when i is equal to length. In this case the last iteration is i === 4 i.e. when i becomes equal to arr.length - 1 and outputs 6 to the console. Then i increases to 5, and the loop terminates because i < arr.length is false.
Declare and initialize a variable total to 0. Use a for loop to add the value of each element of the myArr array to total.

Nesting For Loops
If you have a multi-dimensional array, you can use the same logic as the prior waypoint to loop through both the array and any sub-arrays. Here is an example:
const arr = [
  [1, 2], [3, 4], [5, 6]
];

for (let i = 0; i < arr.length; i++) {
  for (let j = 0; j < arr[i].length; j++) {
    console.log(arr[i][j]);
  }
}
This outputs each sub-element in arr one at a time. Note that for the inner loop, we are checking the .length of arr[i], since arr[i] is itself an array.
Modify function multiplyAll so that it returns the product of all the numbers in the sub-arrays of arr.
for loop
for ( initialExpression; condition; incrementExpression) {
  loop body
}
intitalExpression let i = 1;
condition i <= 5;
incrementExpression i++;
initialExpression
This expression typically initializes the loop counter. It runs at the start of a loop. A very common example is let i = 0. The i variable is short for index, and it's frequently used for the index counter that you saw above.
condition
At the end of each loop, the condition expression is evaluated. In the example above, the condition is "if index is less than or equal to the countTo variable." If the value of the condition is true, the loop statement executes. If the value of the condition is false, the loop statement terminates. In the example above, index would eventually get to 6. At that point, because the value would be greater than 5, the loop would stop.
incrementExpression
At the end of each loop, this statement is executed. In the example above, the code is incrementing the variable index by 1 (++) each time through the loop. But it's important to note that you're not limited to incrementing by 1 for the final condition. Depending on what you're building or the problem you're solving, you can decrement (i--) by some amount, or you could increment by another amount, like 2 (index += 2). That said, incrementing by 1 is the most common technique.
loop body
If the condition is true, this code will run. In the example above, the loop body that executes uses console.log() to display the value of index during the loop.

i stand for index number

increment and decrement operators
i++, i--
i+=2, i-=2

make for loop over an array
for ( let i = 0; i < arr.length; i++ ) {
  console.log( arr[i] );

}

for () {
  var += arr[i]
}

for () {
  if () {
  }
  if () {
  }
}

*** JavaScript For In
The For In Loop

The JavaScript for in statement loops through the properties of an Object:
Syntax
for (key in object) {
  // code block to be executed
}
Example
const person = {fname:"John", lname:"Doe", age:25};

let text = "";
for (let x in person) {
  text += person[x];
}
Example Explained

    The for in loop iterates over a person object
    Each iteration returns a key (x)
    The key is used to access the value of the key
    The value of the key is person[x]

For In Over Arrays

The JavaScript for in statement can also loop over the properties of an Array:
Syntax
for (variable in array) {
  code
}
Example
const numbers = [45, 4, 9, 16, 25];

let txt = "";
for (let x in numbers) {
  txt += numbers[x];
}

Do not use for in over an Array if the index order is important.

The index order is implementation-dependent, and array values may not be accessed in the order you expect.

It is better to use a for loop, a for of loop, or Array.forEach() when the order is important.
Array.forEach()

The forEach() method calls a function (a callback function) once for each array element.
Example
const numbers = [45, 4, 9, 16, 25];

let txt = "";
numbers.forEach(myFunction);

function myFunction(value, index, array) {
  txt += value;
}

Note that the function takes 3 arguments:

    The item value
    The item index
    The array itself

The example above uses only the value parameter. It can be rewritten to:
Example
const numbers = [45, 4, 9, 16, 25];

let txt = "";
numbers.forEach(myFunction);

function myFunction(value) {
  txt += value;
}

*** JavaScript For Of
The For Of Loop

The JavaScript for of statement loops through the values of an iterable object.

It lets you loop over iterable data structures such as Arrays, Strings, Maps, NodeLists, and more:
Syntax
for (variable of iterable) {
  // code block to be executed
}

variable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with const, let, or var.

iterable - An object that has iterable properties.
Browser Support

For/of was added to JavaScript in 2015 (ES6)

Safari 7 was the first browser to support for of:

Chrome 38 	Edge 12 	Firefox 51 	Safari 7 	Opera 25
Oct 2014 	Jul 2015 	Oct 2016 	Oct 2013 	Oct 2014

For/of is not supported in Internet Explorer.
Looping over an Array
Example
const cars = ["BMW", "Volvo", "Mini"];

let text = "";
for (let x of cars) {
  text += x;
}
Looping over a String
Example
let language = "JavaScript";

let text = "";
for (let x of language) {
text += x;
}
The While Loop

The while loop and the do/while loop are explained in the next chapter.

*** do while loop

Iterate with JavaScript Do...While Loops
The next type of loop you will learn is called a do...while loop. It is called a do...while loop because it will first do one pass of the code inside the loop no matter what, and then continue to run the loop while the specified condition evaluates to true.
const ourArray = [];
let i = 0;

do {
  ourArray.push(i);
  i++;
} while (i < 5);
The example above behaves similar to other types of loops, and the resulting array will look like [0, 1, 2, 3, 4]. However, what makes the do...while different from other loops is how it behaves when the condition fails on the first check. Let's see this in action: Here is a regular while loop that will run the code in the loop as long as i < 5:
const ourArray = [];
let i = 5;

while (i < 5) {
  ourArray.push(i);
  i++;
}
In this example, we initialize the value of ourArray to an empty array and the value of i to 5. When we execute the while loop, the condition evaluates to false because i is not less than 5, so we do not execute the code inside the loop. The result is that ourArray will end up with no values added to it, and it will still look like [] when all of the code in the example above has completed running. Now, take a look at a do...while loop:
const ourArray = [];
let i = 5;

do {
  ourArray.push(i);
  i++;
} while (i < 5);
In this case, we initialize the value of i to 5, just like we did with the while loop. When we get to the next line, there is no condition to evaluate, so we go to the code inside the curly braces and execute it. We will add a single element to the array and then increment i before we get to the condition check. When we finally evaluate the condition i < 5 on the last line, we see that i is now 6, which fails the conditional check, so we exit the loop and are done. At the end of the above example, the value of ourArray is [5]. Essentially, a do...while loop ensures that the code inside the loop will run at least once. Let's try getting a do...while loop to work by pushing values to an array.
Change the while loop in the code to a do...while loop so the loop will push only the number 10 to myArray, and i will be equal to 11 when your code has finished running.

*** JavaScript While Loop

Loops can execute a block of code as long as a specified condition is true.
The While Loop

The while loop loops through a block of code as long as a specified condition is true.
Syntax
while (condition) {
  // code block to be executed
}
Example

In the following example, the code in the loop will run, over and over again, as long as a variable (i) is less than 10:
Example
while (i < 10) {
  text += "The number is " + i;
  i++;
}

If you forget to increase the variable used in the condition, the loop will never end. This will crash your browser.
The Do While Loop

The do while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true, then it will repeat the loop as long as the condition is true.
Syntax
do {
  // code block to be executed
}
while (condition);
Example

The example below uses a do while loop. The loop will always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested:
Example
do {
  text += "The number is " + i;
  i++;
}
while (i < 10);

Do not forget to increase the variable used in the condition, otherwise the loop will never end!
Comparing For and While

If you have read the previous chapter, about the for loop, you will discover that a while loop is much the same as a for loop, with statement 1 and statement 3 omitted.

The loop in this example uses a for loop to collect the car names from the cars array:
Example
const cars = ["BMW", "Volvo", "Saab", "Ford"];
let i = 0;
let text = "";

for (;cars[i];) {
  text += cars[i];
  i++;
}

The loop in this example uses a while loop to collect the car names from the cars array:
Example
const cars = ["BMW", "Volvo", "Saab", "Ford"];
let i = 0;
let text = "";

while (cars[i]) {
  text += cars[i];
  i++;
}
Test Yourself With Exercises
Exercise:

Create a loop that runs as long as i is less than 10.

let i = 0;
 (i  10) {
  console.log(i);
  i++
  }

Iterate with JavaScript While Loops
You can run the same code multiple times by using a loop.
The first type of loop we will learn is called a while loop because it runs while a specified condition is true and stops once that condition is no longer true.
const ourArray = [];
let i = 0;
while (i < 5) {
  ourArray.push(i);
  i++;
}
In the code example above, the while loop will execute 5 times and append the numbers 0 through 4 to ourArray.
Let's try getting a while loop to work by pushing values to an array.
Add the numbers 5 through 0 (inclusive) in descending order to myArray using a while loop.
*** JavaScript Break and Continue

The break statement "jumps out" of a loop.

The continue statement "jumps over" one iteration in the loop.
The Break Statement

You have already seen the break statement used in an earlier chapter of this tutorial. It was used to "jump out" of a switch() statement.

The break statement can also be used to jump out of a loop:
Example
for (let i = 0; i < 10; i++) {
  if (i === 3) { break; }
  text += "The number is " + i + "<br>";
}

In the example above, the break statement ends the loop ("breaks" the loop) when the loop counter (i) is 3.
The Continue Statement

The continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.

This example skips the value of 3:
Example
for (let i = 0; i < 10; i++) {
  if (i === 3) { continue; }
  text += "The number is " + i + "<br>";
}
JavaScript Labels

To label JavaScript statements you precede the statements with a label name and a colon:
label:
statements

The break and the continue statements are the only JavaScript statements that can "jump out of" a code block.

Syntax:
break labelname;

continue labelname;

The continue statement (with or without a label reference) can only be used to skip one loop iteration.

The break statement, without a label reference, can only be used to jump out of a loop or a switch.

With a label reference, the break statement can be used to jump out of any code block:
Example
const cars = ["BMW", "Volvo", "Saab", "Ford"];
list: {
  text += cars[0] + "<br>";
  text += cars[1] + "<br>";
  break list;
  text += cars[2] + "<br>";
  text += cars[3] + "<br>";
}

A code block is a block of code between { and }.
Test Yourself With Exercises
Exercise:

Make the loop stop when i is 5.

for (i = 0; i < 10; i++) {
  console.log(i);
  if (i == 5) {
    ;
  }
}


Start the Exercise

*** JavaScript Iterables

Iterables are iterable objects (like Arrays).

Iterables can be accessed with simple and efficient code.

Iterables can be iterated over with for..of loops
The For Of Loop

The JavaScript for..of statement loops through the elements of an iterable object.
Syntax
for (variable of iterable) {
  // code block to be executed
}
Iterating

Iterating is easy to understand.

It simply means looping over a sequence of elements.

Here are some easy examples:

    Iterating over a String
    Iterating over an Array

Iterating Over a String

You can use a for..of loop to iterate over the elements of a string:
Example
const name = "W3Schools";

for (const x of name) {
  // code block to be executed
}
Iterating Over an Array

You can use a for..of loop to iterate over the elements of an Array:
Example
const letters = ["a","b","c"];

for (const x of letters) {
  // code block to be executed
}

You can learn more details about Iterables in the chapter JS Object Iterables.
Iterating Over a Set

You can use a for..of loop to iterate over the elements of a Set:
Example
const letters = new Set(["a","b","c"]);

for (const x of letters) {
  // code block to be executed
}

Sets and Maps are covered in the next chapters.
Iterating Over a Map

You can use a for..of loop to iterate over the elements of a Map:
Example
const fruits = new Map([
  ["apples", 500],
  ["bananas", 300],
  ["oranges", 200]
]);

for (const x of fruits) {
  // code block to be executed
}

*** looping over objects thinkful

Transforming objects into arrays
One way of looping over objects is to "cheat."
In this context, "cheating" means that instead of looping over an object, you'll actually transform part of the object into an array.
There are two methods that allow you to "cheat" in this way: Object.values() and Object.keys().

Accessing values
Often, you'll use objects to connect two pieces of information together.
For example, the following object connects names with addresses.

const people = {
  "Lee Finch": { address: "913 Hunts Lane", isCustomer: true },
  "Whitney Shawna": { address: "392 Norfolk Street", isCustomer: false },
  "Gabrielle Mayo": { address: "934 Engert Avenue", isCustomer: false },
};

However, what if you need to access just the values? You can do this by using Object.values(), passing in the object.
This method will return an array of all the values in any given object.

See the example below:
const addresses = Object.values(people);
//> [
//>   { address: "913 Hunts Lane", isCustomer: true },
//>   { address: "392 Norfolk Street", isCustomer: false },
//>   { address: "934 Engert Avenue", isCustomer: false },
//> ]
You can now loop over these values as you would in an array. Pretty nifty!

Accessing keys
Now, imagine that you need to access just the keys of an object.
This is where a similar method, Object.keys(), comes in handy.

Take a look:
const names = Object.keys(people);
//> [ "Lee Finch", "Whitney Shawna", "Gabrielle Mayo" ];
And yet again, you're set up to loop over this array however you like.

Looping over objects
Generally, the two methods described above will be sufficient for the work that you'll do.
They'll help you "cheat" to create an array that you can then loop over as needed.
However, sometimes it'll be easier to loop through an object on its own.
In those cases, you will use a for/in loop.


Now, take a look at the code sample below:
for (let name in people) {
  const person = people[name];
  const address = person.address;
  console.log(`Sending mail to ${name} at ${address}.`);
}
In the above for/in loop, people is the entire object, and name will be every object key. The code will run as many times as there are keys within the for/in loop block. This will allow you access to every key and value in the object.

This same process can be performed by using Object.keys() in place of the for/in syntax.
However, the for/in syntax is generally recommended because it takes less code and more clearly demonstrates the purpose of the code.

Do this
Use a for/in loop

Try running the following code directly. Can you identify the data types of people, name, person, and address here? Take a moment to consider what those data types might be and to predict what the code will do before you run it.

const people = {
  "Lee Finch": { address: "913 Hunts Lane", isCustomer: true },
  "Whitney Shawna": { address: "392 Norfolk Street", isCustomer: false },
  "Gabrielle Mayo": { address: "934 Engert Avenue", isCustomer: false },
};


for (let name in people) {
  const person = people[name];
  const address = person.address;
  console.log(`Sending mail to ${name} at ${address}.`);
}

for-in loops
use it to iterate over the keys of objects
let object = {
  name: "Alice",
  location: "Sealand"
};
for (let key in object) {
  //  Logs "name Alice",  "location Sealand"
  console.log(key, object[key]);
};

** recursion

Replace Loops using Recursion
Recursion is the concept that a function can be expressed in terms of itself. To help understand this, start by thinking about the following task: multiply the first n elements of an array to create the product of those elements. Using a for loop, you could do this:
  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
However, notice that multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. That means you can rewrite multiply in terms of itself and never need to use a loop.
  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
The recursive version of multiply breaks down like this. In the base case, where n <= 0, it returns 1. For larger values of n, it calls itself, but with n - 1. That function call is evaluated in the same way, calling multiply again until n <= 0. At this point, all the functions can return and the original multiply returns the answer.
Note: Recursive functions must have a base case when they return without calling the function again (in this example, when n <= 0), otherwise they can never finish executing.
Write a recursive function, sum(arr, n), that returns the sum of the first n elements of an array arr.

** Math.

Generate Random Fractions with JavaScript
Random numbers are useful for creating random behavior.
JavaScript has a Math.random() function that generates a random decimal number between 0 (inclusive) and 1 (exclusive). Thus Math.random() can return a 0 but never return a 1.
Note: Like Storing Values with the Assignment Operator, all function calls will be resolved before the return executes, so we can return the value of the Math.random() function.
Change randomFraction to return a random number instead of returning 0.

Generate Random Whole Numbers with JavaScript
It's great that we can generate random decimal numbers, but it's even more useful if we use it to generate random whole numbers.
Use Math.random() to generate a random decimal.
Multiply that random decimal by 20.
Use another function, Math.floor() to round the number down to its nearest whole number.
Remember that Math.random() can never quite return a 1 and, because we're rounding down, it's impossible to actually get 20. This technique will give us a whole number between 0 and 19.
Putting everything together, this is what our code looks like:
Math.floor(Math.random() * 20);
We are calling Math.random(), multiplying the result by 20, then passing the value to Math.floor() function to round the value down to the nearest whole number.
Use this technique to generate and return a random whole number between 0 and 9.

Generate Random Whole Numbers within a Range
Instead of generating a random whole number between zero and a given number like we did before, we can generate a random whole number that falls within a range of two specific numbers.
To do this, we'll define a minimum number min and a maximum number max.
Here's the formula we'll use. Take a moment to read it and try to understand what this code is doing:
Math.floor(Math.random() * (max - min + 1)) + min
Create a function called randomRange that takes a range myMin and myMax and returns a random whole number that's greater than or equal to myMin, and is less than or equal to myMax, inclusive.

** resources

*** finish

freeCodeCamp Basic JavaScript
  i didn't understand recursion without loop

** html dom

get the element iwth the specified id:
document.getElementById(elementID)
document.getElementById("demo")

The example below "finds" an HTML element (with id="demo"), and changes the element content (innerHTML) to "Hello JavaScript":


JavaScript Can Change HTML Styles (CSS)
Changing the style of an HTML element, is a variant of changing an HTML attribute:
Example
document.getElementById("demo").style.fontSize = "35px";

JavaScript Can Hide HTML Elements
Hiding HTML elements can be done by changing the display style:
Example
document.getElementById("demo").style.display = "none";


#+begin_src js
// js get the element with the specified id:demo
document.getElementById("demo");
// js using id:demo and change html content: Hello
document.getElementById("demo").innerHTML = "Hello";
// js using id:demo and change html styles font size to 35px
document.getElementById("demo").style.fontSize = "35px";
// js using id:demo and change html styles: display to none
document.getElementById("demo").style.display = "none";
#+end_src

** JavaScript Events

HTML events are "things" that happen to HTML elements.

When JavaScript is used in HTML pages, JavaScript can "react" on these events.
HTML Events

An HTML event can be something the browser does, or something a user does.

Here are some examples of HTML events:

    An HTML web page has finished loading
    An HTML input field was changed
    An HTML button was clicked

Often, when events happen, you may want to do something.

JavaScript lets you execute code when events are detected.

HTML allows event handler attributes, with JavaScript code, to be added to HTML elements.

With single quotes:
<element event='some JavaScript'>

With double quotes:
<element event="some JavaScript">

In the following example, an onclick attribute (with code), is added to a <button> element:
Example
<button onclick="document.getElementById('demo').innerHTML = Date()">The time is?</button>

In the example above, the JavaScript code changes the content of the element with id="demo".

In the next example, the code changes the content of its own element (using this.innerHTML):
Example
<button onclick="this.innerHTML = Date()">The time is?</button>

JavaScript code is often several lines long. It is more common to see event attributes calling functions:
Example
<button onclick="displayDate()">The time is?</button>
Common HTML Events

Here is a list of some common HTML events:
Event 	Description
onchange 	An HTML element has been changed
onclick 	The user clicks an HTML element
onmouseover 	The user moves the mouse over an HTML element
onmouseout 	The user moves the mouse away from an HTML element
onkeydown 	The user pushes a keyboard key
onload 	The browser has finished loading the page

The list is much longer: W3Schools JavaScript Reference HTML DOM Events.
JavaScript Event Handlers

Event handlers can be used to handle and verify user input, user actions, and browser actions:

    Things that should be done every time a page loads
    Things that should be done when the page is closed
    Action that should be performed when a user clicks a button
    Content that should be verified when a user inputs data
    And more ...

Many different methods can be used to let JavaScript work with events:

    HTML event attributes can execute JavaScript code directly
    HTML event attributes can call JavaScript functions
    You can assign your own event handler functions to HTML elements
    You can prevent events from being sent or being handled
    And more ...

You will learn a lot more about events and event handlers in the HTML DOM chapters.
Test Yourself With Exercises
Exercise:

The <button> element should do something when someone clicks on it. Try to fix it!

<button ="alert('Hello')">Click me.</button>


Start the Exercise

** JavaScript Style Guide
Always use the same coding conventions for all your JavaScript projects.

JavaScript Coding Conventions
Coding conventions are style guidelines for programming. They typically cover:

Naming and declaration rules for variables and functions.
Rules for the use of white space, indentation, and comments.
Programming practices and principles
Coding conventions secure quality:

Improves code readability
Make code maintenance easier
Coding conventions can be documented rules for teams to follow, or just be your individual coding practice.

This page describes the general JavaScript code conventions used by W3Schools.
You should also read the next chapter "Best Practices", and learn how to avoid coding pitfalls.

Variable Names
At W3schools we use camelCase for identifier names (variables and functions).

All names start with a letter.

At the bottom of this page, you will find a wider discussion about naming rules.

firstName = "John";
lastName = "Doe";

price = 19.90;
tax = 0.20;

fullPrice = price + (price * tax);
Spaces Around Operators
Always put spaces around operators ( = + - * / ), and after commas:

Examples:
let x = y + z;
const myArray = ["Volvo", "Saab", "Fiat"];
Code Indentation
Always use 2 spaces for indentation of code blocks:

Functions:
function toCelsius(fahrenheit) {
  return (5 / 9) * (fahrenheit - 32);
}
Do not use tabs (tabulators) for indentation. Different editors interpret tabs differently.

Statement Rules
General rules for simple statements:

Always end a simple statement with a semicolon.
Examples:
const cars = ["Volvo", "Saab", "Fiat"];

const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};
General rules for complex (compound) statements:

Put the opening bracket at the end of the first line.
Use one space before the opening bracket.
Put the closing bracket on a new line, without leading spaces.
Do not end a complex statement with a semicolon.
Functions:
function toCelsius(fahrenheit) {
  return (5 / 9) * (fahrenheit - 32);
}
Loops:
for (let i = 0; i < 5; i++) {
  x += i;
}
Conditionals:
if (time < 20) {
  greeting = "Good day";
} else {
  greeting = "Good evening";
}
Object Rules
General rules for object definitions:

Place the opening bracket on the same line as the object name.
Use colon plus one space between each property and its value.
Use quotes around string values, not around numeric values.
Do not add a comma after the last property-value pair.
Place the closing bracket on a new line, without leading spaces.
Always end an object definition with a semicolon.
Example
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};
Short objects can be written compressed, on one line, using spaces only between properties, like this:

const person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
Line Length < 80
For readability, avoid lines longer than 80 characters.

If a JavaScript statement does not fit on one line, the best place to break it, is after an operator or a comma.

Example
document.getElementById("demo").innerHTML =
"Hello Dolly.";
Naming Conventions
Always use the same naming convention for all your code. For example:

Variable and function names written as camelCase
Global variables written in UPPERCASE (We don't, but it's quite common)
Constants (like PI) written in UPPERCASE
Should you use hyp-hens, camelCase, or under_scores in variable names?

This is a question programmers often discuss. The answer depends on who you ask:

Hyphens in HTML and CSS:

HTML5 attributes can start with data- (data-quantity, data-price).

CSS uses hyphens in property-names (font-size).

Hyphens can be mistaken as subtraction attempts. Hyphens are not allowed in JavaScript names.

Underscores:

Many programmers prefer to use underscores (date_of_birth), especially in SQL databases.

Underscores are often used in PHP documentation.

PascalCase:

PascalCase is often preferred by C programmers.

camelCase:

camelCase is used by JavaScript itself, by jQuery, and other JavaScript libraries.

Do not start names with a $ sign. It will put you in conflict with many JavaScript library names.

Loading JavaScript in HTML
Use simple syntax for loading external scripts (the type attribute is not necessary):

<script src="myscript.js"></script>
Accessing HTML Elements
A consequence of using "untidy" HTML styles, might result in JavaScript errors.

These two JavaScript statements will produce different results:

const obj = getElementById("Demo")

const obj = getElementById("demo")
If possible, use the same naming convention (as JavaScript) in HTML.

Visit the HTML Style Guide.

File Extensions
HTML files should have a .html extension (.htm is allowed).

CSS files should have a .css extension.

JavaScript files should have a .js extension.

Use Lower Case File Names
Most web servers (Apache, Unix) are case sensitive about file names:

london.jpg cannot be accessed as London.jpg.

Other web servers (Microsoft, IIS) are not case sensitive:

london.jpg can be accessed as London.jpg or london.jpg.

If you use a mix of upper and lower case, you have to be extremely consistent.

If you move from a case insensitive, to a case sensitive server, even small errors can break your web site.

To avoid these problems, always use lower case file names (if possible).

Performance
Coding conventions are not used by computers. Most rules have little impact on the execution of programs.

Indentation and extra spaces are not significant in small scripts.

For code in development, readability should be preferred. Larger production scripts should be minified.

*** writing readable code thinkful


earning Objective
By the end of this lesson, you will be able to refactor code to be more readable and more efficient.

Overview
At this point, you've learned several important JavaScript concepts. You're familiar with some essential JavaScript syntax, statements, and code-writing tools. And now, it's time to take those skills and refine them. In this lesson, you'll learn some techniques and best practices for writing readable code.

Key Terms
Guard clause
A statement that evaluates to a boolean that determines whether or not a function should continue running
As you know, developers should aim to write code that is clear, clean, and easy to read. And this lesson is all about helping you do that. Of course, there are different approaches and techniques, and the advice provided in this lesson reflects that subjectivity. None of the techniques included here are required. However, they will improve the readability of your code, and using them will show other developers (and potential employers) that you're thoughtful, careful, and professional.

For more advice on how to write code well, speak with experts in the field. Many developers have strong opinions on how to write code that is more legible and maintainable. Gathering information from different experts will help inform your preferences and practices.

Don't repeat yourself
One important rule that you will often hear as a developer is not to repeat yourself. In fact, don't repeat yourself is often abbreviated to DRY, and the whole idea is often captured in the following advice: write DRY code. Generally, this idea is used specifically in the context of functions. Because functions allow you to wrap up repeated code within a function, they can be particularly helpful when it comes to writing DRY code.

However, this is only one way to think about the phrase "don't repeat yourself." Take a look at the following data and function. Spend a few moments reviewing it to make sure you understand what is happening. What do you notice? Then, try running the function yourself.

const authors = [
  {
    id: 1,
    name: {
      firstName: "Philip",
      surname: "Pullman",
    },
    series: ["His Dark Materials", "Sally Lockhart"],
  },
  {
    id: 2,
    name: {
      firstName: "Terry",
      lastName: "Pratchett",
    },
    series: ["Discworld", "Long Earth"],
  },
];

function getAllSeries(authors) {
  const result = [];
  for (let i = 0; i < authors.length; i++) {
    for (let j = 0; j < authors[i].series.length; j++) {
      result.push(authors[i].series[j]);
    }
  }
  return result;
}

getAllSeries(authors);
//> [ 'His Dark Materials', 'Sally Lockhart', 'Discworld', 'Long Earth' ]
In the above function, there is some duplicate code. Can you see it? The code shows authors[i] multiple times.

But maybe that can be tightened up. Instead, you could assign this value to the variable. Check it out:

function getAllSeries(authors) {
  const result = [];
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    for (let j = 0; j < author.series.length; j++) {
      result.push(author.series[j]);
    }
  }
  return result;
}
Although you've technically made the above function a bit longer, it's now much clearer. It also avoids using authors[i] multiple times.

If you want to try out the code, you can use this REPL:


Return early
Another important rule is to return early. At its most basic level, the return-early mindset involves writing a function that terminates or throws an error as soon as something is wrong, with the goal of yielding the correct result—the one that you'd expect—at the end of the function.

To better understand this idea, take a look at the following function. This code sample expects inputted data that is similar to that authors array from above.

function getSeriesListById(authors, id) {
  let selected = null;
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    if (author.id === id) selected = author;
  }

  if (id) {
    if (selected) {
      const message = `Series list: ${selected.series.join(", ")}`;
      return message;
    } else {
      return [];
    }
  } else {
    return "No ID provided.";
  }
}
In the above function, the authors array and an id are given to the function. If the id matches one of the authors, the code returns the series for that author. Otherwise, it returns an empty array. If no id is inputted, it returns a string at the end saying so: No ID provided.

The above code isn't that complicated. But it can be made simpler by returning early. Check it out:

function getSeriesListById(authors, id) {
  if (!id) return "No ID provided.";

  let selected = null;
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    if (author.id === id) selected = author;
  }
  if (!selected) return [];

  return `Series list: ${selected.series.join(", ")}`;
}
In this modified example, the function stops if there is no id inputted rather than running despite the lack of id. In fact, when the function stops, the same string from above, No ID provided, is returned. But you'll notice that this happens near the beginning of the function, rather than at the end. This means that the code below that point does not have to run, and it is letting you know as soon as possible that there's no id inputted.

This is sometimes referred to as a guard clause. A guard clause is a statement that evaluates to a boolean that determines whether or not a function should continue running. Implementing guard clauses in your code will make your code much more efficient and easier to read.

Avoid boolean returns
One final rule is to avoid boolean returns when possible. Although this isn't always possible, you can often avoid explicitly returning true and false by returning the expression that is evaluating the statement.

For example, take a look at the following function. What do you notice?

function moreThanThreeAuthors(authors) {
  if (authors.length > 3) {
    return true;
  } else {
    return false;
  }
}
The function above just checks if there are more than three authors in the given array. But you can actually write a stronger, shorter function with the following:

function moreThanThreeAuthors(authors) {
  return authors.length > 3;
}
The conditional statement will already be evaluated to a boolean, so you don't need to explicitly return true or false.


DRY (Don't repeat yourself) & Writing readable code

Simplify condition based functions by returning the comparison instead of true or false explicitly

function isAdult(age){
  if(age > 17){
    return true;
  } else {
    return false;
  }
}


function isAdult(age){
  return age > 17;
}


DRY (Don't repeat yourself) & Writing readable code

const characters = [
  {
    id: 1,
    name: {
      firstName: "Sonic",
      lastname: "Hedgehog",
    },
    games: ["Sonic 1", "Sonic 2"],
  },
  {
    id: 2,
    name: {
      firstName: "Lara",
      lastName: "Croft",
    },
    games: ["Tomb Raider", "Tomb Raider 2"],
  },
];

function getAllGames(characters) {
  const result = [];
  for (let i = 0; i < characters.length; i++) {
    for (let j = 0; j < characters[i].games.length; j++) {
      result.push(characters[i].games[j]);
    }
  }
  return result;
}

getAllGames(characters);

function getAllGames(characters) {
  const result = [];
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    for (let j = 0; j < character.games.length; j++) {
      result.push(character.games[j]);
    }
  }
  return result;
}

getAllGames(characters);

** JavaScript Best Practices
Avoid global variables, avoid new, avoid ==, avoid eval()

Avoid Global Variables
Minimize the use of global variables.

This includes all data types, objects, and functions.

Global variables and functions can be overwritten by other scripts.

Use local variables instead, and learn how to use closures.

Always Declare Local Variables
All variables used in a function should be declared as local variables.

Local variables must be declared with the var keyword or the let keyword,or the const keyword, otherwise they will become global variables.

Strict mode does not allow undeclared variables.

Declarations on Top
It is a good coding practice to put all declarations at the top of each script or function.

This will:

Give cleaner code
Provide a single place to look for local variables
Make it easier to avoid unwanted (implied) global variables
Reduce the possibility of unwanted re-declarations
// Declare at the beginning
let firstName, lastName, price, discount, fullPrice;

// Use later
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price - discount;
This also goes for loop variables:

for (let i = 0; i < 5; i++) {
Initialize Variables
It is a good coding practice to initialize variables when you declare them.

This will:

Give cleaner code
Provide a single place to initialize variables
Avoid undefined values
// Declare and initiate at the beginning
let firstName = "",
let lastName = "",
let price = 0,
let discount = 0,
let fullPrice = 0,
const myArray = [],
const myObject = {};
Initializing variables provides an idea of the intended use (and intended data type).

Declare Objects with const
Declaring objects with const will prevent any accidental change of type:

Example
let car = {type:"Fiat", model:"500", color:"white"};
car = "Fiat";      // Changes object to string

const car = {type:"Fiat", model:"500", color:"white"};
car = "Fiat";      // Not possible
Declare Arrays with const
Declaring arrays with const will prevent any accidential change of type:

Example
let cars = ["Saab", "Volvo", "BMW"];
cars = 3;    // Changes array to number

const cars = ["Saab", "Volvo", "BMW"];
cars = 3;    // Not possible
Don't Use new Object()
Use "" instead of new String()
Use 0 instead of new Number()
Use false instead of new Boolean()
Use {} instead of new Object()
Use [] instead of new Array()
Use /()/ instead of new RegExp()
Use function (){} instead of new Function()
Example
let x1 = "";             // new primitive string
let x2 = 0;              // new primitive number
let x3 = false;          // new primitive boolean
const x4 = {};           // new object
const x5 = [];           // new array object
const x6 = /()/;         // new regexp object
const x7 = function(){}; // new function object
Beware of Automatic Type Conversions
JavaScript is loosely typed.

A variable can contain all data types.

A variable can change its data type:

Example
let x = "Hello";     // typeof x is a string
x = 5;               // changes typeof x to a number
Beware that numbers can accidentally be converted to strings or NaN (Not a Number).

When doing mathematical operations, JavaScript can convert numbers to strings:

Example
let x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number
let x = 5 + "7";     // x.valueOf() is 57,  typeof x is a string
let x = "5" + 7;     // x.valueOf() is 57,  typeof x is a string
let x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number
let x = 5 - "7";     // x.valueOf() is -2,  typeof x is a number
let x = "5" - 7;     // x.valueOf() is -2,  typeof x is a number
let x = 5 - "x";     // x.valueOf() is NaN, typeof x is a number
Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):

Example
"Hello" - "Dolly"    // returns NaN
Use === Comparison
The == comparison operator always converts (to matching types) before comparison.

The === operator forces comparison of values and type:

Example
0 == "";        // true
1 == "1";       // true
1 == true;      // true

0 === "";       // false
1 === "1";      // false
1 === true;     // false
Use Parameter Defaults
If a function is called with a missing argument, the value of the missing argument is set to undefined.

Undefined values can break your code. It is a good habit to assign default values to arguments.

Example
function myFunction(x, y) {
  if (y === undefined) {
    y = 0;
  }
}
ECMAScript 2015 allows default parameters in the function definition:

function (a=1, b=1) { /*function code*/ }
Read more about function parameters and arguments at Function Parameters

End Your Switches with Defaults
Always end your switch statements with a default. Even if you think there is no need for it.

Example
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
    break;
  default:
    day = "Unknown";
}
Avoid Number, String, and Boolean as Objects
Always treat numbers, strings, or booleans as primitive values. Not as objects.

Declaring these types as objects, slows down execution speed, and produces nasty side effects:

Example
let x = "John";
let y = new String("John");
(x === y) // is false because x is a string and y is an object.
Or even worse:

Example
let x = new String("John");
let y = new String("John");
(x == y) // is false because you cannot compare objects.
Avoid Using eval()
The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it.

Because it allows arbitrary code to be run, it also represents a security problem.

** JavaScript Common Mistakes
This chapter points out some common JavaScript mistakes.

Accidentally Using the Assignment Operator
JavaScript programs may generate unexpected results if a programmer accidentally uses an assignment operator (=), instead of a comparison operator (==) in an if statement.

This if statement returns false (as expected) because x is not equal to 10:

let x = 0;
if (x == 10)
This if statement returns true (maybe not as expected), because 10 is true:

let x = 0;
if (x = 10)
This if statement returns false (maybe not as expected), because 0 is false:

let x = 0;
if (x = 0)
An assignment always returns the value of the assignment.

Expecting Loose Comparison
In regular comparison, data type does not matter. This if statement returns true:

let x = 10;
let y = "10";
if (x == y)
In strict comparison, data type does matter. This if statement returns false:

let x = 10;
let y = "10";
if (x === y)
It is a common mistake to forget that switch statements use strict comparison:

This case switch will display an alert:

let x = 10;
switch(x) {
  case 10: alert("Hello");
}
This case switch will not display an alert:

let x = 10;
switch(x) {
  case "10": alert("Hello");
}
Confusing Addition & Concatenation
Addition is about adding numbers.

Concatenation is about adding strings.

In JavaScript both operations use the same + operator.

Because of this, adding a number as a number will produce a different result from adding a number as a string:

let x = 10;
x = 10 + 5;       // Now x is 15

let y = 10;
y += "5";        // Now y is "105"
When adding two variables, it can be difficult to anticipate the result:

let x = 10;
let y = 5;
let z = x + y;     // Now z is 15

let x = 10;
let y = "5";
let z = x + y;     // Now z is "105"
Misunderstanding Floats
All numbers in JavaScript are stored as 64-bits Floating point numbers (Floats).

All programming languages, including JavaScript, have difficulties with precise floating point values:

let x = 0.1;
let y = 0.2;
let z = x + y            // the result in z will not be 0.3
To solve the problem above, it helps to multiply and divide:

Example
let z = (x * 10 + y * 10) / 10;       // z will be 0.3
Breaking a JavaScript String
JavaScript will allow you to break a statement into two lines:

Example 1
let x =
"Hello World!";
But, breaking a statement in the middle of a string will not work:

Example 2
let x = "Hello
World!";
You must use a "backslash" if you must break a statement in a string:

Example 3
let x = "Hello \
World!";
Misplacing Semicolon
Because of a misplaced semicolon, this code block will execute regardless of the value of x:

if (x == 19);
{
  // code block
}
Breaking a Return Statement
It is a default JavaScript behavior to close a statement automatically at the end of a line.

Because of this, these two examples will return the same result:

Example 1
function myFunction(a) {
  let power = 10
  return a * power
}
Example 2
function myFunction(a) {
  let power = 10;
  return a * power;
}
JavaScript will also allow you to break a statement into two lines.

Because of this, example 3 will also return the same result:

Example 3
function myFunction(a) {
  let
  power = 10;
  return a * power;
}
But, what will happen if you break the return statement in two lines like this:

Example 4
function myFunction(a) {
  let
  power = 10;
  return
  a * power;
}
The function will return undefined!

Why? Because JavaScript thought you meant:

Example 5
function myFunction(a) {
  let
  power = 10;
  return;
  a * power;
}
Explanation
If a statement is incomplete like:

let
JavaScript will try to complete the statement by reading the next line:

power = 10;
But since this statement is complete:

return
JavaScript will automatically close it like this:

return;
This happens because closing (ending) statements with semicolon is optional in JavaScript.

JavaScript will close the return statement at the end of the line, because it is a complete statement.

Never break a return statement.

Accessing Arrays with Named Indexes
Many programming languages support arrays with named indexes.

Arrays with named indexes are called associative arrays (or hashes).

JavaScript does not support arrays with named indexes.

In JavaScript, arrays use numbered indexes:

Example
const person = [];
person[0] = "John";
person[1] = "Doe";
person[2] = 46;
person.length;       // person.length will return 3
person[0];           // person[0] will return "John"
In JavaScript, objects use named indexes.

If you use a named index, when accessing an array, JavaScript will redefine the array to a standard object.

After the automatic redefinition, array methods and properties will produce undefined or incorrect results:

Example:
const person = [];
person["firstName"] = "John";
person["lastName"] = "Doe";
person["age"] = 46;
person.length;      // person.length will return 0
person[0];          // person[0] will return undefined
Ending Definitions with a Comma
Trailing commas in object and array definition are legal in ECMAScript 5.

Object Example:
person = {firstName:"John", lastName:"Doe", age:46,}
Array Example:
points = [40, 100, 1, 5, 25, 10,];
WARNING !!

Internet Explorer 8 will crash.

JSON does not allow trailing commas.

JSON:
person = {"firstName":"John", "lastName":"Doe", "age":46}
JSON:
points = [40, 100, 1, 5, 25, 10];
Undefined is Not Null
JavaScript objects, variables, properties, and methods can be undefined.

In addition, empty JavaScript objects can have the value null.

This can make it a little bit difficult to test if an object is empty.

You can test if an object exists by testing if the type is undefined:

Example:
if (typeof myObj === "undefined")
But you cannot test if an object is null, because this will throw an error if the object is undefined:

Incorrect:
if (myObj === null)
To solve this problem, you must test if an object is not null, and not undefined.

But this can still throw an error:

Incorrect:
if (myObj !== null && typeof myObj !== "undefined")
Because of this, you must test for not undefined before you can test for not null:

Correct:
if (typeof myObj !== "undefined" && myObj !== null)

** JavaScript Performance
How to speed up your JavaScript code.

Reduce Activity in Loops
Loops are often used in programming.

Each statement in a loop, including the for statement, is executed for each iteration of the loop.

Statements or assignments that can be placed outside the loop will make the loop run faster.

Bad:
for (let i = 0; i < arr.length; i++) {
Better Code:
let l = arr.length;
for (let i = 0; i < l; i++) {
The bad code accesses the length property of an array each time the loop is iterated.

The better code accesses the length property outside the loop and makes the loop run faster.

Reduce DOM Access
Accessing the HTML DOM is very slow, compared to other JavaScript statements.

If you expect to access a DOM element several times, access it once, and use it as a local variable:

Example
const obj = document.getElementById("demo");
obj.innerHTML = "Hello";
Reduce DOM Size
Keep the number of elements in the HTML DOM small.

This will always improve page loading, and speed up rendering (page display), especially on smaller devices.

Every attempt to search the DOM (like getElementsByTagName) will benefit from a smaller DOM.

Avoid Unnecessary Variables
Don't create new variables if you don't plan to save values.

Often you can replace code like this:

let fullName = firstName + " " + lastName;
document.getElementById("demo").innerHTML = fullName;
With this:

document.getElementById("demo").innerHTML = firstName + " " + lastName;
Delay JavaScript Loading
Putting your scripts at the bottom of the page body lets the browser load the page first.

While a script is downloading, the browser will not start any other downloads. In addition all parsing and rendering activity might be blocked.

The HTTP specification defines that browsers should not download more than two components in parallel.

An alternative is to use defer="true" in the script tag. The defer attribute specifies that the script should be executed after the page has finished parsing, but it only works for external scripts.

If possible, you can add your script to the page by code, after the page has loaded:

Example
<script>
window.onload = function() {
  const element = document.createElement("script");
  element.src = "myScript.js";
  document.body.appendChild(element);
};
</script>
Avoid Using with
Avoid using the with keyword. It has a negative effect on speed. It also clutters up JavaScript scopes.

The with keyword is not allowed in strict mode.

** JavaScript Reserved Words
In JavaScript you cannot use these reserved words as variables, labels, or function names:
abstract 	arguments 	await* 	boolean
break 	byte 	case 	catch
char 	class* 	const 	continue
debugger 	default 	delete 	do
double 	else 	enum* 	eval
export* 	extends* 	false 	final
finally 	float 	for 	function
goto 	if 	implements 	import*
in 	instanceof 	int 	interface
let* 	long 	native 	new
null 	package 	private 	protected
public 	return 	short 	static
super* 	switch 	synchronized 	this
throw 	throws 	transient 	true
try 	typeof 	var 	void
volatile 	while 	with 	yield
Words marked with* are new in ECMAScript 5 and 6.

You can read more about the different JavaScript versions in the chapter JS Versions.
Removed Reserved Words
The following reserved words have been removed from the ECMAScript 5/6 standard:
abstract 	boolean 	byte 	char
double 	final 	float 	goto
int 	long 	native 	short
synchronized 	throws 	transient 	volatile

Do not use these words as variables. ECMAScript 5/6 does not have full support in all browsers.
JavaScript Objects, Properties, and Methods
You should also avoid using the name of JavaScript built-in objects, properties, and methods:
Array 	Date 	eval 	function
hasOwnProperty 	Infinity 	isFinite 	isNaN
isPrototypeOf 	length 	Math 	NaN
name 	Number 	Object 	prototype
String 	toString 	undefined 	valueOf
Java Reserved Words
JavaScript is often used together with Java. You should avoid using some Java objects and properties as JavaScript identifiers:
getClass 	java 	JavaArray 	javaClass
JavaObject 	JavaPackage
Other Reserved Words

JavaScript can be used as the programming language in many applications.
You should also avoid using the name of HTML and Window objects and properties:
alert 	all 	anchor 	anchors
area 	assign 	blur 	button
checkbox 	clearInterval 	clearTimeout 	clientInformation
close 	closed 	confirm 	constructor
crypto 	decodeURI 	decodeURIComponent 	defaultStatus
document 	element 	elements 	embed
embeds 	encodeURI 	encodeURIComponent 	escape
event 	fileUpload 	focus 	form
forms 	frame 	innerHeight 	innerWidth
layer 	layers 	link 	location
mimeTypes 	navigate 	navigator 	frames
frameRate 	hidden 	history 	image
images 	offscreenBuffering 	open 	opener
option 	outerHeight 	outerWidth 	packages
pageXOffset 	pageYOffset 	parent 	parseFloat
parseInt 	password 	pkcs11 	plugin
prompt 	propertyIsEnum 	radio 	reset
screenX 	screenY 	scroll 	secure
select 	self 	setInterval 	setTimeout
status 	submit 	taint 	text
textarea 	top 	unescape 	untaint
window
HTML Event Handlers

In addition you should avoid using the name of all HTML event handlers.
Examples:
onblur 	onclick 	onerror 	onfocus
onkeydown 	onkeypress 	onkeyup 	onmouseover
onload 	onmouseup 	onmousedown 	onsubmit

** unsorted

REPL stand for Read-eval-print loop
  an interactive computer programming environment that lets you perform basic tasks

Order of operations
Also called operator precedence, a collection of rules that govern the order in which operators are evaluated
  Parentheses
  Exponents
  Multiplication
  Division
  Addition
  Subtraction

Truthy values
Values that an if statement will treat as true
!! turns anything to a boolean
Falsy values
Values that an if statement will treat as false
  // Values that evaluate to `false`
  false; // `false` itself
  ""; // Empty string
  0; // Zero
  null;
  undefined;
  NaN; // Not a number


Tracing
    The process of following values through a program

conditional statements
    An if statement checks a condition and will execute a task if that condition evaluates to true.
    if...else statements make binary decisions and execute different code blocks based on a provided condition.
    We can add more conditions using else if statements.
    Comparison operators, including <, >, <=, >=, ===, and !== can compare two values.
    The logical and operator, &&, or “and”, checks if both provided expressions are truthy.
    The logical operator ||, or “or”, checks if either provided expression is truthy.
    The bang operator, !, switches the truthiness and falsiness of a value.
    The ternary operator is shorthand to simplify concise if...else statements.
    A switch statement can be used to simplify the process of writing multiple else if statements. The break keyword stops the remaining cases from being checked and executed in a switch statement.

*** JavaScript Where To

The <script> Tag

In HTML, JavaScript code is inserted between <script> and </script> tags.
Example
<script>
document.getElementById("demo").innerHTML = "My First JavaScript";
</script>

Old JavaScript examples may use a type attribute: <script type="text/javascript">.
The type attribute is not required. JavaScript is the default scripting language in HTML.
JavaScript Functions and Events

A JavaScript function is a block of JavaScript code, that can be executed when "called" for.

For example, a function can be called when an event occurs, like when the user clicks a button.

You will learn much more about functions and events in later chapters.
JavaScript in <head> or <body>

You can place any number of scripts in an HTML document.

Scripts can be placed in the <body>, or in the <head> section of an HTML page, or in both.
JavaScript in <head>

In this example, a JavaScript function is placed in the <head> section of an HTML page.

The function is invoked (called) when a button is clicked:
Example
<!DOCTYPE html>
<html>
<head>
<script>
function myFunction() {
  document.getElementById("demo").innerHTML = "Paragraph changed.";
}
</script>
</head>
<body>

<h2>Demo JavaScript in Head</h2>

<p id="demo">A Paragraph</p>
<button type="button" onclick="myFunction()">Try it</button>

</body>
</html>
JavaScript in <body>

In this example, a JavaScript function is placed in the <body> section of an HTML page.

The function is invoked (called) when a button is clicked:
Example
<!DOCTYPE html>
<html>
<body>

<h2>Demo JavaScript in Body</h2>

<p id="demo">A Paragraph</p>

<button type="button" onclick="myFunction()">Try it</button>

<script>
function myFunction() {
  document.getElementById("demo").innerHTML = "Paragraph changed.";
}
</script>

</body>
</html>

Placing scripts at the bottom of the <body> element improves the display speed, because script interpretation slows down the display.
External JavaScript

Scripts can also be placed in external files:
External file: myScript.js
function myFunction() {
  document.getElementById("demo").innerHTML = "Paragraph changed.";
}

External scripts are practical when the same code is used in many different web pages.

JavaScript files have the file extension .js.

To use an external script, put the name of the script file in the src (source) attribute of a <script> tag:
Example
<script src="myScript.js"></script>

You can place an external script reference in <head> or <body> as you like.

The script will behave as if it was located exactly where the <script> tag is located.

External scripts cannot contain <script> tags.
External JavaScript Advantages

Placing scripts in external files has some advantages:

    It separates HTML and code
    It makes HTML and JavaScript easier to read and maintain
    Cached JavaScript files can speed up page loads

To add several script files to one page  - use several script tags:
Example
<script src="myScript1.js"></script>
<script src="myScript2.js"></script>
External References

An external script can be referenced in 3 different ways:

    With a full URL (a full web address)
    With a file path (like /js/)
    Without any path

This example uses a full URL to link to myScript.js:
Example
<script src="https://www.w3schools.com/js/myScript.js"></script>

This example uses a file path to link to myScript.js:
Example
<script src="/js/myScript.js"></script>

This example uses no path to link to myScript.js:
Example
<script src="myScript.js"></script>

*** JavaScript Output
JavaScript Display Possibilities

JavaScript can "display" data in different ways:

    Writing into an HTML element, using innerHTML.
    Writing into the HTML output using document.write().
    Writing into an alert box, using window.alert().
    Writing into the browser console, using console.log().

Using innerHTML

To access an HTML element, JavaScript can use the document.getElementById(id) method.

The id attribute defines the HTML element. The innerHTML property defines the HTML content:
Example
<!DOCTYPE html>
<html>
<body>

<h1>My First Web Page</h1>
<p>My First Paragraph</p>

<p id="demo"></p>

<script>
document.getElementById("demo").innerHTML = 5 + 6;
</script>

</body>
</html>

Changing the innerHTML property of an HTML element is a common way to display data in HTML.
Using document.write()

For testing purposes, it is convenient to use document.write():
Example
<!DOCTYPE html>
<html>
<body>

<h1>My First Web Page</h1>
<p>My first paragraph.</p>

<script>
document.write(5 + 6);
</script>

</body>
</html>

Using document.write() after an HTML document is loaded, will delete all existing HTML:
Example
<!DOCTYPE html>
<html>
<body>

<h1>My First Web Page</h1>
<p>My first paragraph.</p>

<button type="button" onclick="document.write(5 + 6)">Try it</button>

</body>
</html>

The document.write() method should only be used for testing.
Using window.alert()

You can use an alert box to display data:
Example
<!DOCTYPE html>
<html>
<body>

<h1>My First Web Page</h1>
<p>My first paragraph.</p>

<script>
window.alert(5 + 6);
</script>

</body>
</html>

You can skip the window keyword.

In JavaScript, the window object is the global scope object, that means that variables, properties, and methods by default belong to the window object. This also means that specifying the window keyword is optional:
Example
<!DOCTYPE html>
<html>
<body>

<h1>My First Web Page</h1>
<p>My first paragraph.</p>

<script>
alert(5 + 6);
</script>

</body>
</html>
Using console.log()

For debugging purposes, you can call the console.log() method in the browser to display data.

You will learn more about debugging in a later chapter.
Example
<!DOCTYPE html>
<html>
<body>

<script>
console.log(5 + 6);
</script>

</body>
</html>
JavaScript Print

JavaScript does not have any print object or print methods.

You cannot access output devices from JavaScript.

The only exception is that you can call the window.print() method in the browser to print the content of the current window.
Example
<!DOCTYPE html>
<html>
<body>

<button onclick="window.print()">Print this page</button>

</body>
</html>

*** error types thinkful
**** Runtime errors

errorType: description of the error
SyntaxError: function statement requires a name

**** Reference errors

Reference error - An error that occurs when some variable being referenced doesn't exist or can't be accessed

In console.log statement the variable customerName is misspelled

A reference error tells you that some variable being referenced doesn't exist.
You can fix this kind of error by finding the offending reference and checking for the correct name.

But a ReferenceError could also surface if the variable cannot be accessed at all.

In the above example, the result variable does exist, but it exists only inside the addSalesTax() function.
Attempting to access that variable outside of that function would lead to a ReferenceError.
(This is because of a concept called scope, which you'll learn about later in this module.)

#+begin_src js
// reference error caused by misspelling variable name
const customerName = "Alfie Lee";
// customerName is mis-spelled
console.log(customrName); // returns ReferenceError: customrName is not defined

// reference error caused variable can't be accessed
function addSalesTax(total, salesTax) { //func takes parameters total and salesTax
    let result = total * (1 + salesTax); // declare result asign total times (salesTax plus one)
    return result; // return results
}
// trying print result but result but result only exist is local scope of function
console.log(result); //returns ReferenceError: result is not defined
#+end_src

**** Syntax errors

Syntax error - An error that occurs when some part of the predefined JavaScript syntax is being used incorrectly

A syntax error will occur when some part of the predefined JavaScript syntax is used incorrectly, such as a character is used twice or not used at all.
These errors are common for developers due to the simple fact that coding uses many symbols and characters that people don't otherwise use.
For instance, because curly brackets {} are unusual in regular typing, it can be easy to forget one.

Take a look at the following code. Can you find what's missing?

function printWelcome () {
  console.log("Welcome to our store!";
}
Above, you'll see that the console.log() statement is missing a closing parenthesis ).
The error that would surface because of the above code would be as follows:

SyntaxError: missing ) after argument list
Although that message is fairly straightforward, it often isn't that simple.
It can be challenging to actually resolve a SyntaxError with longer, more complex code.
In the case of a SyntaxError, you often just need to look through your code patiently and carefully for the missing or extra symbol.

Correctly indenting your code and using a code formatter can be useful for identifying (and preventing) issues like this.
For example, take a look at the following code.

function openInstructions (weather, temperatureInCelsius) {
if (weather && temperatureInCelsius) {
  if (weather === "sunny") {
  if (temperatureInCelsius > 20) {
    return "Set up the patio and put out umbrellas. Open indoor windows.";
  } else { return "Set up the patios, umbrellas optional. Open indoor windows."; }
  } else if (weather === "rainy") {
    if (temperatureInCelsius > 10) {
      return "Open indoor windows slightly.";
    } else { return "Keep windows closed." } }
  }
} else {
  return "Please set the `weather` and `temperatureInCelsius` variables.";
}
}

openInstructions("sunny", 18);
If you were to run the above code, you would receive this message in the console:

SyntaxError: expected expression, got '}'
That isn't very helpful, and you'd have to do the legwork of resolving the issue.
This is one of the many reasons that it's important to write your code legibly.

**** Type errors

Type error - An error that occurs when you misuse a data type in JavaScript, meaning that an operation can't be performed

And finally, you'll learn about the TypeError.
A type error will occur when you misuse a data type in JavaScript, meaning that an operation can't be performed.
One of the most common ways that this error will occur is through a situation like this:

price.trim(); //> TypeError: price.trim is not a function
As it turns out, the trim() function, when called on a string, removes extra whitespace from the beginning and the end of that string.
So in this case, why would price.trim() not be a function? Well, this error is likely telling you that price isn't actually a string.

To better understand what's going on, take a look at the whole picture:

let price = 9.99;
price.trim(); //> TypeError: price.trim is not a function
You might expect this error to tell you that price isn't the right data type, rather than telling you that trim() isn't a function. To better understand why the error is described the way it is, try running the following code:

let price = 9.99;
console.log(price.trim); //> undefined
You may be surprised to find that calling trim as a property on price doesn't fail—instead, it returns an undefined. But when you try to invoke the undefined property, that is when you get your error.

**** Silent errors

Silent error - An error that doesn't immediately surface when the code is run

The three errors described above are caught and revealed to you when you run your JavaScript code. However, it's also possible for errors to occur as you are writing code but not immediately surface when you run it. This type of error is called a silent error.

For example, take a look at the following code. Do you see any problems?

function formatPrice(priceInCents) {
  let formattedPrice = "$" + (priceInCents / 100).setFixed(2);
  return formattedPrice;
}
You may not notice any issues with this code right off the bat. And even when you run this code sample, no errors will surface. It is only when you invoke the function that you will see the error:

TypeError: (priceInCents / 100).setFixed is not a function
In this case, the function uses setFixed(), which is not a function, instead of toFixed(), which is a function. When working with complex applications with multiple functions, you'll need to be aware of silent errors like this one.

*** references thinkful

Primitive data type Also called a primitive or a simple data type, a data type containing variables that store values
Reference data type Also called a reference or a complex data type, a data type containing variables that store addresses to locations in memory

Primitive data types
JavaScript has several data types that are passed by value.
These are often called primitive data types, or simply primitives, and you've already learned a bit about them!
Primitive data types in JavaScript include strings, numbers, and booleans, as well as null and undefined.
When a primitive data type is assigned to a variable, that variable gets its own copy.

Take a look at the following line of code:

const title = "Mort";
In this example, the variable title contains the string "Mort". If you reassign the value contained by title to another variable, such as name, both variables will contain their own copy of that value. You can see this below.

let title = "Mort";
const name = title;
title = "Equal Rites";
console.log(title, name); //> "Equal Rites", "Mort"
The above code is very important. Although it may seem obvious, you should take a moment to understand what's happening here. When title is reassigned to "Equal Rites", notice that the name variable still holds its own copy of "Mort".

Now, take a look at another example. As you read over this, what do you expect to be logged?

let price = 1000;
let salePrice = price;
salePrice -= 100;
console.log(price, salePrice); //> 1000 900
In the code above, the price variable will still be the number 1000, while the salePrice variable will be 900. Despite the modification of salePrice, price retains its own copy of the value 1000.

Reference data types
But there's another kind of data type: reference data types. Reference data types, sometimes just called references, in JavaScript include functions, objects, and arrays. When a reference data type is assigned to a variable, the variable will contain a reference (also called a pointer) to the data.

Take a look at the following example. What do you expect to happen here?

const book = { title: "Mort", author: "Terry Pratchett" };
const mort = book;
book.price = 789;
console.log(mort); //> { title: "Mort", author: "Terry Pratchett", price: 789 }
Are you surprised by the result? Both the book variable and the mort variable point toward the same reference. That means that if you modify the object through one variable, the other variable will have that same modification.

This is further illustrated by the following two examples. Here's the first:

const author = {};
const book = {};
console.log(author === book); //> false
In the above console.log() statement, two empty objects, author and book, are compared with one another. When the === sign is used, it compares these objects' references.

These objects may look the same. However, the statement resolves to false. That is because author and book each store their own references to different objects.

Now, check out this example:

const sourcery = { title: "Sourcery", author: "Terry Pratchett" };
const favoriteBook = sourcery;
console.log(sourcery === favoriteBook); //> true
In the above console.log() statement, sourcery and favoriteBook contain references to the same object. When the === sign is used, it compares these references and resolves to true.

This works the same way for arrays, as well. Take a look:

const books = ["Mort", "Sourcery", "Equal Rites"];
const series = books;
series.push("Guards! Guards!");
console.log(books); //> [ "Mort", "Sourcery", "Equal Rites", "Guards! Guards!" ]
In the above example, push() changes the array to include a new title. This mutates the original array, which both books and series are pointing toward.

Note: In the examples above, const is used instead of let to store an array or object. And yet, the values inside of these arrays and objects can be changed. Ultimately, const only stops reassignment, without changing the values inside of the reference itself (in other words, the array or object).
