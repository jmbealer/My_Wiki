:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]

these are my notes on the thinkful program
this is a staging area for my notes need to summarize and move to a better place

[[id:63bc8d8d-4fc8-4b34-8881-43ace1415a53][JavaScript]]
[[id:6df2c337-4b01-470f-9028-d0745498f8a6][devWorkflow]]
[[id:dea16eb4-d34a-421b-b037-9f3e606ec001][git]]
[[id:43e93100-42e8-432e-99bb-ecdd6f6b7097][devCollab]]
[[id:a3333ce5-86aa-4729-af16-cd8dafd42149][Node.js]]

*** module 8 developer collaboration
**** pair programming

Pair programming The practice of working on a single problem with a peer, in one shared workspace

What is pair programming?
Pair programming, also called pairing, is the practice of working on a single problem with a peer, in one shared workspace.
Pair programming typically looks like two developers sitting down at one computer.
One developer will have their hands on the keyboard while the other will be sitting nearby, as the two work together to solve the same problem.
Some companies use pair programming for 100% of their work, others never use it, and still others use it for specific occasions like onboarding new developers.

Why use pair programming?
Proponents of pair programming say that there are many benefits.
Here are some of the most commonly cited benefits:
Increased code quality because the developers must communicate out loud as they program
Better transfer of skills from one developer to another
Improved resiliency to interruption or distraction, because disrupting the process means disrupting two people instead of one

Despite these benefits, pair programming isn't perfect.
This practice is often difficult, and it can turn into a negative experience for some people.
Later on in this lesson, you'll learn about ways to create a positive pairing environment.

Driving and navigating
In pair programming, there are two distinct roles: the driver and the navigator. Both have access to a keyboard, but the driver does most of the typing. Pairs should discuss a problem and agree on a rough solution. Then the driver is responsible for implementing it.

The navigator is responsible for keeping the larger picture in mind and guiding the driver in the right direction. The navigator also watches for syntax errors, thinks about solutions to the problems that the pair is solving, and researches questions in the background. If the navigator wants to type something, the best practice is to ask permission before doing so. Generally, the navigator should not dictate code word by word; instead, they should provide general directions that the driver then implements.

Pairing sessions
For most of the pairing sessions that you'll participate in during this program, you'll pair either with other students or with a mentor. Although these two scenarios will be different, there are common processes to follow throughout.

Starting a pairing session
Begin by determining who will be the driver and who will be the navigator. Clearly define a point when you will switch roles. Then discuss the tasks that you need to complete, and pick a place to start.

From the very beginning, it's easy to fall into a few traps. Watch out for the following issues:

The more experienced developer shouldn't take over, no matter if they are driving or navigating. The goal is to work together and share knowledge.

When you're the navigator, you aren't taking a break. The role of the navigator is to catch small issues, help brainstorm solutions, and look up syntax. Regardless of your role, be an active participant.

If either one of you is uncertain about where to begin or what is going on, then you should discuss the problem further. No one should be left behind.

It's important to stay engaged, no matter who you're working with. Ask questions, offer to be the driver, and do your best to stay focused.

During a pairing session
Aim to switch who is driving and who is navigating about every 30 minutes, or at another reasonable stopping place. Switching roles gives you both a chance to take a step back to consider what you've done and what you'll do next. And it's a way to make sure that both members of a pair understand what you're building.

If you aren't working on the same computer, the driver should push their work to GitHub when you switch, and the navigator should pull down that work. The new driver should start by reviewing what was done and discussing the plan for the next session.

It's also important to be direct with your partner throughout your pairing session. Because you set a baseline at the beginning of the session for what good communication means to you, you can bring it up with your partner if things have strayed from that baseline. Make sure to communicate your thoughts if you feel that the pairing isn't working effectively, or if you're struggling to work together effectively for any significant reason.

Finishing a pairing session
Remember that one of the most valuable aspects of this program is the steady flow of feedback that you get. Take five minutes at the end of the session to debrief with your partner.

You should both mention one thing that the other person did well during the session and one thing that they can improve on. Make sure to thank each other for the feedback and for working together for the session. And as you get this feedback from your partner, it's important to use this time to reflect on the feedback received and address any changes that you could implement to make future sessions more efficient.

Being a great partner
Be patient with your partner if one of you is having an easier time understanding the session's work. Don't feel too embarrassed if your partner takes on the role of teacher for the session. And if you have experience with a topic, don't work ahead if your partner doesn't understand what you're doing. At no point should either of you feel as though you aren't contributing to the project or learning something new.

When you're giving feedback, choose your words with care and make sure to say what you actually mean. And when you're receiving feedback, assume the best of your partner. They almost certainly intend to help you be productive and improve your skills, though every suggestion might not come out quite right. If you feel that your partner isn't being sensitive to your needs—for example, by driving for an entire session—speak up! Your partner is learning this new skill, too. Make sure that you bring up your concerns with specific feedback.

As you work, explain what you're implementing and specify why you are making each decision.

Pairing remotely
Working remotely makes it harder to understand someone, particularly if there's any subtlety to something that they're expressing. Aim to overcommunicate and be incredibly explicit about what you're doing and how you're feeling. When you're sitting next to someone, you might recognize when they're starting to get tired—but that's much harder to intuit remotely. Remember to take some short breaks if you or your partner are feeling burnt out.

Make sure that you have headphones that you're comfortable wearing for long periods. Headphones will reduce audio feedback and make it easier to hear each other.

*** module 9
**** Branches
***** What is a branch?
A branch is a collection of ordered commits.
Different branches can have the same commit history, or they can diverge.
The main branch is the first and only branch that is created when you initialize a new Git repository.

Moving forward, you should consider the main branch to be the most recent and correct version of your code.
That is, the main branch should contain code that is working and ready to be shared with the world.
This is useful when you're working individually; you'll always know that at least one branch has working code, even if you're working on a new feature and introduce a bug.
And reserving the main branch for production-ready code is a practice that only becomes more important as more people begin working on a project.

***** Creating branches
You can create a new branch with the git branch command, supplying the name of the branch as an argument.

git branch <branch-name>

This command will create a new branch in your local Git repository.
It's important to note that this will not make any changes on GitHub if your local repository is synced to a remote one.

Although you can name your branch anything that you want, many teams create naming conventions.
One common convention is to include your initials, followed by two dashes --, and then a descriptive but concise branch name. For example, recall Bill P.'s name for the new branch:

git branch bp--save-artist

After running this command, you can run the git branch command without any arguments.
This will show you what branches are available and which branch you are currently on.
The output will look something like this:
  bp--save-artist
  `* main`
In this output, two branches are listed: bp--save-artist and main. The asterisk * in front of main means that you're currently on that branch.

***** The checkout command
To switch to a new branch, you can use the git checkout command with the branch name, as shown below:

git checkout bp--save-artist
If you run git branch again, you'll see that the * has moved.

`* bp--save-artist`
  main

A note on checkout
The git checkout command is a bit overused.
Although it can be used for switching between branches, it can also be used to go back to an earlier commit as well as undo changes to a file.

***** Merging

Merging a branch The process of taking commits from one branch and adding them to another
Merging a branch refers to the process of taking commits from one branch and adding them to another.

You can do this with the git merge command. Here's an example:

git merge bp--save-artist
Note that where you run this command is important.
When you run the git merge command, you should be in the branch where you want the new commits.
For example, if you want to merge your new branch into the main branch, you must be in the main branch.

Do this
Merge a branch
Switch back to your main branch. Then, merge your newly created branch into main.

git merge bp--save-artist
You will see something like the output below:

Updating 199740a..1561e97
Fast-forward
 adventure.txt | 3 +++
 1 file changed, 3 insertions(+)
Check your adventure.txt file again. You will see the content that you added to the branch.

Use git log to check your history. You will see the commit that you added on the other branch, but that commit is now on the main branch.

**** Feature branch workflow and pull requests
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to create pull requests on GitHub.

Overview
In this lesson, you will get an overview of how to collaborate with other developers on GitHub using the feature branch workflow. You will then practice creating pull requests.

Key Terms
Feature branch workflow
A process for developers to build, review, and integrate new features
Pull request
A tool that allows for a visual comparison between two branches, which lets collaborators see what changes are being made and provides an interface for code review
Starter code
To get started, you will need a local repository with at least one commit. If you don't already have one from a previous lesson, you can follow the steps below:

Create a new folder called git-branch-practice.

Inside of that folder, create a new file called adventure.txt.

Initialize the directory as a Git repository.

Add the adventure.txt file and commit it.

Feature branch workflow
Git and GitHub are powerful tools for collaboration between developers. In general, developers have settled on the feature branch workflow as a way to collaborate on repositories. This workflow makes use of a main branch, feature branches, and pull requests.

The feature branch workflow gives developers a process to build, review, and integrate new features. To follow the feature branch workflow, developers create a feature branch, share that branch on a remote repository, and then merge it back into the main branch after review.

This process also makes use of another feature that GitHub provides: pull requests. Pull requests allow for a visual comparison between two branches, which lets collaborators see what changes are being made and provides an interface for code review.

In general, the feature branch workflow looks like this:

On the main branch, run git pull so that you have the most up-to-date version.

Create a new feature branch from the main branch.

Create new commits on your new branch.

Push your new branch up to GitHub.

Create a pull request and have it reviewed.

After making any requested changes, merge the pull request, bringing the new commits into the main branch.

Once the pull request is merged, you can repeat the above process for the next feature.

An example
Imagine that two developers, Bill P. and Ted L., are working on the same music application. They've just gotten started, and each is working on new features.

Bill is satisfied with his work, so he pushes his branch, bp--save-artist, up to a remote branch on GitHub and creates a pull request. The pull request allows Ted to review Bill's code. Together, they work to add another commit to the feature.

Once Ted finds the code acceptable, he merges Bill's work. That brings Bill's new commits into the main branch on the remote repository.

Do this
Create a remote repository
Complete the following steps to sync your local and remote repositories.

Create a new GitHub repository.

Add a new remote (using git remote add origin <url>).

Push your local main branch up to your remote repository (using git push -u origin main).

Remember that you can always check your remotes by using git remote -v.

Change your repository permissions
In this lesson, you'll be working on your own. But, if you were working with another developer, you might need to change the permissions on your repository to allow them to push to your repository.

To change the permissions, go to the Settings tab on the GitHub repository. You will end up on a screen with a menu like the one below:

A screenshot of the Settings menu in GitHub
Click Manage access, and you should see the following screen:

A screenshot of the GitHub access screen
Click the Invite a collaborator button, and you'll be prompted to enter a GitHub username. You don't need to enter one right now; just know that this dialog exists.

Entering a username would bring you to a new view that displays the user's username and shows that their invitation is pending. If the user doesn't see their invitation, you can always copy the link (by clicking the Copy 📋 icon shown below) and send the link to them directly.

The screen for inviting a collaborator
This will allow the user to push to your repository.

Create a feature branch
Create a new feature branch called <initials>--favorite-tracks. Then, create a new file called tracks.txt.

Add some of your favorite songs into the file:

"Father Time" by Shark Island
"Breakaway" by Big Pig
"Walk Away" by Bricklin
Add the changes and create a new commit on your feature branch.

Push up your feature branch
Although your main branch has been pushed to the remote repository, your feature branch has not. To push your feature branch up, follow the same convention as before:

git push origin <initials>--favorite-tracks
Back on your GitHub repository, you will see a notice pop up. The notice will look something like the image below:

A notification to push a branch up to GitHub
Pull requests
As previously mentioned, pull requests are a tool provided by GitHub to allow for comparison between two branches.

Do this
Create a pull request
Click the Compare & pull request button that appeared after you pushed up your feature branch. If you've refreshed the page or the notice has disappeared, you can click the Pull requests tab on your GitHub repository and then click New pull request.

At the top of the page, you'll see something like this image:

A screenshot of a GitHub pull request
As you can see, the branch bp--favorite-tracks is being compared to the main branch. If the pull request is successful, your feature branch will be merged into the main branch.

You can use the drop-down boxes to change which branches are being compared.

Below that, you'll see a section where you can add a title and a description to the pull request. You can also add labels and make different assignments, like who should review the pull request. If you're interested, feel free to play around with those options on your own.

An options page for a GitHub pull request
Finally, click the Create pull request button.

Reviewing code
Pull requests do more than maintain a record of the changes that you've made in your remote repository. They also allow for you to comment on code and merge your code.

Your view of a pull request will look something like the screen below:

A view of a pull request
As you can see, this view includes four tabs. Each of these sections can be useful in the review process, so explore them below:

The Conversation tab will show all comments made for this pull request. This can provide a useful overview of the entire pull request.

The Commits tab will highlight all of the new commits made, and it will display them in comparison to the main branch. This is one of the reasons why you should write descriptive commit messages. This tab is a valuable place where you can examine the process for creating the code.

The Checks tab is related to running automated builds and testing. This feature is powerful but is beyond the scope of this lesson.

The Files changed tab will show you the exact changes made to the file.

Under the Files changed tab, you can control how the changes are shown; to change the display, click the Settings ⚙️ icon and switch between Unified and Split.

A screenshot of the Files Changed tab on GitHub
You can also add comments to an individual line by holding your cursor over one of the lines and clicking the blue Comment ➕ icon that appears.

A screenshot of the Files changed tab with the Comment icon visible.
A text box will drop down, allowing you to add a single comment or start a review.

Do this
Make a comment on your code
Click one of the lines of your code under the Files changed tab. Then, add a comment and click the Add single comment button.

If you return to the Conversation tab, you will see your comment.

Merge your pull request
Once you're happy with your code, return to the Conversation tab and click Merge pull request. Afterward, you can click Delete branch to remove the branch from your remote repository.

Locally, return to your main branch and run git pull. Then, run git log to see your main branch's history and view your commit.

What is the additional commit?
You may have noticed an additional commit that you didn't explicitly create. This commit is created by GitHub when you click Merge pull request. Don't worry; no additional changes have been added. This commit simply marks that a pull request was merged.
**** Merge conflicts
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to solve merge conflicts both in your local Git repository and through the GitHub interface.

Overview
In this lesson, you will learn about problems known as merge conflicts, which occur when you and another developer make changes that affect the same code. You will learn how to resolve these conflicts and some best practices for avoiding them in GitHub.

Key Terms
Merge conflict
A problem that occurs when Git attempts to resolve changes to a specific line in a file, but that file has been changed in a different way through another commit
Starter code
To get started, you will need a local repository with at least one commit. Your repository should be synced and pushed up to a remote repository on GitHub. If you don't already have one from a previous lesson, you can follow the steps below:

Create a new folder called git-branch-practice.

Inside of that folder, create a new file called adventure.txt.

Initialize the directory as a Git repository.

Add the adventure.txt file and commit it.

Create a new GitHub repository and sync the two repositories.

What is a merge conflict?
Git and GitHub are very clever when it comes to managing changes to multiple files made by multiple different people. If you and another developer are working on different parts of the codebase, Git will typically solve your issues without any problems.

But, what happens if you and another developer make changes that affect the same code? The result will be a merge conflict, and that's a problem that will need to be solved by a human.

A merge conflict occurs when Git attempts to resolve changes to a specific line in a file, but that file has been changed in a different way through another commit. Essentially, Git isn't sure which change you want to keep, so it asks you to choose one. Git does this by editing the file that contains the conflict and adding a separator between the conflicting lines within the < and > angle brackets.

function playSong (lyrics) {
  for (let i = 0; i < lyrics.length; i++) {
    let casing;
<<<<<<< HEAD
    if (!!(i % 4)) {
      casing = lyrics[i].toUpperCase();
    } else {
      casing = lyrics[i].toLowerCase();
    }
=======
    let lyric = lyrics[i];
    casing = !!(i % 0) ? lyric.toUpperCase() : lyric.toLowerCase();
>>>>>>> bp--code-refactor
  }
}
In the above code, the two conflicting changes are between the < and > symbols and are separated by a line with multiple equals signs (=). In this case, Git requires you to decide whether you want to keep the code changes in lines 5-9 or the code changes in lines 11 and 12.

Merge conflicts occur during the middle of a merge process. As you merge the code, the merge process will stop and require you to choose one of the two versions (or combine them).

As you'll see below, there are two different ways of solving a merge conflict: remotely and locally. You'll learn how to do both in this lesson.

An example
Imagine that two developers, Bill P. and Tracy L., are working on the same music application. They've been working for some time, and the application is starting to come together.

In the morning, both developers sync their local repositories with the remote repository. Tracy has a bit of free time, so she makes what she considers a small change to one file, songs.js. Meanwhile, Bill is working across a number of files, making small code quality changes. In doing this work, Bill just so happens to edit the same line of code.

Tracy pushes up her work first and then goes for lunch. Bill continues working. He pushes up his feature branch and then notices that GitHub is prompting him to solve a conflict that has arisen.

Using the GitHub UI, Bill needs to decide which changes to keep to ensure that the file continues working. He resolves the conflict and uses the UI to merge his code successfully.

Solving conflicts through GitHub
GitHub provides a tool to solve merge conflicts on its website. If you choose to solve a problem on GitHub, remember that merging creates a new commit. If you want to return later and complete more work on that same branch, you will need to pull from that branch before you continue.

Do this
Create a conflict on GitHub
Typically, conflicts arise when working with other team members. But in this case, you will fabricate your own conflict.

In your repository, create a new branch with your initials and the branch name adventure-update. For example, here's what Bill P. would call the branch:

bp--adventure-update
Then, go to your remote GitHub repository. On GitHub, edit the first line of the adventure.txt file. You can make changes directly by clicking the filename and then clicking the Edit ✏️ icon in the top-right corner.

The edit icon on GitHub highlighted
Make a change to the first line, and then click Commit change.

Back in your local repository, on your new branch, make a different change to the first line of the same file. Add and commit your changes. Then, push up your feature branch to GitHub.

Next, return to GitHub and create a new pull request with your newly created feature branch. When you create the pull request, you'll see a message that says something like this:

Can't automatically merge. Don't worry, you can still create the pull request.
Finally, click Create pull request.

Solve a remote conflict
You now have a merge conflict, because the same line was edited in two different places. The main branch has a commit that shows one change (the one that you made from GitHub), while your branch includes a different change in the same place.

Importantly, your new feature branch does not have the same commit that the main branch does.

A screenshot of a conflict error on GitHub
GitHub will allow you to solve merge conflicts through its UI. Just click the Resolve conflicts button, and GitHub will display any conflicting files.

The GitHub interface when there is a conflict
As you can see above, the conflicts are highlighted for you. The content above the = symbols is what was added in the new branch (bp--adventure-update). And the content below the = symbols is what conflicts with the main branch.

To solve the merge conflict, correct the file in whatever way you like. But make sure to delete the lines that contain the <, >, and = symbols; these are the lines that GitHub added.

A screenshot of resolving a conflict on GitHub
In the above example, all of the changes were kept.

Click the Mark as resolved button and then the resulting Commit merge button. You will now see that your pull request can be merged.

Local conflicts
Remember that you can merge branches locally as well, using the git merge command. Most often, you will merge locally when you want to make sure that your feature branch is up to date.

For example, you might take a few days to work on a new feature on your new branch. Then, you would go to the main branch, use git pull to receive any new changes, and then return to your feature branch. On your feature branch, you would then run the following code to merge main into it, updating your code.

git merge main
During this process, you may end up with a merge conflict. If that happens, you'll need to manage the conflict locally.

Do this
Create a local conflict
Begin in your local repository. Switch back to your main branch and sync with the remote repository.

git checkout main
git pull origin main
Then, create a new branch called adventure-restart with your initials (you can see the branch below uses Bill's initials):

bp--adventure-restart
Switch back to main. Create a new commit where you change the first line of the adventure.txt file. You can change this line to whatever you want.

Tip
In general, you shouldn't be committing to the main branch. However, you can make an exception here in the interest of time.

Switch back to your adventure-restart branch. Create a new commit where you remove all of the contents of the adventure.txt file. Make sure not to delete the file, just remove the contents.

Once you've made your commit, run the following command on your adventure-restart branch:

git merge main
In your terminal window, you'll see something like the following:

Auto-merging adventure.txt
CONFLICT (content): Merge conflict in adventure.txt
Automatic merge failed; fix conflicts and then commit the result.
Solve a local conflict
You are now in the middle of a merge conflict. You can see that this is the case by running git status in your terminal. You'll see something like the following output:

On branch bp--adventure-restart
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   adventure.txt

no changes added to commit (use "git add" and/or "git commit -a")
Git provides some useful instructions above. Your next steps are as follows:

Fix conflicts.

Run git add and then git commit.

First, open up the adventure.txt file. You will see something like the following:

<<<<<<< HEAD
=======
Billy the Kid
Joan of Arc
Abraham Lincoln
>>>>>>> main
Here, you can see that the changes from your feature branch are above the = symbols. And the changes from the main branch are below the = symbols.

Go ahead and make whatever changes you like. Just make sure to remove the <, >, and = symbols.

Tip
If you are in VSCode, you'll notice that VSCode highlights the two sections and provides in-line links that will allow you to choose one section or the other. You can either use this feature or ignore it.

Whatever changes you make, run the following commands when you are done:

git add adventure.txt
git commit
Notice that you aren't including the -m flag in this commit.

When you run git commit, you'll be brought back into the vi editor. At the top, you'll notice a message similar to the one that you saw when you merged your pull request on GitHub.

An example of an error message on the terminal for a merge conflict
The hash symbols # in this message represent comments. You do not need to change this message at all. Instead, you can type :x and then press Enter. This will save and quit the editor.

Once you are done, you will see a message like this:

[bp--adventure-restart aec1828] Merge branch 'main' into bp--adventure-restart
If you run git log, you will see your commit from main, as well as the commit that describes the merge.

Avoiding conflicts
It is important to note that having a merge conflict is quite common. Particularly on large projects, it can be difficult to avoid modifying a file that someone else is working on. It is more important to be able to resolve merge conflicts than it is to avoid them completely.

With that said, there are some steps that you can take to reduce the number of merge conflicts that you have. Here are some best practices to keep in mind:

Communicate often with other developers working on the same codebase. If you are working on the same part of the codebase, consider working together on that feature or fix until it is complete.

Avoid making commits directly to the main branch or on GitHub. Stick with the feature branch workflow as much as possible.

Use code formatters like PrettierJS in your code. This will avoid small conflicts, like added line spacing or errant commas.
*** unsorted

1. Understand the problem - aka "reflect the question back into your our words."
    -  Do you understand all the words used in stating the problem?
    -  What are you asked to find or show?
    -  Can you restate the problem in your own words?
    -  Can you think of a picture or diagram that might help you understand the problem?
    -  Is there enough information to enable you to find a solution?

2. Devise a plan - aka "Pseudocode"
    * Guess and check           |   * Look for a pattern
    * Make an orderly list      |   * Draw a picture
    * Eliminate possibilities   |   * Solve a simpler problem
    * Use symmetry              |   * Use a model
    * Consider special cases    |   * Work backwards
    * Use direct reasoning      |   * Use a formula
    * Solve an equation         |   * Be ingenious

3. Carry out the plan - aka "code your Pseudocode"
    * Third. Carry out your plan.
    * Carrying out your plan of the solution, check each step. Can you see clearly that the step is correct? Can you prove that it is correct?

4. Look back - aka "refactor"
    * Fourth. Examine the solution obtained.
    * Can you check the result? Can you check the argument?
    * Can you derive the solution differently? Can you see it at a glance?
    * Can you use the result, or the method, for some other problem?

Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly
