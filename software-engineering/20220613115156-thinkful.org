:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]

these are my notes on the thinkful program
this is a staging area for my notes need to summarize and move to a better place

[[id:63bc8d8d-4fc8-4b34-8881-43ace1415a53][JavaScript]]
[[id:6df2c337-4b01-470f-9028-d0745498f8a6][devWorkflow]]
[[id:dea16eb4-d34a-421b-b037-9f3e606ec001][git]]
[[id:43e93100-42e8-432e-99bb-ecdd6f6b7097][devCollab]]
[[id:a3333ce5-86aa-4729-af16-cd8dafd42149][Node.js]]
[[id:c1cbc82c-ad99-4ae6-80a8-a9d83d2e71b8][careerNetworking]]

** Testing Basics
*** Test-driven development
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to use the test-driven development philosophy to determine good tests for a program before you write code.

Overview
How do you know if your code is working as it should? And when you're updating code, how do you know whether your new code will work or if it will break something? Programmers use tests to verify that code is working correctly before they merge to production. Particularly in larger companies, some developers follow a process called test-driven development (TDD). In this lesson, you will learn what TDD is and how to apply it to your coding process.

Key Terms
Happy path
The default scenario for using a function, with no edge cases or error conditions
Tip
Many of the assessments in this program are autograded using tests, so understanding the basics of testing will also help you throughout this program.

Test-driven development
Often, developers who prioritize building functional and robust code prioritize the test-driven development process when writing their tests.

Key Term
Test-driven development: TDD, a process of first determining what you want your code to do and writing tests that your code will need to pass, and then writing the code

Key Term
Test: Code that checks whether or not some other code works as intended

Test-driven development benefits you, the developer, in the following ways:

It helps you fully understand the requirements for your function, because you have to express them by writing test code. This also helps other people understand your code.

It helps you relax when code doesn't work. This attitude will help you think more clearly when debugging.

It helps you fearlessly refactor and improve your code when you need to, because the tests will let you know if you break anything.

It helps you frequently experience the joy of working code, because getting a test to pass feels great! These repeated moments of triumph will make developing code more enjoyable.

TDD often takes place at the level of individual functions. To begin applying TDD to a function, follow the process detailed below:

Determine inputs, outputs, and the function name. Put another way, what does the function do?

Determine the happy path. The term happy path refers to the common scenario for using a function. So determining the happy path means ignoring any exceptions or odd cases (such as a missing parameter).

Write the smallest test possible. For example, you may write a test that just checks whether or not the function exists.

Write code to make the test pass. If you are testing for whether or not the function exists, you may just write the function.

Repeat steps three and four, updating the test to check for the next step on the road to the happy path. For example, the next test that you write may be that it returns a value.

Consider alternative cases and exceptions. For example, what should happen if a parameter is missing?

Repeat steps three and four with alternative cases. Essentially, you should build out the function to accommodate all kinds of possible options.

TDD walk-through
Imagine that you wish to build a function that takes in a number of scores that students received on an exam, and returns the student who received the highest score. Now, use this example to explore the TDD process step by step.

Step 1: Determine inputs, outputs, and the function name
For the input, you may decide that an array like the following makes the most sense.

[
  { name: "Shane Carey", score: 9.5 },
  { name: "Rebecca Mills", score: 8.7 },
];
The output should be a single object that represents the student with the highest score, as follows:

{ name: "Shane Carey", score: 9.5 }
Finally, you should decide on a descriptive name. In this example, highestScore() seems like a good name.

Step 2: Determine the happy path
Determining the happy path really just involves clearly stating your function's purpose.

For example, in this case, you may describe the happy path as follows: "When given an array of objects that each have a name and score key, the highestScore() function should return one of those objects that has the highest score value."

Notice that you are assuming that the input is an array of multiple items and that the object is of the correct shape. For now, that's okay!

Step 3: Write the smallest test possible
For a true TDD process, you would write a very small test that may not solve the entire problem but puts you on the right path. For example, the first test might look like this:

if (typeof highestScore === "function") {
  console.log("Test passed.");
} else {
  console.log("highestScore() is not a function.");
}
In this example, if the highestScore() function is defined, then typeof highestScore === "function" will evaluate to true. Then "Test passed." would be logged to the console.

However, if you run the above code without having defined the function, you will receive the second "highestScore() is not a function." statement.

Step 4: Write code to make your test pass
If you wanted to pass the above test, you would only need to update your file to include the following:

function highestScore() {}

if (typeof highestScore === "function") {
  console.log("Test passed.");
} else {
  console.log("highestScore() is not a function.");
}
Note that this doesn't solve the overall problem, but it does pass this test.

Step 5: Repeat the steps until you have a solid test
If you wanted to continue the TDD process, you might update your test and code to solve the following tests:

Check that the function returns an object.

Check that the function returns an object from the inputted array.

Check that the function returns the object with the highest score.

Your final function and test might look like this:

// Function being tested
function highestScore(students) {
  let result = null;
  let highScore = 0;

  for (let i = 0; i < students.length; i++) {
    let student = students[i];
    if (student.score > highScore) {
      highScore = student.score;
      result = student;
    }
  }

  return result;
}

// Setup phase
const input = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Rebecca Mills", score: 8.7 },
];
const expected = input[0];

// Run phase
const actual = highestScore(input);

// Check phase
if (expected.name === actual.name && expected.score === actual.score) {
  console.log("Test passed.");
} else {
  console.log(
    "highestScore() did not return the student with the highest score."
  );
}
Notice that this test has three phases:

Setup: Where you prepare both the input data and the expected output data

Run: Where you feed the input data to the function and collect the actual results

Check: Where you compare the actual results to your expected results

All tests have these three phases.

Step 6: Consider alternative cases
What else could happen when your function is getting used? For the highestScore() function, these are some of the additional cases that you might need to test:

The list of students is undefined.

The list of students is empty.

There is only one person in the list.

There are two students tied for the highest score.

The uncommon and often tricky cases are called edge cases.

Key Term
Edge case: A problem that arises in code because of something unexpected

Edge cases can include any number of scenarios that don't cover the happy path. It is easy to forget about edge cases when you are implementing your code, so it is important to cover them in the tests.

Step 7: Write tests to cover edge cases
To cover the edge cases, you would write tests for each edge case and follow the same process as you did before. By the end of your process, you may end up with the function below. This function will return null if the list of students is empty or undefined. If two students have the same score, it will return the first student.

function highestScore(students) {
  let result = null;
  if (!students || !students.length) {
    return result;
  }

  let highScore = 0;
  for (let i = 0; i < students.length; i++) {
    let student = students[i];
    if (student.score > highScore) {
      highScore = student.score;
      result = student;
    }
  }

  return result;
}
Notice that there isn't actually much that changed within the function. This can sometimes be the case when testing edge cases.

Regardless, it's important to have tests; that way, if the function changes later, you can feel confident that you are still testing for possible edge cases.

*** Unit testing with Mocha and Chai
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to write a series of unit tests using Mocha and Chai.

Overview
In the previous lesson, you wrote tests using if/else statements. But writing and running tests is much easier if you use a testing framework and assertion library instead. In this lesson, you'll learn how to do just that.

Key Terms
Unit test
A test that checks a small piece of code, generally a single function
Testing framework
A program that automatically runs the tests so that you can easily run a complete set of tests whenever you update your code
Assertion library
A tool that will help check for equality between the actual and expected outputs from a function
The video below provides an brief introduction to unit testing with Mocha and Chai. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.


Unit tests
The tests that you will be writing are called unit tests. A unit test tests a small piece of code, generally a single function.

If you have a large program, you should have unit tests for each function in your program. If you have thorough unit tests, the unit tests will point you to any functions that aren't working as expected. This makes it easy to track down where issues are.

Testing framework
In the previous lesson, you saw that you could manually call the highestScore() function and test it with if/else statements, like so:

const input = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Rebecca Mills", score: 8.7 },
];
const expected = input[0];
const actual = highestScore(input);
if (expected.name === actual.name && expected.score === actual.score) {
  console.log("Test passed.");
} else {
  console.log(
    "highestScore() did not return the student with the highest score."
  );
}
Although this approach works, running multiple tests requires multiple console.log() statements. This can make the test code confusing to read and the output difficult to interpret. So instead, you can use a testing framework.

Key Term
Testing framework: A program that automatically runs the tests so that you can easily run a complete set of tests whenever you update your code

Mocha
There are several testing frameworks for JavaScript. In this program, you will be using Mocha. Mocha tells you how to format your tests so that it can automatically run them. With Mocha, like with most testing frameworks, you will be writing a function for every test.

Assertion library
You will also be using an assertion library to help with testing. An assertion library is a tool that will help check for equality between the actual and expected outputs from a function. Assertion libraries are particularly useful for comparing more complex data structures, like arrays and objects.

Chai
In this program, the assertion library that you'll use is called Chai.

Do this
Function setup
You will be creating a new function called averageScore(). This function will take an array of students with names and scores and return a number that represents the average score among all students. The following code shows the happy path for the function.

const input = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Rebecca Mills", score: 8.7 },
  { name: "Catarina Lima", score: 9.7 },
];
averageScore(input); //> 9.3
Project setup
Create a directory for this project and name it something like testing-with-mocha-chai. Then navigate to the new directory in the command line.

Run npm init -y to create a package.json file with default values.

Then install Mocha and Chai, as follows:

npm install --save-dev mocha chai
It's typical to include testing frameworks as a developer dependency, because testing is a process that you run in development rather than in production.

Now, create a folder called src/ and create a file called main.js inside of it. You will be implementing the averageScore() function in this file.

As shown below, start with an empty function stub and export the function.

function averageScore(students) {
  // TODO
}

module.exports = averageScore;
Test files
Generally, you will have a test file for every file in your project. Because you have the code file main.js, you will need a corresponding test file called main.test.js.

Test files should have the suffix .test.js, because Mocha will be checking file names for that suffix when looking for test files to execute. It's conventional to give test files the same name as the file that they are testing, for easy reference.

There are a few places where you can store test files. One option is to put them all inside of a single folder.

Do this
Create a test file
Create the file main.test.js in a new folder called test.

You will need to import the averageScore() function in order to test it, so start with this line:

const averageScore = require("../src/main");
At the end of this step, your project structure should look like the following:

.
├── node_modules
├── package-lock.json
├── package.json
├── src
│   └── main.js
└── test
    └── main.test.js
Update package.json
You need to tell Node which testing framework you are using and the command to run it. Update the package.json file to include the following script:

{
  "scripts": {
    "test": "mocha test"
  }
}
In the test script above, test references a folder named test.

Run npm test
The npm test command runs all of your tests. If you run it now, you will see the following:

0 passing (1ms)
The output shows you how many tests have passed or failed, and how long it took. This test output shows that zero tests are passing. This makes sense; you haven't written any tests yet.

Writing a test
For each test, you will call two special functions: describe() and it().

The describe() function
The describe() function allows you to describe what you are testing. This function takes in two arguments:

A string message explaining what is being tested, which is often the name of the function or topic

A callback function that contains a set of individual tests for the function or topic

Here's an example:

describe("averageScore", () => {
  // More will go here
});
Think of describe() as a way to group a set of related tests together. You can optionally nest multiple describe() statements inside of each other, if it makes sense to create further subgroups for individual tests with a describe() block.

The it() function
Inside of the describe() callback function, use the it() function to define the steps for testing your function. The it() function takes in two arguments:

A string message explaining a desired behavior of the function. Typically, these statements use the it() function name as part of a sentence.

A callback function that defines the steps for testing the desired behavior of your function.

Here's an example:

describe("averageScore", () => {
  it("should return the average score among all students", () => {
    // More will go here
  });
});
The above example is a typical test case. It reads like a sentence and describes the happy path.

Do this
Run your tests
Copy the above JavaScript into your main.test.js file. Then, run your tests using the npm test command. You will see something like the following:

averageScore
  ✓ should return the average score among all students

1 passing (3ms)
Notice that it says that the tests are passing, but you still haven't actually written any tests.

Mocha will run all of the tests. They are considered passing as long as they do not cause an error. Any tests that do cause an error will be considered to be failing.

The expect() function
In the it() function, use the expect() function to tell the test to throw an error if the result is not as expected.

First, in your main.test.js file, you must require the expect() function from the Chai package:

const expect = require("chai").expect;
Then, you will be able to use the expect() function inside of the it() function.

To compare if two values are the same, use the chained method to.equal() with expect(). For example, the following code checks whether 1+1 is equal to 2, and throws an error if those values aren't equal.

expect(1 + 1).to.equal(2); // No error
The following code doesn't get the expected result, so it will throw an error.

expect(1 + 1).to.equal(1); // Error
The entire passing test suite for the simple example above might look like this:

const expect = require("chai").expect;

describe("Checking equality", () => {
  it("should return true if the equation is correct", () => {
    expect(1 + 1).to.equal(2); // No error
  });
});
Do this
Add a new test
First, include the following line at the top of your main.test.js file.

const expect = require("chai").expect;
Then, add the following inside of your it() function in the main.test.js file.

const input = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Rebecca Mills", score: 8.7 },
  { name: "Catarina Lima", score: 9.7 },
];
const expected = 9.3;
const actual = averageScore(input);
expect(actual).to.equal(expected);
Finally, run npm test. You will see something like the following:

averageScore
  1) should return the average score among all students


0 passing (6ms)
1 failing

1) averageScore
      should return the average score among all students:
    AssertionError: expected undefined to equal 9.3
    at Context.<anonymous> (test/main.test.js:13:23)
    at processImmediate (internal/timers.js:456:21)
In the above output, you can see that one test is failing. It also describes why the test is failing:

AssertionError: expected undefined to equal 9.3
The undefined value is what is stored inside the actual variable in your test. This variable is undefined because the actual function hasn't been implemented!

Make the test pass
To make the test pass, you will have to implement the function in main.js:

function averageScore(students) {
  let totalScore = 0;
  for (let i = 0; i < students.length; i++) {
    totalScore += students[i].score;
  }
  return Number((totalScore / students.length).toFixed(1));
}
Then, run npm test. You will see something like the following:

averageScore
  ✓ should return the average score among all students


1 passing (5ms)
Complete example
A completed example from this lesson can be found here:

Testing basics: Unit testing with Mocha and Chai

*** More with Chai
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to use different expect() methods to test your code.

Overview
The assertion library Chai includes many more ways to test your code besides to.equal(). In this lesson, you will learn different methods that you can call to more easily test your code.

Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


Code starters
Download the following code to your machine, and follow the instructions to get everything running as expected.

Testing: More with Chai (Starter)
When you run npm test, you should have a single test failing.

Using the documentation
As you can see from Chai's documentation, there are many different methods that you can use for testing. In general, you should consider having the documentation open while you are learning to build your own tests.

In this lesson, you will learn some of the more common methods—but don't let your learning stop there!

The to.be.a() method
One method that you can use in tests is the to.be.a() method. This method allows you to check for the expected result's data type.

expect("Score").to.be.a("string");
expect(10).to.be.a("number");
This method is particularly useful if you are following a strict TDD process. Early on, you may just check whether or not a returned value is of a certain type, before later testing whether or not it is the right value.

There is also a to.be.an() method, which works exactly the same way.

expect({}).to.be.an("object");
Do this
Remove extraneous checks
Although the to.be.a() method can be very useful when first writing a function, it becomes extraneous as you add more specific tests. For example, take a look at the following code from the project that you downloaded at the beginning of this lesson.

const actual = medianScore(students);
const expected = 8.4;
expect(actual).to.be.a("number");
expect(actual).to.equal(expected);
In this case, the to.equal() check is more specific and covers the check for to.be.a("number").

Take a moment to remove the to.be.a() statements in your test file.

The to.equal() method versus the to.eql() method
Take a look at the following code. What do you expect the output to be?

[] === [];
The above code will result to false. Despite the fact that the two arrays look the same, each of the arrays is unique and has its own reserved memory.

Often, while testing, you'll want to check whether or not one object or array matches another. For example, from the project that you downloaded earlier, this test is currently failing:

const actual = topScoringStudent(students);
const expected = { name: "Riley Morgan", score: 9.8 };
expect(actual).to.equal(expected);
When you look at the test failure, shown below, you may be even more confused.

AssertionError: expected { name: 'Riley Morgan', score: 9.8 } to equal { name: 'Riley Morgan', score: 9.8 }
Although these objects look the same, they are different objects in memory. Instead, you can use to.eql() to check for deep equality. That is, this method will check the contents of arrays and objects to see if they are the same.

expect(actual).to.eql(expected);
Do this
Update your tests
Update the second test to use eql() instead of equal(). When you run the test again, all of the tests should pass.

More expect() methods
There are dozens of other methods and properties that you could use for testing. Here are some of the most common:

empty
include()
lengthOf()
true
Note that it is generally preferred to use the specific methods (like to.have.lengthOf()) when possible, because it makes the code and error messages easier to understand.

Complete example
A completed example from this lesson can be found here:

Testing: More with Chai

*** Unit testing with Jest
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to write a series of unit tests using Jest.

Overview
In previous lessons, you saw how using a testing framework like Mocha and an assertion library like Chai can make writing tests easier. Keep in mind that a testing framework is a program that automatically runs the tests so that you can easily run a complete set of tests whenever you update your code, whereas an assertion library is a tool that will help check for equality between the actual and expected outputs from a function. In this lesson, you will learn about another popular testing tool: Jest.

Jest
Jest is a JavaScript testing framework developed by Facebook. It includes both an assertion library and a test runner. Jest is used extensively throughout the curriculum and is one of the most popular testing frameworks nowadays, so it's important to be familiar with it. Luckily, its syntax is quite similar to Mocha and Chai.

Do this
Set up the project
Create a directory for this project and name it something like testing-with-jest. Then navigate to the new directory in the command line.

Run npm init -y to create a package.json file with default values.

Then install Jest as a development dependency, as follows:

npm install --save-dev jest
Now, create a folder called src/ and create a file called main.js inside of it. You will be implementing a function called findHighestScoringStudent() inside this file.

Start with an empty function stub and export the function, as follows:

function findHighestScoringStudent(students) {
  // TODO
}

module.exports = findHighestScoringStudent;
Function setup
You will be creating a new function called findHighestScoringStudent(). This function will take an array of students with names and scores and return the student with the highest score. If there are multiple students with the same highest score, you can return any one of them. The following code shows the happy path for the function.

const mathStudents = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Catarina Lima", score: 9.7 },
  { name: "Rebecca Mills", score: 8.7 },
];
findHighestScoringStudent(students); //> { name: "Catarina Lima", score: 9.7 }
Test files
Setting up test files in Jest is similar to setting up test files for Mocha. Test files should have the suffix .test.js, because Jest will be checking file names for that suffix when looking for test files to execute.

Do this
Create a test file
In a new folder called tests/, create the file main.test.js and import the findHighestScoringStudent() function in this file so that you can test it:

const findHighestScoringStudent = require("../src/main");
At the end of this step, your project structure should look like this:

.
├── node_modules
├── package-lock.json
├── package.json
├── src
│   └── main.js
└── tests
    └── main.test.js
Update package.json
Add the following test script to your package.json:

{
  "scripts": {
    "test": "jest"
  }
}
Run npm test
If you run the npm test command now, the test output would show that the test suite has failed to run, because you haven't written any tests.

 FAIL  tests/main.test.js
  ● Test suite failed to run

    Your test suite must contain at least one test.
Writing a test
Similar to writing a test with Mocha and Chai, you will call the describe() and it() functions for each test. Keep in mind the describe() function allows you to group a set of related tests together. The it() function, which is typically nested inside of the describe() function, describes the steps for testing your function.

Here's an example:

describe("findHighestScoringStudent", () => {
  it("should return the student with the highest score", () => {
    // Steps for testing the function
  });
});
Tip
Sometimes, instead of the it() function, you may encounter the test() function instead. Both it() and test() are exactly the same; the it() function is an alias of test().

The following setup, using the test() function, is also valid:

describe("findHighestScoringStudent", () => {
  test("should return the student with the highest score", () => {
    // Steps for testing the function
  });
});
Do this
Run your tests
Copy the above JavaScript into your main.test.js file. Then, run your tests using the npm test command. You will see something like the following:

findHighestScoringStudent
  ✓ should return the student with the highest score
1 passing (1ms)
Notice that the tests are passing even though you haven't actually written any tests. Similar to Mocha, Jest considers tests to be passing as long as they don't throw an error. Any tests that do cause an error will be considered to be failing.

The expect() function and Jest matchers
Next, you will use the expect() function to tell the test to throw an error if the result isn't as expected.

Keep in mind that Jest already includes an assertion library, so there's no need to install a separate assertion library. Jest's assertion library exposes an expect() function that you can use to assert values in your tests.

To perform an assertion, you will call matchers on the output of the expect() function. Previously, to check whether 1 + 1 is equal to 2 using the Chai library, you used the to.equal() matcher, as follows:

expect(1 + 1).to.equal(2);
To perform the same check with Jest, you will have to use the toBe() matcher. toBe() checks for exact equality, as follows:

expect(1 + 1).toBe(2);
To compare objects, use toEqual() instead, which recursively checks every property of an object. For example, the test below checks whether or not two given person objects have the same properties and values:

test("two persons have the same name", () => {
  const personOne = { name: "Jane" };
  const personTwo = { name: "Jane" };
  expect(personOne).toEqual(personTwo);
});
Besides toBe() and toEqual(), there are dozens of other Jest methods and properties that you could use for testing.

Refer to the documentation to learn about some of the most common matchers for comparing truthiness, numbers, strings, arrays, and more in a test.

Do this
Add a new test
In your tests/main.test.js file, add the following code inside of your it() function:

const mathStudents = [
  { name: "Shane Carey", score: 9.5 },
  { name: "Catarina Lima", score: 9.7 },
  { name: "Rebecca Mills", score: 8.7 },
];

const expected = { name: "Catarina Lima", score: 9.7 };
const actual = findHighestScoringStudent(mathStudents);

expect(actual).toEqual(expected);
Now, run npm test. You will see a failing test:

  findHighestScoringStudent
    ✕ should return the student with the highest score (4 ms)

  ● findHighestScoringStudent › should return the student with the highest score

    expect(received).toEqual(expected) // Deep equality

    Expected: {"name": "Catarina Lima", "score": 9.7}
    Received: undefined
Make the test pass
To make the test pass, you will have to implement the function in main.js:

function findHighestScoringStudent(students) {
  let student = students[0];
  for (let i = 1; i < students.length; i++) {
    if (students[i].score > student.score) {
      student = students[i];
    }
  }
  return student;
}
Then, run npm test. You will see the test is now passing:

findHighestScoringStudent
  ✓ should return the student with the highest score
1 passing (1ms)
Now you know how to write unit tests with Jest. As you can see, the process for setting up tests with Jest is largely similar to Mocha and Chai, but Jest includes a built-in assertion library and offers a slightly different and cleaner matcher syntax.

Complete example
A completed example from this lesson can be found here:

Testing basics: Unit testing with Jest

*** Coverage
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to use code coverage tools to identify opportunities for new tests.

Overview
How do you know if you've tested your code adequately? Although experience will help, you can also make use of code coverage tools, which will let you know which parts of your code are covered by tests. Although code coverage tools aren't perfect, they can lead you in the right direction when it comes to testing.

Code starters
In this lesson, you'll continue working with the project that you downloaded in the previous lesson. If you need to, you can download the code below. Follow the installation instructions to get everything up and running.

Testing: More with Chai
How it works
Take a look at the following function. How many possible outcomes are there?

function assignGrade(score) {
  let result = "F";

  if (score > 0.9) {
    result = "A";
  } else if (score > 0.8) {
    result = "B";
  } else if (score > 0.7) {
    result = "C";
  }

  return result;
}
For the above function, the following return values are possible:

A

B

C

F

When building tests for this function, you want to cover as many cases as possible, increasing your code coverage. Code coverage tools work by looking at individual lines, functions, and paths that code can take, and comparing those to what you test. The more that you've tested, the higher score you receive on your code coverage test.

Installing code coverage tools
The nyc package makes it easy to integrate code coverage tools into your workflow. After installing the package as a developer dependency, you can update your test script with the following:

{
  "scripts": {
    "test": "nyc --reporter=text mocha test"
  }
}
Now when you run your tests, you'll see something like this at the bottom of your output:

----------|---------|----------|---------|---------|-------------------
File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
----------|---------|----------|---------|---------|-------------------
All files |     100 |      100 |     100 |     100 |
 main.js  |     100 |      100 |     100 |     100 |
----------|---------|----------|---------|---------|-------------------
The above output shows two lines: one for all files and another for a specific file, main.js. Each column describes a different topic that is being assessed by the tool.

Stmts refers to whether or not each individual statement of code (such as let result = 10;) was executed by tests.

Branch refers to whether or not each branch (for example, if/else) was executed by tests.

Funcs refers to whether or not each function was executed by tests.

Lines literally refers to whether or not each line of code was executed by tests.

Do this
Install nyc
Install the nyc package as a developer dependency, as follows:

$ npm install --save-dev nyc
Then, update your script as described above.

Run npm test and take a look at the test coverage for your current project. Notice that you also have a .nyc_output folder now.

Respond to coverage
As you're building functions and tests, coverage tools can guide you in the right direction when you're trying to decide what (if anything) to test next.

Do this
Create a lack of coverage
Add the following line of JavaScript to the top of both functions in the main.js file of the current project.

if (!students.length) return null;
Then, try running npm test. Notice which values have changed and which values have stayed the same.

Get to full coverage
Write two new tests for each of the functions, increasing your coverage to 100%.

Prioritize branches
Although code coverage tools are useful, it is definitely possible to spend too much time working on reaching 100%. Instead, it's worthwhile to focus specifically on increasing coverage of the Branch statements, because this is often the code that can break or cause unintended effects.

Complete example
A completed example from this lesson can be found here:

** Error handling basics
*** Understanding errors
1 hourAverage Reading Time
Learning Objective
By the end of this lesson, you will learn how to identify and interpret a variety of errors.

Overview
Earlier in this program, you learned about syntax, reference, and type errors. As you may have seen by now, these aren't the only types of errors that you will encounter when building a Node.js application. Other types of errors include user errors, system errors, and assertion errors. In this lesson, you will focus on identifying and interpreting errors for faster debugging.

Understanding errors
Knowing how to properly identify and understand errors is an essential skill that every developer must possess. You already covered some standard JavaScript errors in the Error types lesson in the JavaScript foundations module, but now you'll take a deeper look at error messages. In this lesson, you'll go back to basics with error messages so that you can better understand how to work with them.

Suppose you have a notfound.js file with the following code:

// Import file
const doesNotExist = require('./does-not-exist');
Running the code above will throw an error similar to this one:

internal/modules/cjs/loader.js:883
  throw err;
  ^

Error: Cannot find module './does-not-exist'
Require stack:
- /home/user/Dev/Thinkful-Ed/tmp/notfound.js
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15)
    at Function.Module._load (internal/modules/cjs/loader.js:725:27)
    at Module.require (internal/modules/cjs/loader.js:952:19)
    at require (internal/modules/cjs/helpers.js:88:18)
    at Object.<anonymous> (/home/gabriel/Dev/Thinkful-Ed/tmp/errors.js:1:22)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12) {
  code: 'MODULE_NOT_FOUND',
  requireStack: [ '/home/user/Dev/Thinkful-Ed/tmp/notfound.js' ]
}
What does this error say to you? The error message is very explicit in this case. It says Error: Cannot find module './does-not-exist'. A MODULE_NOT_FOUND error code is also printed in the error message. Error codes are useful when you aren't sure about the error presented. Node's documentation sometimes provides more details of the error in hand:

"MODULE_NOT_FOUND: A module file could not be resolved while attempting a require() or import operation."

Tip
When you don't understand an error message, search for the error code in Node's Errors documentation. If that still doesn't help, sites like Stack Overflow may give more information on the error code.

Do this
Create a new file and run the following code:

const fs = require('fs');
fs.writeFile("/temp/test", "Hello!");
Then consult Node's Errors documentation to learn more about this error. What does the documentation say about this error?

System errors
A system error occurs when an application breaks a constraint set by the operating system. An example of this could be opening a file that doesn't exist or the application not having the proper system permissions.

Suppose you want to read a text file called idontexist.txt:

// Import JavaScript's fs library (used to read and write text files)
const fs = require('fs')
// Attempt to read the idontexist.txt file
const content = fs.readFileSync("idontexist.txt")
If you run the code above, you will get an error like this one:

internal/fs/utils.js:308
    throw err;
    ^

Error: ENOENT: no such file or directory, open 'idontexist.txt'
    at Object.openSync (fs.js:476:3)
    at Object.readFileSync (fs.js:377:35)
    at Object.<anonymous> (/home/user/Dev/Thinkful-Ed/tmp/errors2.js:2:20)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
    at internal/main/run_main_module.js:17:47 {
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'idontexist.txt'
}
Notice how this error has a few properties that the previous error didn't have. System errors may include properties such as syscall, path, and errorno. Also, did you notice which properties are present in both this error and the previous one? The essential properties that all errors need to have are the error code and the error message.

What is ENOENT anyway? ENOENT stands for Error No Entity. Some of these codes come from the operating system, so they may not be as explicit as other error types. If you have a hard time understanding the error, you can always search for the error code in Node's documentation:

"ENOENT (No such file or directory): Commonly raised by fs operations to indicate that a component of the specified pathname does not exist. No entity (file or directory) could be found by the given path."

Tip
Node's documentation provides a list of common system errors. Review the list and try to remember if you have encountered any of those errors.

Do this
Create a new file and run the following code:

const fs = require('fs');
fs.mkdirSync('temp_dir');
What does Node's Errors documentation say about this error?

Assertion errors
Assertion errors indicate a failure of an assertion. These types of errors are more commonly used in testing. There are several assertion libraries, such as Chai, that use these types of errors or similar ones.

The code below uses the assert module to assert that 1 === 2.

const assert = require('assert');
assert.strictEqual(1, 2);
Obviously, this will throw the following error:

assert.js:104
  throw new AssertionError(obj);
  ^

AssertionError [ERR_ASSERTION]: Expected values to be strictly equal:

1 !== 2

    at Object.<anonymous> (/home/user/Dev/Thinkful-Ed/tmp/errors2.js:2:8)
    at Module._compile (internal/modules/cjs/loader.js:1063:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)
    at Module.load (internal/modules/cjs/loader.js:928:32)
    at Function.Module._load (internal/modules/cjs/loader.js:769:14)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
    at internal/main/run_main_module.js:17:47 {
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: 1,
  expected: 2,
  operator: 'strictEqual'
}
Now, do a quick search for ERR_ASSERTION in Node's documentation:

"A special type of error that can be triggered whenever Node.js detects an exceptional logic violation that should never occur. These are raised typically by the assert module."

Notice how an AssertionError has different properties than other errors. Assertion errors can have actual, expected, and operator properties. The error message and the properties clearly indicate how the actual value differs from the expected value when using the strictEqual operator.

Note: In Testing basics, you reviewed some of the most commonly used assertion methods in testing. Now, check out Chai's documentation to get a broader perspective of the different operators that you may encounter in tests. Becoming familiar with the assert API and the BDD API will help you better understand any assertion errors that you may encounter.

*** Writing errors
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to create custom error messages.

Overview
Errors are a way of life when it comes to programming. However, errors can also be a powerful way to improve your functions and ensure that they are used correctly. In this lesson, you'll learn how to create errors to signal to yourself and other developers when something wrong is happening.

Creating errors
You encountered a few different error types and descriptions in the first part of the program. Review them briefly:

ReferenceError: [name] is not defined

TypeError: cannot read property '[name]' of undefined

TypeError: [name] is not a function

SyntaxError: Unexpected token

These kinds of error messages can be more informative than a console.log() statement or a silently failing problem. So next, you're going to learn how to use the throw keyword to create your own errors like this.

The throw keyword
You can make code generate an error by using the throw keyword. Here's an example:

let secret = 42;
let guess = 55;

if (guess !== secret) {
  throw new Error("That's not the secret number!");
}
When JavaScript sees throw, it stops running the code (similar to return) and "unwinds" the code. Then it then prints out the error.

Backtraces
To make it easier for developers to understand what's going on, JavaScript also prints out a backtrace. Each line walks backward through the functions that were called before the error, like this:

function one() {
  two();
}
function two() {
  three();
}
function three() {
  throw new Error("Here's the error");
}
one();
Then, the error will be as follows:

Error: Here's the error
    at three (test.js:8:9)
    at two (test.js:5:3)
    at one (test.js:2:3)
First, you see the error message itself. Next, each line tells you the name of the function and which line of the program this error came from.

Error values
The new Error() syntax is a special syntax for creating objects. This syntax will not be covered in this lesson. However, you can throw anything, not just new Error('message'). Here are some examples:

throw "here's what went wrong";
throw 10;
throw { message: "This a string in an object" };
throw ["two", "message strings"];
When to create errors
Now you know how to create errors. But when should you create them?

It is most useful to throw errors when a function is being used incorrectly. For example, if an essential parameter is missing, you may consider throwing an error. Here's an example:

function checkSecretPassword(password) {
  if (!password) throw "No password given!";
  return password === "SECRET";
}
In the above function, if the password parameter is undefined, an error will be thrown. This will stop other members of your team (or your future self) from making the mistake of not including a password.

*** Try and catch
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to handle errors by using try and catch statements.

Overview
Sometimes, you'll want your code to continue running despite an error. This can be useful in cases where you know that it's possible that your code may fail. In this lesson, you'll learn how to handle errors so that your code keeps running. However, this doesn't mean that you should use these methods on all of your code! Error-free code is still the best kind of code.

The try and catch statements
You can use try...catch statements to stop errors before they stop your whole program. To do so, wrap the code that you want to handle in a try block, and then catch any errors that happen inside the try block. The syntax looks like this:

try {
  throw new Error("Something went wrong");
} catch (error) {
  console.log(`We handled the error: ${error}`);
}
Usually, this approach is used to recover from possible errors—not ones that are guaranteed.

For example, take a look at the function below. Here, an error is thrown if the number is too small. Otherwise, the number is printed without an error message. Either way, the function will continue to run and will not stop the execution of the program.

function getRandomNumber() {
  // Math.floor(Math.random() * 100) generates a random number
  const randomNumber = Math.floor(Math.random() * 100);
  const min = 10;
  try {
    if (randomNumber < min) {
      throw `Random number is too small! ${randomNumber} is less than ${min}.`;
    } else {
      console.log(`The random number is: ${randomNumber}`);
    }
  } catch (error) {
    console.log(`An error occurred: ${error}`);
  }
}
Also, notice that the catch statement includes access to the error that was thrown. That error is exactly what was thrown.

For example, in the code below, note how error is being operated on as an array, because that is what was thrown.

try {
  throw ["one", "two", "three"];
} catch (error) {
  const errors = error.join(", ");
  console.log(`Multiple errors: ${errors}`);
}

** Promises
*** Sync and async code
**** Terminology
Synchronous code (also called sync code) :: executes one code instruction at a time, in the order that the instructions are given.
Asynchronous code (also called async code) :: executes multiple instructions simultaneously, and the order in which the instructions complete isn't known.


It's a lot easier to understand the difference between these two types of code with an example.
So take a look at the code snippet below:

function useSetTimeout() {
  console.log("Start!");
  setTimeout(() => {
    console.log("Inside setTimeout!");
  }, 1000);
  console.log("End!");
}
useSetTimeout();

The function above contains three log() statements.

The second log() statement, "Inside setTimeout!", is inside of a function passed to the setTimeout() function.
The setTimeout() function takes two arguments: a callback function and a number that represents the number of milliseconds that should elapse before firing the callback function.

This leads to the following text being logged to the console.

Start!
End!
Inside setTimeout!

Despite the fact that the setTimeout() function is invoked immediately, the callback function isn't invoked until later.
 That means that the setTimeout() function is an asynchronous operation.
 This is visualized in the diagram below:
setTimeout() visualization

**** Event loop
Knowing how setTimeout() works, the above ordering makes sense.

Of course Inside setTimeout! would be printed after "End!" if it was forced to wait for one second before running.
But take a look at the code below—this results in exactly the same output.

function useSetTimeout() {
  console.log("Start!");
  setTimeout(() => {
    console.log("Inside setTimeout!");
  }, 0);

  console.log("End!");
}

useSetTimeout();

Notice that the setTimeout() function was told to wait for 0 milliseconds.
So how is it possible that "End!" is still printed before "Inside setTimeout!"?

Event loop :: A design pattern that a program may use to prioritize certain lines of code for execution
The reason has to do with something called the event loop.
The event loop describes a process by which JavaScript prioritizes certain lines of code for execution.
Asynchronous code is placed into a queue where it will always run after the synchronous lines of code in the current file.
If the current file has two or more asynchronous operations, you cannot determine the order in which the asynchronous operations will complete.

Essentially, when JavaScript is being interpreted, asynchronous operations are not executed immediately.
Instead, they are placed into an event queue and executed later.
Those operations will be run as soon as they can (which is always after the synchronous code has been run).


To further reinforce how this works, take a look at another example. Can you determine the order in which the statements below will run?
console.log("Start!"); // Synchronous code

setTimeout(() => {
  console.log("Inside first setTimeout!"); // Asynchronous code
}, 0);

setTimeout(() => {
  console.log("Inside second setTimeout!"); // Asynchronous code
}, 0);

console.log("End!"); // Synchronous code

It's important to note that each function in the above code is invoked when it is encountered.
That is, all of the code is being invoked in the order in which it's written.
However, the results of the asynchronous function calls aren't immediate.

In the above code, the log() statements for "Start!" and "End!" are synchronous function calls, so you will see the output from those function calls immediately.

However, when setTimeout() is invoked, it doesn't execute the callback immediately.
Instead, a new event is placed on the event queue along with the callback passed to setTimeout().
After the current file is done executing, the events in the queue are executed in order from oldest to newest (or first-in, first-out).
As a result, the callback function passed into setTimeout() will always run after the synchronous code in the current file.

So, the above code will result in the following output:
Start!
End!
Inside first setTimeout!
Inside second setTimeout!

Again, this is a simplistic view of the event loop, but it demonstrates the main concept at hand.
In short, despite the order in which the code is written, some code will take longer to run.

**** Why use asynchronous JavaScript?

Synchronous code will block further execution until it has finished what it's doing.
As a result, a long-running JavaScript function will make the web page or server unresponsive until the function has finished.
This can result in a terrible user experience.

To solve this problem, JavaScript makes certain operations asynchronous.
This way, the web page or server is responsive while waiting for long-running tasks to complete.

**** Common scenarios

Asynchronous code is usually preferred when one of the following conditions applies:
    + You want the application to continue to be able to run without waiting for some process.
    + You have no choice but to wait because the process depends on something outside of your control.

***** Animations

In web development, many graphical animations are powered by JavaScript using tools like setTimeout().
This can be anything from incredible visual displays to a notification icon blinking red.

Either way, timing is important for animation, as is interactivity.
When an animation starts on a web page, you probably don't want the rest of the web page to stop running completely to wait for that animation to finish.
Because of this, animations on the web are run asynchronously.

***** External web requests

When you're requesting data from an external source, you have little choice but to wait for the requested information.
If the external source is down or having a slow day, the request will take longer.

This isn't the same as depending on an external package; when you use libraries, you'll likely download them to your project so that they can be accessed quickly.
In contrast, external web requests involve requesting data from some other website.

Tip :: Intensive processes, like processing images or video files, are often put into an asynchronous function so that the long-running process doesn't slow down the main program.

****** Do this :: Write an asynchronous function

Now you will write code that downloads a video from a remote server and processes it after the download completes.
However, downloading a large video from a remote server takes some time depending on the network speed and the size of the video.

Note: Rather than actually downloading or processing the video, you will use the setTimeout() function to simulate the time that it takes for downloading and processing.

Create a new folder on your computer, then add the following code to download-and-process-video.js:

function download(url) {
  console.log(`Start downloading video from ${url} ...`);

  setTimeout(() => {
    const fileName = url.split("/").pop();
    console.log(`Video downloaded from ${url} to ${fileName}.`);
  }, 2000);
}


function process(videoFile) {
  console.log(`Start processing ${videoFile} ...`);


  setTimeout(() => {
    console.log(`Video processing complete: ${videoFile}.`);
  }, 4000);
}

const url = "https://www.thinkful.com/sync-and-async.mov";

const fileName = download(url);

process(fileName);

In the above code, the download() and process() functions are both synchronous functions.
However, they both call setTimeout(), an asynchronous function.

Before running the code, take a moment to write down what you think the output will be when you run the above code.
Then run the code, using node download-and-process-video.js.
You'll see the following output:

Start downloading video from https://www.thinkful.com/sync-and-async.mov ...
Start processing undefined ...
Video download from https://www.thinkful.com/sync-and-async.mov to sync-and-async.mov.
Video processing complete: undefined.

As you can see from the above output, the process() function started before the download() function completed. The behavior that you want is for the code to wait for the download to complete, then call the process() function.

To fix this problem, pass the process() function to the download() function as a callback, as shown below. When the download() function is complete, it will call the callback() function, passing in the filename.

-function download (url) {
+function download (url, callback) {
   console.log(`Start downloading video from ${url} ...`);

   setTimeout(() => {
     const fileName = url.split('/').pop()
     console.log(`Video downloaded from ${url} to ${fileName}.`);
\+    callback(fileName)
   }, 3000);
 }


function process (videoFile) {
  console.log(`Start processing ${videoFile} ...`);

  setTimeout(() => {
    console.log(`Video processing complete: ${videoFile}.`);
  }, 4000);
}

const url = 'https://www.thinkful.com/sync-and-async.mov';

-const fileName = download(url);
+download(url, process);

-process(fileName);

In the above code, the download() function now takes a callback function as a second parameter.
The download() function does not know what the callback function does, only that it should be called after the download is complete.
You have already used callback functions for the find(), filter(), map(), some(), and every() functions on an array, so this pattern will seem familiar.

Now, run the code again using node download-and-process-video.js.
You'll see the following output:
Start downloading video from https://www.thinkful.com/sync-and-async.mov ...
Video downloaded from https://www.thinkful.com/sync-and-async.mov to sync-and-async.mov.
Start processing sync-and-async.mov ...
Video processing complete: sync-and-async.mov.

Now the code works as expected.

Although it may seem like the code is blocked while it is waiting for the download, the code is able to execute other commands while waiting for the download.
Add the following code to the end of the file to see that other commands are still processed while waiting for the download.

setInterval(() => console.log("some other work is happening here"), 500);

Now, the output will look like this:
Start downloading video from https://www.thinkful.com/sync-and-async.mov ...
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
Video downloaded from https://www.thinkful.com/sync-and-async.mov to sync-and-async.mov.
Start processing sync-and-async.mov ...
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
some other work is happening here
Video processing complete: sync-and-async.mov.
some other work is happening here
...

As you can see, asynchronous code allows the web page and server to remain responsive while waiting for long-running tasks to complete.

*** Creating promises
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to create promises using the Promise() constructor function.
Overview

The most popular way to manage asynchronous code in JavaScript is through an object called a promise. A promise can run asynchronous code and provide a set of methods that allows you to extract a single result from that code. In this lesson, you'll learn the basics of creating promises in JavaScript.
What's the problem?

Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Recall that asynchronous code complicates the order in which code is run. In some scenarios, this can be challenging. To understand the problem a little better, you will write some code to read a text file containing quotes, then randomly select one of the quotes and print it out for the user.

To begin, create a new folder named quotes to store the files.

In quotes.txt, add the following:

On a long enough timeline, every line of code is obsolete. - Unknown

Deliver yesterday, code today, think tomorrow. - Unknown

A clever person solves a problem. A wise person avoids it. - Albert Einstein

There's no time to stop for gas, we're already late. - Karin Donke

In main.js, add the following code:

const fs = require("fs");


let quote = null;


console.log("Finding a quote...");


fs.readFile("quotes.txt", (error, buffer) => {

  if (error) {

    throw error;

  }

  const lines = buffer.toString().split("\n");

  quote = lines[Math.floor(Math.random() * lines.length)];

});


console.log(`Your quote is: ${quote}`);

The above code reads the contents of quotes.txt using the asynchronous fs.readFile() function. In the readFile() callback function, it splits the file contents into lines and then randomly assigns one of the lines to the quote variable. Finally, it logs Your quote is: ${quote}.
Tip

The fs module used in the code above enables interacting with the file system. The intricacies of the fs library are outside of the scope of this lesson; if you would like to know more, consult the fs documentation.

However, if you run the code above, you'll see that the output doesn't quite work. Take a look:

node main.js


Finding a quote...

Your quote is: null

Why is the quote null?

Remember that any asynchronous code is not executed immediately. Instead, it is added to the event queue and will always run after the code in the current file. This means that the code inside of the fs.readFile() callback will always run after the console.log(`Your quote is: ${quote}`); statement.

One way to fix this code is to move the console.log(`Your quote is: ${quote}`); inside of the fs.readFile() callback.

Another way to fix this code is to use a promise. In JavaScript, promises are a reliable way of knowing when asynchronous code has been completed.
Promises

For an introduction to promises, review the following video.

A promise is a type of object that wraps around asynchronous code. Promises won't run the callback function until needed, and they provide methods to extract the final result.

Promises are an ingenious solution. They allow you to run asynchronous code inside an object that provides you with some functions that you can use to respond to the success or failure of the asynchronous code.

To manage asynchronous code, promises have three states:

    Pending: When a promise is first created, it has a status of pending. For example, with fs.readFile(), the promise would be in the pending state during the time that the file is being read.

    Fulfilled: When the promise has successfully finished running, it has a status of fulfilled. This means that it is ready to pass back a value. In the fs.readFile() example, this is after the error and buffer are passed to the callback function.

    Rejected: If something goes wrong, the promise changes to a status of rejected. This means that something failed. In the fs.readFile() example, if the first parameter, error, is truthy, that means that there was an error reading the file—so the promise should be rejected. The rejected status is especially likely to come up when you're making external web requests or reading files.

Syntax

Take a look at the code below, which demonstrates the creation of a promise.

const newPromise = new Promise((resolve, reject) => {

  // Your code here...

});

The code above demonstrates the following:

    A new promise can be created using the new keyword with the Promise class. This will create an instance of a promise.

    Promises can be assigned to variables.

    The only argument to pass in to the Promise constructor is a callback function that has two parameters: resolve and reject.

The following diagram shows how the resolve() and reject() methods change the state of the promise.
A pending promise can either be fulfilled with a value or rejected with a reason

As you can see in the diagram above, a pending promise can either be fulfilled with a value, or rejected with a reason (error). Finally, a fulfilled or rejected promise cannot transition into any other state.
Do this
Return a promise

The video below outlines how to return promises from functions.

Next, you will write a function that returns a promise. Inside the returned promise, you will write some code that executes fs.readFile() to read the file contents.

Create a file named read-file.js, and add the following code:

const fs = require("fs");


function readFile(fileName) {

  return new Promise((resolve, reject) => {

    fs.readFile(fileName, (error, buffer) => {

      if (error) {

        return reject(error);

      }

      resolve(buffer.toString());

    });

  });

}


module.exports = readFile;

In the code above, you can see that readFile() returns a new Promise(). The promise takes a callback function with two parameters, resolve() and reject(), which are both functions.

To fulfill the promise successfully, pass the final value that you want to extract from the promise to the resolve() function. In the example above, the file contents are passed into the resolve() function and the promise becomes fulfilled.

The reject() function works the same way as resolve(), except that it is used when the asynchronous code has failed or gone wrong in some way. In the above example, if error has a truthy value, then error is passed to the reject() function and the promise becomes rejected. You will see more examples using reject() in the future.
Do this
See a promise change state

Next, you will write some code that uses the readFile() function that you created earlier. This new code will log the promise returned by readFile() two different times, a few milliseconds apart, so that you can see the promise change state automatically when the asynchronous code inside the promise completes.

Create a new file named quotes.js, and add the following code:

const readFile = require("./read-file");


const readFilePromise = readFile("quotes.txt");


console.log(readFilePromise);


setTimeout(() => {

  console.log(readFilePromise);

}, 500);

Run the code above using node quotes.js. The first console.log(readFilePromise); statement will print something like this:

Promise { <pending> }

Then a few milliseconds later, it will log out the readFilePromise variable again. This time, it will look a bit different:

Promise {

  'On a long enough timeline, every line of code is obsolete. - Unknown\n' +

    'Deliver yesterday, code today, think tomorrow. - Unknown\n' +

    'A clever person solves a problem. A wise person avoids it. - Albert Einstein\n' +

    "There's no time to stop for gas, we're already late - Karin Donke"

}

As you can see above, the readFilePromise variable goes from a pending state to a fulfilled state once the asynchronous code inside the promise callback calls the resolve() function.

More precisely, the promise changes state when the resolve() or reject() function is called.

*** Resolving promises
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use the then() method to extract the resolved value of a promise, and the catch() method to extract the rejected reason of a promise.
Overview

In this lesson, you'll learn how to resolve promises using callback functions.

Now that you know how to create promises, you may have noticed that there is no way to determine the promise's state (such as pending, fulfilled, or rejected). There's also no way to get the resolved value or rejected reason from the promise. Unlike other objects in JavaScript, the state of the promise, and therefore its value, can change from pending to fulfilled or rejected at any time. This means that you need to have a way to be notified when the state of the promise changes. As a result, promises use callback functions to signal the state of the promise. When the promise is resolved, the callback function passed to then() is called, passing in the resolved value. When the promise is rejected, the catch() method is called, passing in the rejected reason (error).

The video below provides an overview of the file setup process. Start by watching the video, and then read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.
Starter code

This lesson requires you to fork and clone the following GitHub repository:

    Resolving Promises Starter Code

Once you have the repository on your computer, you can run npm start from the folder to run the code in main.js.

You will see output that looks similar to the following:

node src/main.js


Promise { "Provide me a question and I'll give you an answer..." }

Fortune-teller functions

Each of the functions inside of utils/fortune-teller.js returns a promise. You'll be able to use these functions to test out promises for the rest of this module.

Although you are welcome to look at the code inside of the utils folder, you don't need to make any changes.
Extracting the resolved value

When a promise is created, the asynchronous operation inside will be fulfilled as quickly as possible. However, there are no methods or properties available to directly access the resolved value of a promise.

For example, look at the code below:

const welcomePromise = welcome();

console.log(welcomePromise);

When you run the code above, you will see the following:

Promise { "Provide me a question and I'll give you an answer..." }

Although you can see the final value stored inside of the welcomePromise variable in the above example, you aren't able to access the string inside. In other words, you only have access to the Promise object, not the string, because there are no methods or properties you can use to directly access the resolved value of a promise.

Thankfully, JavaScript's Promise object offers two methods—then() and catch()—that allow you to access the value of a fulfilled promise or the reason for a rejected promise.
The then() method

The video below provides an overview of the then() method.

The then() method accepts a callback function that is called whenever the promise is fulfilled. Here's an example:

const welcomePromise = welcome();

welcomePromise.then((result) => {

  console.log("The result is:", result);

});

The above code will print the following:

The result is: Provide me a question and I'll give you an answer...

The callback takes a single parameter, which contains the fulfilled (resolved) value of the promise.

The code above can also be written to chain directly from the promise, like so:

welcome().then((result) => {

  console.log("The result is:", result);

});


//> The result is: Provide me a question and I'll give you an answer...

Because console.log() is a function, you can also just pass it into then() if you don't need to do anything extra. Here's an example:

welcome().then(console.log);


//> Provide me a question and I'll give you an answer...

Remember, it's asynchronous!

Now that you've seen how to access the result of a promise, it can be tempting to do something like this:

let myString = "The result is: ";


const promise = welcome();

promise.then((result) => {

  myString += result;

});


console.log(myString);

But can you guess what the output of the code above will be? Remember, promises are asynchronous!

The code above will result in the following output:

//> The result is:

When the console.log() function is called, the promise hasn't yet resolved. It's important to remember that all work on the result of the promise must be done inside of the then() callback function.
Do this
Use then()

In the repository that you cloned, add the following code at the end of src/main.js:

const question = "Will the weather be nice today?";

const tellPromise = tell(question);

Use a then() function to log out the fortune's result. Try it on your own before looking at the solution below.

const question = "Will the weather be nice today?";

const tellPromise = tell(question);

tellPromise.then(console.log);

Use external variables

Although you can only access the result of a promise inside of a then() function, you can use variables outside of its scope inside of the then() callback function.

To see this in action, try updating your code to this:

const question = "Will the weather be nice today?";

const tellPromise = tell(question);

tellPromise.then((fortune) => {

  console.log(question);

  console.log(fortune);

});


//> Will the weather be nice today?

//> Without a doubt.

Did you notice the output?
The catch() method

The video below provides an overview of the catch() method.

Earlier, the method was described as a way to access the resolved value. That's because if a value inside of a promise is rejected with the reject() function, it will skip the then() method until it finds a catch().

The catch() method is the error handler for a promise. Like try/catch blocks, if the catch() method doesn't throw an error, the calling method doesn't know that an error happened. In other words, the promise returned by the catch() method is rejected only if the catch() throws an error or returns a promise which is itself rejected; otherwise, the promise is resolved.

This can be a bit confusing, so have a look at some code.

For example, if no question is provided to the tell() function below, an error message will be passed into the reject() function.

const tellPromise = tell()

  .then((result) => {

    console.log("Success:", result);

  })

  .catch((error) => {

    console.log("Failure:", error);

  });


setTimeout(() => console.log(tellPromise), 500);

In the above code, the tell() function has no question passed into it. Therefore, inside the tell() function, the reject() function is called with an error message.

When you run the above code, the output will be the following:

Failure: A question is required...


Promise { undefined }

When a promise's state changes from pending to rejected, it skips over any then() methods to the next catch() method. Notice that the "Success:" message doesn't get called at all!

As you can see in the output above, the promise is in the fulfilled state with a value of undefined (the catch() callback function returned undefined). While this may seem counterintuitive, it is exactly the same behavior as a try/catch block inside a function.
Do this
Use catch()

Include a catch() at the end of your code's current then(). Log out the value from the callback and then run your code; you won't see the error message.

Then try removing the question and running the code again.

The complete code is below.

const question = "Will the weather be nice today?";

const tellPromise = tell();

tellPromise

  .then((fortune) => {

    console.log(question);

    console.log(fortune);

  })

  .catch(console.error);

Reorder then() and catch()

If a promise reaches the fulfilled state, the response goes to the next then(). And if a promise reaches the rejected state, the response goes to the next catch(). This is true regardless of the order.

const question = "Will the weather be nice today?";

const tellPromise = tell(question);

tellPromise.catch(console.error).then((fortune) => {

  console.log(question);

  console.log(fortune);

});

The above code will work the same regardless of whether catch() comes before or after then(). It's typical to put catch() statements at the end, but it isn't necessary.

Try switching the order of your then() and catch() code to verify this assertion.
Chain then() and catch()

You can continue to chain then() and catch() statements, depending on what you want to accomplish with the return result.

When chaining multiple then() calls together, the value returned from a then() callback function is passed to the next then() callback function. If a then() callback function returns a promise, the promise is resolved before the next then() callback function is called. This continues until the last then() callback function is called. Because of this, you don't have to place then() calls inside of another then() call.

welcome()

  .then(console.log) // Logs the result of welcome()

  .then(() => goodbye().then(console.log)) // .then inside of another .then

  .catch(console.error); // Logs error from welcome() or goodbye()

Instead, the above code should be written as follows:

welcome()

  .then(console.log) // Logs the result of welcome()

  .then(goodbye) // Returns promise from goodbye()

  .then(console.log) // Logs the result of goodbye()

  .catch(console.error); // Logs error from welcome() or goodbye()

Try running the code above to see what gets outputted.

However, if you want to combine the results of two or more promises, you will need to nest then() calls to have access to the results of both calls. The following code demonstrates combining the results from multiple promises.

welcome()

  .then((welcomeMessage) =>

    goodbye().then((goodbyeMessage) => `${welcomeMessage}\n${goodbyeMessage}`)

  ) // welcomeMessage and goodbyeMessage combined.

  .then(console.log) // Logs combines messages

  .catch(console.error); // Logs error from welcome() or goodbye()

It's important to note that a then() or catch() will always move to the next then(). Therefore, if you place a then() call after a catch(), the next then() will always be called. For example, try running the following code to see the output:

welcome()

  .then(console.log) // Logs the result of welcome()

  .then(tell) // Calls tell, which returns a rejected promise (no question supplied).

  .then(console.log) // Skipped because tell returned a rejected promise.

  .catch(console.error) // Logs error from tell() or welcome()

  .then(goodbye) // Returns promise from goodbye()

  .then(console.log) // Logs the result from goodbye()

  .catch(console.error); // Logs error only from goodbye()

Note: You'll learn more about this topic later in the program.
Complete example

A completed example from this lesson can be found here:

    Promises: Resolving Promises
** Making requests
*** How the web works
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use technical terminology to explain the series of requests that are made when visiting a website.
Overview

Right now, you are looking at a web page from Thinkful. How did that happen? In this lesson, you will learn the basics of how web requests and responses work. This lesson is the foundation of your career in web development.
Key Terms

Uniform resource locator
    URL, also called a uniform resource identifier, the way that distinct resources are identified on the web
Domain name system
    DNS, a service that acts as a lookup, translating a domain into an actual IP address
Internet service provider
    ISP, an entity that gives you access to the internet

The client
Concept of a client requesting information.

Right now, you are accessing this curriculum through a web browser. No matter which browser you are using, your browser is requesting information from Thinkful. More specifically, it's requesting HTML, CSS, and JavaScript from Thinkful in order to present you with this page. In this way, your browser is acting as a client.
Key Term

Client: A web-accessing device or software that requests information

Although you are accessing this page through a browser, a browser isn't the only kind of client. Any kind of program that requests information from the web could be considered a client.

For example, all of the following could be clients:

    A mobile application (such as your mail application)

    A software program running on your computer (such as Slack)

    Your computer

Each of the above examples can make requests to the web and do something with that information. Next, you'll explore where these requests go.
The server
Concept of a server receiving a request for information.

Each successful request that a client makes must go somewhere, but where does it go? The program that receives the request is called a server.
Key Term

Server: A device or program that receives requests from clients and responds to them, acting as the brain of the backend

Note: You may also hear the term server used to refer to actual hardware. But in this case, it refers to the program that takes in a request and responds to it.

Servers expose resources to clients. Those resources could be general data, or they could be HTML, CSS, JavaScript, image, video, or audio files. Sometimes those resources are stored on the server itself, while other times, the server may request those resources from another server. In this way, the server can actually act as a client as well.

Servers make it possible for clients to get the files, data, and other resources that they need in order to do something valuable for an end user.
Request-response cycle
The request-response cycle.

In the request-response cycle, the client sends a request to the server, which then processes this request and responds back to the client. Often, the client will then do something with this information, such as render a web page.
Key Term

Request-response cycle: The path that information takes from the client to the server and then back to the client

This is how the web works: When you go to a website, your browser (a client) makes a request to a server. That server responds with the requested information, which your browser then transforms into a website.

This process can be repeated multiple times for a single view of a web page. For example, on this page, your browser made multiple requests for HTML, CSS, JavaScript, and image files.
Browser making multiple requests for HTML, CSS, JavaScript, and image files.
URLs

The server determines what information to send back. In large part, this determination is based on where the client makes the request. For example, making a request to thinkful.com/about will yield different information than a request to thinkful.com/blog.

The "location" of a request is represented by a uniform resource locator (URL), which is an address for a request. The server will respond to the client with information based on the requested URL.

A URL contains many parts, each of which helps the server decide how to respond. For example, go to YouTube's home page. In the search bar on YouTube's home page, type in how the web works. When you press Enter, notice that the URL in the address bar changes. It will now show something like the URL below.
Anatomy of a URL.

As you can see, there are many parts to a URL. You will return to this diagram later on as you begin to build your own servers. For now, know that each part of the URL helps the server determine what kind of information to send back to the client.
DNS and ISP

Each device connected to the internet has an address associated with it called an IP address. You have an IP address too.
Key Term

IP address: A unique series of numbers that represent a device connected to the internet and allows other devices to connect to it

It isn't easy for humans to remember IP addresses, because they feel like random series of numbers. Instead, people rely on remembering domain names such as thinkful.com or khanacademy.org. These domain names are simply text labels that mask an IP address underneath.

For example, thinkful.com is a domain name. When you type thinkful.com into your browser, how does it know what the IP address is for Thinkful? The answer is that it doesn't. Instead, it asks what's called a domain name system (DNS) by going through your internet service provider (ISP). A DNS is a service that acts as a lookup. It translates a domain (such as thinkful.com) into an actual IP address (such as 104.26.13.185). And an ISP is an entity—like Comcast or Verizon—that gives you access to the internet.

Your browser will make a request to a DNS with the domain name, which will then translate it into an IP address. It sends that information back to the browser, which will then make all subsequent requests to the server. This diagram illustrates that process:
DNS request diagram showing four steps: parsing the URL, ISP, DNS, and client.
The full trip

This lesson covered several new concepts. Now, review the entire process of making a web request:

    Your client (the browser) makes a request to a specific URL.

    The client sends the domain name to the ISP.

    The ISP looks up the IP address in the DNS.

    The ISP sends the IP address back to the client.

    The client opens a connection to the server located at the IP address.

    The client sends a request to the server.

    The server sends a response.

    Steps six and seven repeat until the browser has all of the resources that it needs.
*** Postman
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use Postman to make web requests.
Overview

Although your browser is a client that can make web requests on your behalf, by default, it doesn't allow for the kind of insight that web developers need. Web developers want to understand what's happening behind the scenes and see what kind of responses are being sent back from a server. Fortunately, there are several tools that will allow you to do just that. In this lesson, you'll learn how to use a tool called Postman.

The following video provides a brief introduction to this topic. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.
Starter code

This lesson requires you to have the Constellations server GitHub repository running on your local machine. If you haven't already, fork and clone the repository. Then, follow the README file's instructions to get the server running.
What is Postman?

At its most basic, Postman is a software application that allows you to make web requests without the use of a browser. In this program, you will use Postman to make requests and inspect the results.

However, Postman can do much more than that. The free version of the app allows for saving collections of requests, as well as a variety of testing and logging features. Although this program will not make use of those features, feel free to explore some of the features available in Postman on your own time.
Do this
Download Postman

Download Postman through the following link. Install the software and then open the program.

    Postman: Downloads

Application overview

When you open the application, you will see something like this:
Graphical user interface of the Postman application.

Take note of the following components, which are labeled in the image above.

    The navigation bar at the top of Postman allows you to switch workspaces and includes the New button.

    The sidebar allows you to filter historical requests that you've made. It also lets you create new collections for your requests.

    The main section of the application will be where you see the requests that you make. The app typically starts up on the Launchpad screen. The New tab ➕ icon allows you to start a new request.

As you can see, there are numerous buttons and icons; you'll focus on just a few of them for this program.
Do this
Customize your screen

By selecting the various dividers and closing tabs, you can simplify your workflow. Click the New tab button in the main section of the page and then follow the instructions below to create a more streamlined view.

    Close the Launchpad tab.

    Open a new request tab by clicking the New tab button.

    Drag the sidebar divider to the left to collapse the sidebar.

    Drag the Response section of the new request tab up to hide the Params section.

When you're done, your view will look like this:
Customized Postman view.
Making a request

To make a request with Postman, type a URL like https://thinkful.com into the location bar that's next to the drop-down menu with the word GET in it, as shown below. Then, click Send.
Making a request with Postman.

The response section will change to include a number of tabs, including the Body tab. In it, you'll see a bunch of text—that's HTML and CSS!

By default, Postman will suggest that you save your requests in case you end up using them often. In this program, you typically won't need to save them.
Do this
Make a request with Postman

Follow the instructions above to make a request to https://thinkful.com. If you've visited the Thinkful website lately, you may recognize some of the content!
Use the Preview button

Click the Preview button that is within the Body section. Although it may not look quite the same, you will probably recognize some elements from the Thinkful website.
Make a request to your running server

Make sure that your Constellations server is up and running, and then make a request to the following URL:

http://localhost:5000/constellations

You will see something that looks like an array with a number of objects inside of it. You just made your first request to a server running on your own machine!
*** Headers
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to inspect and identify different parts of requests and responses. You'll also be able to make requests that use different HTTP verbs and include data in the request body.
Overview

In this lesson, you'll discover how to change the requests that you make and how to inspect the responses that are returned.
Key Terms

HTTP request method
    Also called an HTTP verb, a method that indicates the desired action (such as deleting a resource) to be taken on a given resource
Header
    Information that is included on the request and response, and generally includes metadata such as authorization information, cookies, and when the request happened
Request body
    Information that is sent on a request that isn't included in the URL
Response body
    Information sent back from the server
Status code
    The part of the response that gives a quick indication as to how the request went

Although you may be used to seeing only the URL, web requests are actually much more complicated than just the URL. Both requests and responses allow for additional data to be sent back and forth, and this process is invisible to most internet users. This metadata is generally referred to as headers.

The following video provides a brief introduction to this topic. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.
Starter code

This lesson requires you to have the Constellations server GitHub repository running on your local machine. If you haven't already, fork and clone the repository. Then, follow the README file's instructions to get the server running.
Diagramming a request and response

As mentioned above, web requests include much more than just a URL. Take a look at the request below, which was made with Postman. Then, continue on to read the description of each section and the definitions that follow.
A web request in Postman.

    This section includes the request URL as well as the HTTP verb. In this case, the request URL is https://thinkful.com, and the HTTP verb is GET.

    This section includes parts of the request headers as well as the request body sent along with the request.

    This section shows the response body as well as the response headers.

    This section shows the response status code and associated message.

As you may have noticed, web requests have a lot of terminology associated with them. The definitions below will help you understand the web request description that you just read.

    An HTTP verb, also sometimes called an HTTP request method, describes what kind of request is being made. For example, a GET request means that the client wants to "get" new information from the server.

    Headers is a general term that relates to information that is included on both the request and response. Headers generally include metadata such as authorization information, cookies, and when the request happened. Request headers and response headers specify particular information that only appears on the appropriate response.

    The request body is information that is sent on a request that isn't included in the URL. For example, when you sign up for a new website, your username and password are sent in the request body.

    The response body is information sent back from the server. This could include the information that you've requested or an error message if something went wrong.

    A status code is the part of the response that gives a quick indication as to how the request went. In the example above, 200 OK indicates that the request was successful.

In the following sections, you'll explore each of the above concepts in depth.
Requests

Recall that requests come from a client (such as Postman) and reach some kind of server (such as where Thinkful has stored its server).
HTTP verbs

Each request contains an HTTP verb, also called an HTTP method. Although there are many possible verbs, there are five that are the most common. Each verb ideally describes what kind of request is being made.
Verb
	Description
GET
	Retrieve information
POST
	Create something new
PUT
	Update something
PATCH
	Update part of something
DELETE
	Destroy something

By default, when you type a URL into your browser's location bar, a GET request is always performed. With a browser, there is no easy way for you to simulate the other kinds of verbs. Thankfully, this is much easier with Postman.
URLs

In combination, HTTP verbs and URLs are the key ways that servers begin to figure out what it is that the client wants. For example, the following three requests could all perform distinctly different actions.

DELETE http://localhost:5000/constellations/abc-def

POST http://localhost:5000/constellations

GET http://localhost:5000/constellations

The first two URLs in the above example are different, and therefore it may be obvious that they'd return a different kind of response. However, the last two URLs are the same—and yet they might return a different response because they use different HTTP verbs.

This combination of HTTP verb and URL is sometimes called a route. A route is a specific combination of an HTTP verb and a URL (or part of a URL).
Do this
Use the GET verb

Ensure that your Constellations server is running. Then, in Postman, make a GET request to the following URL:

http://localhost:5000/constellations

The output will look something like this:
Making a GET request with Postman.

Take one of the id values and make a new GET request to the following URL, replacing the :id with the actual id value from the Postman output.

http://localhost:5000/constellations/:id

After pressing the Send button, you will see output that shows only that single constellation, as shown below.
Output shows the single constellation.

Even though the HTTP verbs were the same for both of the requests you made, the outputs were different. This shows that the URL affected the type of information that was returned.
Use the DELETE verb

Using the same id value as before, make a new DELETE request to the following URL. Again, replace :id with the actual id value from the Postman output.

http://localhost:5000/constellations/:id

You will get back a response that looks like an empty object. The constellation that you just selected has been deleted from your running server!
Selected constellation is deleted from the running server.

If you want to check that the operation has taken hold, you can look at the changes in your Constellations server repository or repeat the GET requests from above. You should see that the constellation has been removed.

Even though the URL is the same as before, changing the verb from GET to DELETE caused a completely different operation to happen.
Body

Optionally, additional data can be sent in the form of a body. A body can contain any kind of data, although the body contains JSON in many APIs.
Do this
Use the POST verb

In Postman, open up the Body tab that is closest to the URL. You'll be presented with a number of radio button options. Select raw, and then paste the following content inside of it. Then, change the drop-down menu at the end of the line from Text to JSON.

{

  "name": "Columba",

  "meaning": "Dove",

  "starsWithPlanets": 3,

  "quadrant": "SQ1"

}

Before making the request, your view should look like this:
Before making a POST request in Postman.

Then make a POST request to the following URL:

http://localhost:5000/constellations

This will cause the creation of a new constellation on your server. You can see this by the fact that the response now includes an ID.
Other headers

Other headers can sometimes be included in the request. This includes headers like the Authorization header or information about what response format is preferable. In this program, these request headers will be introduced as needed.
Responses

Responses come with their own structured information.
Body

In general, the response body is the most interesting part of the response. If you are expecting to receive data like JSON or HTML, you'll see it in the body.

In all of the previous examples, the response body contained JSON. In future applications, you'll be able to use this data to present information to the user in some way.
Status codes

A status code is like a brief synopsis of how the request-response cycle went. Status codes have a particular numbering system and associated messages.
Number range
	Response type
	Example
200s
	Successful
	200 - OK
300s
	Redirects
	307 - Temporary Redirect
400s
	Client error
	404 - Not Found
500s
	Server error
	503 - Service unavailable

Status codes are useful in programs that make web requests; they enable the program to make a quick decision based on just a number.

There are many status codes, and some are used much more than others. You can learn more about status codes at MDN's HTTP response status codes page.
Other headers

Other values can be stored inside of the response. For example, the response can store the date or even what kind of program is returning the response. In this program, you will be introduced to these response headers as needed.
*** Requests in JavaScript
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to make requests to a server with JavaScript.
Overview

In this lesson, you'll learn how to make requests in JavaScript, just like the ones that you made in the Postman application. To do so, you'll need to synthesize what you've learned about how the web works and how to write asynchronous code.

Postman is a great tool for making requests to servers. However, ultimately, you will want to be able to make these kinds of requests from your code instead of from a separate program.

The following video provides a brief introduction to this topic. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.
Starter code

This lesson requires you to have the Constellations server GitHub repository running on your local machine. If you haven't already, fork and clone the repository. Then, follow the README file's instructions to get the server running.

Next, create a new folder called requests-in-javascript. Inside of it, run the following:

touch requests.js

npm init -y

npm i axios

External request helpers

Depending on your environment, there are several different tools that you can use to make external requests in JavaScript. For example, if you're building code that will be used on the frontend, you could use the Fetch API. And if you're building code that will be used on the backend, you could use the built-in Node HTTP package.

For this module, you will use a package called axios. The axios package can be used on both the frontend and the backend, making it a good choice for learning how to make web requests. It's also a promise-based library, which means that you can apply your prior knowledge of working with asynchronous code to making web requests. To learn more about this package, check out the axios documentation.

Note: Every tool is slightly different, even if they accomplish the same goal. If you use a different tool at some point, look at that tool's documentation to learn how to use it.
Simple requests

The axios library provides clear documentation and even clearer methods. To begin, take a look at this request:
Making a GET request with Postman.

This same request written in JavaScript with the axios library would look like this:

const axios = require("axios");


const url = "http://localhost:5000/constellations";

axios.get(url).then((response) => {

  console.log(response.status);

  console.log(response.statusText);

  console.log(response.data);

});

The axios.get(url) command is a promise, which means that the then() method can be called on it. The then() callback function will provide a parameter which is an object that contains details about the response.

The keys status, statusText, and data return information about the status code, the status code message, and the response body, respectively.

If an error with axios occurs, you can use catch(), just like you would with other failures.

axios.get("malformed url").catch((error) => {

  console.log(error.message);

});

Do this
Make a request with JavaScript

Copy the code below into the requests.js file that you made.

const axios = require("axios");


const url = "http://localhost:5000/constellations";

axios

  .get(url)

  .then((response) => {

    console.log(response.status);

    console.log(response.statusText);

    console.log(response.data);

  })

  .catch((error) => {

    console.log(error.message);

  });

Make sure that your Constellations server is running, and then run your requests.js file. Take a look at the output and compare it with the output that you received from Postman. The response body should be the same!
Manipulate the data

Now that you have these responses in JavaScript, you can perform all kinds of operations on them. For example, try writing code that will print out an array of only those constellations where the starsWithPlanets value is less than 10.

Try writing the code on your own before looking at the solution below.

const axios = require("axios");


const url = "http://localhost:5000/constellations";

axios

  .get(url)

  .then((response) => {

    const result = response.data.filter((constellation) => {

      return constellation.starsWithPlanets < 10;

    });

    console.log(result);

  })

  .catch((error) => {

    console.log(error.message);

  });

Complex requests

The axios library provides different methods for common HTTP verbs such as get(), post(), put(), patch(), and delete().

The second, optional argument in all of these methods is a config object, which can include information like additional headers or the request body.

Most of the time, you will be providing a request body, which can be accomplished by adding an object with the request body data.

const url = "http://localhost:5000/constellations";

axios

  .post(url, {

    name: "Ara",

    meaning: "Altar",

    starsWithPlanets: 7,

    quadrant: "SQ3",

  })

  .then((response) => {

    console.log(response.data);

  });

The above request will create new data for the Ara constellation on the server. It will then return the newly created constellation with an ID.

{

  name: "Ara",

  meaning: "Altar",

  starsWithPlanets: 7,

  quadrant: "SQ3",

  id: "DVaSPTf",

};

Do this
Create a new constellation

Copy the code above and run it to create a new constellation on your Constellations server. Take note of the ID that it returns!
Delete a constellation

Create a new DELETE request using the axios.delete() method. Change the URL to the URL below, replacing :id with the ID from your newly created constellation.

http://localhost:5000/constellations/:id

Upon deletion, you will likely just see an empty object. Run your get() request again to confirm that the constellation has been deleted.
Complete example

A completed example from this lesson can be found here:

    Making Requests: Requests in JavaScript
*** Testing asynchronous JavaScript
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to write automated tests for asynchronous code.
Overview

HTTP requests in JavaScript are asynchronous operations, meaning that the data for requests is returned at a later time from the server. Too many asynchronous operations in unit tests could significantly slow down development. To keep your unit tests running quickly, your unit tests should avoid accessing external resources such as remote servers and databases. So, in this lesson, you'll learn how to use Jest—specifically Jest mocks—to test asynchronous code.
Starter code

This lesson requires you to have the Testing asynchronous JavaScript GitHub repository running on your local machine. Fork and clone that repository now. Then, follow the instructions on how to get it to run.
Unit tests

Keep in mind that unit tests test a small piece of code, generally a single function. If you have thorough unit tests, the unit tests will point you to any functions that aren't working as expected, thereby making it easy to identify issues with your code. Luckily, you can also write unit tests to test asynchronous code.
Testing asynchronous code

It's common in JavaScript for code to run asynchronously. For example, while using the axios library, you've learned that methods such as axios.get() and axios.post() return a promise. The promise can be handled within the then() method if the promise resolves successfully, or within a catch() method if the promise is rejected with an error.

You can use Jest to test various behaviors in your asynchronous code, including ensuring that methods are called with the correct arguments, and that any resolved or rejected promises are handled properly.
The index() function

In the src/requests.js file, the index() function makes a GET request to the URL http://localhost:5000/constellations using the axios library, as follows:

function index() {

  return axios

    .get(`${BASE_URL}/constellations`)

    .then(({ data }) => {

      const result = data.filter((constellation) => {

        return constellation.starsWithPlanets < 10;

      });

      return result;

    })

    .catch(({ message }) => {

      console.error(message);

    });

}

You can test the following behaviors of the index() function:

    It should call axios.get() with the correct URL (which, in this case, is "http://localhost:5000/constellations") as the argument.

    If the request is successful, then it should return a promise that resolves to an array of constellations where starsWithPlanets < 10.

    If the request is unsuccessful, then it should return a promise that rejects with a reason that is then logged to the console.

Tip

For simplicity, the index() function logs the error message to the console. In a real app, you'd want to handle a failed request properly by showing an error message to let the user know what went wrong instead of just logging the error to the console.

Now, you can write a unit test to test each behavior.
Jest mocks

Before you can start writing tests for asynchronous code, it's important to understand a testing technique called mocking. Mocking allows you to focus on the code being tested by controlling the behavior of any external dependencies in the code. For example, you can use mocking to configure specific return values or capture calls to a function. That way, you can isolate the code being tested and remove the effects of external dependencies (such as third-party npm packages).

Often, when your code depends on an external library to work properly, it may become difficult to isolate your code for testing.

For example, if the index() function internally calls the axios.get() method and a test fails, how would you know why the test is failing? Is it failing because the function is incorrectly implemented (which is what unit testing is meant to capture)? Or is it failing because of some underlying issues with the axios library (which is not what unit testing is meant to test)?

To address this issue, you can mock the methods in the axios library and configure the mock functions so that they always returns specific values when called, as follows:

jest.spyOn(axios, "get");

axios.get.mockImplementation(() => Promise.resolve({ data: { greeting: "Hello World" } }));

jest.spyOn(axios, "get"); "spies on" or tracks calls to the axios module and returns a Jest mock function for axios.get(). The Jest mock function is also known as a spy; it allows you to spy on the behavior of the function that is called indirectly by some other code.

The next line calls axios.get.mockImplementation(). mockImplementation() accepts a callback that defines the implementation of the mock (that is, how it should behave under test). Here, the axios.get() mock returns a promise that always resolves to the { data: { greeting: "Hello World" } } object as the response.

Now, with this setup, the mocked function will be called whenever axios.get() is invoked in the test code.
Do this
Verify that index() calls axios.get() with the correct arguments

In the tests/requests.test.js file, add the following code:

it("should make a GET request to the appropriate URL", async () => {

  jest.spyOn(axios, "get");


  await index();



  const expectedURL = `${BASE_URL}/constellations`;

  expect(axios.get).toHaveBeenCalledWith(expectedURL);


  jest.clearAllMocks();

});

Here's a breakdown of that syntax:

    jest.spyOn(axios, "get"); creates a Jest mock function for axios.get().

    Next, the line await index(); invokes the index() function, which in turn calls the axios.get() mock function.

    Then, assert that the axios.get() mock function was called with the expected URL.

    Finally, run jest.clearAllMocks() to remove any mocks created in the current test, so that other tests won't be affected by the mocks. This step is important because it's generally a good practice to ensure that the state of one test is independent of other running tests and that the failing or passing of one test should not affect another test.

Run npm test, and now you'll see one passing test.
Verify that index() resolves correctly

In the tests/requests.test.js file, add the following code:

it("should return a list of constellations with fewer than 10 stars with planets", async () => {

  jest.spyOn(axios, "get");

  axios.get.mockImplementation(() => Promise.resolve({ data }));


  const response = await index();


  const expected = data.slice(0, 2);

  expect(response).toEqual(expected);


  jest.clearAllMocks();

});

Here, the axios.get() mock function returns a promise that resolves to an object that contains a data key, which is set to an array of constellations objects.

Then await index() is called, and the result of the promise is stored in the response variable.

Next, create an assertion to check the response. Keep in mind that the index() function will filter for constellations where constellation.starsWithPlanets < 10, which are the first two constellations in the data array.

Finally, call jest.clearAllMocks() to remove any mocks created in the current test.

Run npm test, and you will now see two passing tests.
Verify that index() handles promise rejection

In the tests/requests.test.js file, add the following code:

it("should log an error to the console", async () => {

  jest.spyOn(axios, "get");

  axios.get.mockImplementation(() =>

    Promise.reject(new Error("Request failed."))

  );



  jest.spyOn(console, "error");


  await index();


  expect(console.error).toHaveBeenCalledWith("Request failed.");


  jest.clearAllMocks();

});

Here, the axios.get() mock function is configured to return a promise that rejects with an Error object containing the error message Request failed.

jest.spyOn(console, "error"); creates a mock function for console.error() so that you can spy on its behavior under test.

Next, await index() is called, and the test asserts that console.error() is called with the error message of Request failed.

Finally, call jest.clearAllMocks() to remove any mocks created in the current test.

Run npm test, and you will now see three passing tests.
Refactor

Because jest.spyOn(axios, "get") is called at the beginning of each test, you can keep your code DRY by moving this function call inside beforeEach(), like this:

beforeEach(() => {

  jest.spyOn(axios, "get");

});

And because jest.clearAllMocks() is called at the end of each test, you can move this function call inside the afterEach() function, like this:

afterEach(() => {

  jest.clearAllMocks();

});

Conclusion

Now you know how to use mocks to override the behavior of external libraries and API calls in your tests so that you can better isolate your code for testing.

In this lesson, you learned how to mock functions with Jest. Note that Jest also allows you to mock entire modules and even timers in your tests.
Complete example

A completed example from this lesson can be found here:

    Making requests: Testing asynchronous JavaScript
** Modern asynchronous programming
*** Promise chaining
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to evaluate chains of then() and catch() calls. You'll also be able to return promises to flatten your code.
Overview

Promises are a powerful tool for handling asynchronous code. However, as you begin to write complex code that performs multiple asynchronous requests, your code can become a bit messy. But by choosing the correct values to return in then() and catch() statements, you can write clear and concise code that uses promises. So in this lesson, you'll learn how to do just that.

The video below provides a brief introduction to promise chaining. Start by watching the video, and then read through the rest of the lesson and complete the practice work required. This will give you a full understanding of this concept.
Starter code

This lesson requires you to have the following GitHub repository running on your local machine.

    Constellations Server

Fork and clone the repository. Then, follow the instructions to get it to run.
Multiple asynchronous operations

It's common to need to make multiple asynchronous requests at nearly the same time. Sometimes, these requests depend on one another. For example, imagine that you wanted to create a new constellation record—but before creating the new record, you wanted to check to make sure that one with the same name didn't already exist.

To solve this problem, begin by taking a look at the following code, which makes two web requests at nearly the same time.

const axios = require("axios");

const BASE_URL = "http://localhost:5000";

const constellationsUrl = `${BASE_URL}/constellations`;


const leo = {

  name: "Leo",

  meaning: "Lion",

  starsWithPlanets: 19,

  quadrant: "NQ2",

};


axios.get(constellationsUrl).then(({ data }) => console.log(data));

axios.post(constellationsUrl, leo).then(({ data }) => console.log(data));

In the above code, the GET and POST requests are fired around the same time. It is not safe to assume that the GET request will finish first. Because both of these requests are asynchronous, it is uncertain when each will finish.

What if, instead of making each request separately, you wanted to order the requests? That is, what if you wanted to make sure that one request would happen after the other?

You could make that happen as follows:

axios.get(constellationsUrl).then(({ data }) => {

  console.log(data);

  axios.post(constellationsUrl, leo).then(({ data }) => console.log(data));

});

In the above code, you can be certain that the GET request will be logged first. However, you now end up with code that is a bit more complex. Multiple callback functions are nested inside of one another.

The code below demonstrates working code that will solve the constellation problem described earlier. In this code, a request is made to check whether or not the constellation already exists. Then, if it doesn't exist, the code will then create the new constellation.

axios

  .get(constellationsUrl)

  .then(({ data }) => {

    const exists = data.find(({ name }) => name === leo.name);

    if (exists) throw `Constellation "${leo.name}" already exists.`;

    return axios

      .post(constellationsUrl, leo)

      .then(({ data }) => console.log(data));

  })

  .catch(console.log);

Although this works, notice that the code above is a bit complex. The above code includes branching logic in addition to multiple callback functions. And just from quickly looking at the code, it's also a bit unclear what exactly the end result will be.

You can clean up this code in a number of ways. In this lesson, you'll learn how to clean it up using return values inside of then() and catch().
Do this
Run nested promises

Make sure that your Constellations server is up and running. Then, run the above code in a JavaScript file. Feel free to play around with the db.json file in the server to see a successful response and an unsuccessful response.
Returning values

The video below provides an introduction to returning values.

You can make promise code simpler by returning values inside of then() and catch(), as shown below:

axios

  .get(constellationsUrl)

  .then(({ data }) => {

    return data.find(({ name }) => name === leo.name);

  })

  .then((exists) => {

    if (exists) throw `Constellation "${leo.name}" already exists.`;

    return axios

      .post(constellationsUrl, leo)

      .then(({ data }) => console.log(data));

  })

  .catch(console.log);

In the above code, the search for the existing Leo constellation is separated into its own then() block. That value is then returned. The return value from the previous then() is then accessible as a parameter in subsequent then() method calls.

Whenever a value is returned inside of a then() or catch(), that value will be available to the next then().

Returning values allows you to make your code flatter; it reduces the number of nested callbacks needed to run your code.
Do this
Inspect return values

In a JavaScript file, copy and paste the code below. Take a moment to read through the code and understand what is happening, and then run it a few times.

new Promise((resolve, reject) => {

  const random = Math.floor(Math.random() * 10);

  random > 5 ? resolve(random) : reject(random);

})

  .then((response) => {

    console.log("Resolved!", response);

    return response;

  })

  .catch((response) => {

    console.log("Rejected!", response);

    return response;

  })

  .then((response) => {

    console.log("Add 10", response + 10);

  });

Notice that it doesn't matter whether the random number is resolved or rejected. In both cases, the final then() is called.
Omit returns

Try removing the return values from the code above. What happens to the final "Add 10" output?

You'll see that, without returning, the value that ends up in the final then() call is undefined.
Returning promises

When you return a promise, that promise is placed into the chain of events taking place with then() and catch(). If that promise resolves, it will move to the next then(). And if it rejects, it will move to the next catch().

axios

  .get(constellationsUrl)

  .then(({ data }) => {

    return data.find(({ name }) => name === leo.name);

  })

  .then((exists) => {

    if (exists) throw `Constellation "${leo.name}" already exists.`;

    return axios.post(constellationsUrl, leo);

  })

  .then(({ data }) => console.log(data))

  .catch(console.log);

The code above works as follows:

    A GET request is made to the constellationsUrl. If that request fails, the entire chain of then() calls is skipped, and the console.log() statement inside of catch() is called.

    The data is searched through to see whether or not there is a matching name. The record that's found is returned, or undefined is returned.

    If the constellation already exists, an error is thrown, skipping ahead to the catch(). If the constellation does not exist, a POST request is created and returned. If that request fails, the next catch() is called.

    The results of the POST request are logged. Specifically, the data key is logged.

When a promise is returned, the correct call of then() or catch() will be called next. Because of this, you don't have to place then() calls inside of other then() calls.

As shown above, the resulting code ends up being flatter as well as a bit more readable.
Complete example

A completed example from this lesson can be found here:

    Making Requests: Promise Chaining
*** Resolve and reject
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use resolve() and reject() to return promises with specific statuses and values.
Overview

Promises include class methods such as resolve() and reject(), which allow for you to write flexible asynchronous code. As you'll explore in this lesson, using these methods will make it easier to work with functions that encapsulate promise code.
Starter code

This lesson requires you to have the following GitHub repository running on your local machine.

    Constellations Server

Fork and clone the repository. Then, follow the instructions to get it to run.
Returning similar types

Take a look at the following function, which returns either a promise or a boolean.

const axios = require("axios");

const BASE_URL = "http://localhost:5000";


function update(id, body) {

  if (!id || !body) return false;

  const url = `${BASE_URL}/constellations/${id}`;

  return axios.put(url, body);

}

How might this function get used? Most likely, it will be used as shown in the code below:

const hydrus = {

  name: "Hydrus",

  meaning: "Water Snake",

  starsWithPlanets: 5,

  quadrant: "SQ1",

};


update("UPtAzfV", hydrus)

  .then(({ data }) => console.log(data))

  .catch(console.log);

This should work just fine—unless the id or body parameters are missing. Take a look:

update("UPtAzfV")

  .then(({ data }) => console.log(data))

  .catch(console.log);

//> Uncaught TypeError: false.then is not a function

Because the function returns false, it isn't possible to call then() on that value. This means that the update() function now has three possible states:

    An error occurs.

    A boolean is returned.

    A promise is returned.

Ideally, functions should always return either an error or a consistent data type (such as always returning a String), regardless of any conditions. This function must include an option to return a promise. Therefore, this function should be changed so that it no longer returns a boolean.
The resolve() and reject() methods

Although there are a few ways to solve the problem described above, one of the simplest solutions involves using the class method Promise.reject().

function update(id, body) {

  if (!id || !body) return Promise.reject(false);

  const url = `${BASE_URL}/constellations/${id}`;

  return axios.put(url, body);

}

Promise.reject() returns a promise with a status of rejected. Whatever is passed in as an argument will be what is accessible in the catch() callback function.

With this update, the code would work as intended even if one of the arguments to update() was missing.

update("UPtAzfV")

  .then(({ data }) => console.log(data))

  .catch(console.log); //> false

A similar class method is Promise.resolve(). This method will return a promise with a status of resolved. The argument passed to it will be accessible in the next then() statement.

Promise.resolve({ success: true }).then(console.log);

//> { success: true }
*** Promise.all
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use Promise.all() to resolve an array of promises.
Overview

In this lesson, you'll learn how to use Promise.all() to quickly display data from multiple requests.

Chaining promises lets you make a series of requests, one after another, knowing that each request will finish before the next one starts. But what if you want to make multiple requests at the same time, then wait for all of them to finish before doing something else?

Promise.all() solves this problem, making it possible to send multiple requests and receive multiple responses at the same time, even if you don't know the exact number of requests ahead of time. This lets you display data from multiple requests more quickly to the user.
Starter code

This lesson requires you to have the following GitHub repository running on your local machine.

    Constellations Server

Fork and clone that repository. Then, follow the instructions on how to get it to run.
Promise.all()

Promise.all() takes an array of promises as an argument, and returns a single promise that resolves when all the promises passed to Promise.all() have resolved. The fact that Promise.all() returns a promise means that you can chain a then() call after Promise.all() as follows:

const axios = require("axios");

const BASE_URL = "http://localhost:5000";


Promise.all([

  axios.get(`${BASE_URL}/constellations/UEUrlfX`),

  axios.get(`${BASE_URL}/constellations/zb8QvVt`),

  axios.get(`${BASE_URL}/constellations/32TN5F8`),

]).then(console.log);

If you run the code above, you'll see an array of three axios response objects gets logged to the console, one for each promise passed to Promise.all(). Here is how to access the data property of each result inside that array of response objects:

const axios = require("axios");

const BASE_URL = "http://localhost:5000";


Promise.all([

  axios.get(`${BASE_URL}/constellations/UEUrlfX`),

  axios.get(`${BASE_URL}/constellations/zb8QvVt`),

  axios.get(`${BASE_URL}/constellations/32TN5F8`),

]).then((results) => {

  console.log(results[0].data);

  console.log(results[1].data);

  console.log(results[2].data);

});

/*

  { id: 'UEUrlfX', name: 'Columba', ... }

  { id: 'zb8QvVt', name: 'Crater', ... }

  { id: '32TN5F8', name: 'Draco', ... }

*/

Note that the promise returned by Promise.all() will be rejected immediately if any one of the promises passed to Promise.all() is rejected. You can add a catch() call after then() to handle that contingency.
Unknown number of promises

What if you need to make an unknown number of requests, and wait for all of them to resolve before doing something else?

For example, imagine that you want to build a function that takes in an array of IDs. For each of those IDs, a request will be made to get information about that record.

const axios = require("axios");

const BASE_URL = "http://localhost:5000";


function getConstellations(ids) {

  // ??

}

You don't know how many IDs will be passed to the getConstellations() function. However, you can use each of those IDs to create an array of promises. Then, you can pass that array of promises to Promise.all(), which returns a promise that gets returned by the getConstellations() function. So, getConstellations() returns a promise that resolves once all the requests resolve.

function getConstellations(ids) {

  const promises = ids.map((id) => {

    const url = `${BASE_URL}/constellations/${id}`;

    return axios.get(url);

  });


  return Promise.all(promises);

}


const ids = ["KGQIwSq", "32TN5F8"];

getConstellations(ids).then(console.log);

/*

  [

    { name: "Eridanus", ... },

    { name: "Draco", ... }

  ]

*/

In the code above, the following happens:

    The incoming ids array is mapped over. An array of equal length is returned, with each element being a GET request.

    The array of promises is passed in to Promise.all().

    The return result of that value is returned. Once all of the promises have been fulfilled, the then() method will be called.

Of course, as mentioned previously, if any of the asynchronous requests fail, the entire getConstellations() function call will fail.

const ids = ["KGQIwSq", "32TN5F8", "wrong-id"];

getConstellations(ids).then(console.log);

In the code above, nothing would get logged because "wrong-id" isn't a valid ID. This means that you would lose access to all of the other responses, even if they were successful.

Note that Promise.allSettled() is an alternative to Promise.all() that always returns the result of each individual promise, including whether the promise was fulfilled or rejected.
*** Async and await
1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to use async and await to write modern, synchronous-looking code.
Overview

In this lesson, you'll learn how to use the async and await keywords. These keywords use promises but will allow your asynchronous code to look more synchronous.

At this point, you've learned a lot about promises. You know that promises manage asynchronous code, and you know that then() and catch() can be used to extract values from promises.

You've also learned about a few different types of class methods, like Promise.resolve(), Promise.reject(), and Promise.all(). These class methods will help you write code that is cleaner and more flexible.

You're now ready to learn about one of the most powerful tools that involves promises: the async and await keywords.
The async and await keywords

The async keyword is applied to a function. On its own, the async keyword transforms the function so that when the function is invoked, the return value will be wrapped in a promise, like this:

const axios = require("axios");

const BASE_URL = "http://localhost:5000";

async function getConstellation(id) {

  //> Placeholder function body

  return true;

}


getConstellation().then(console.log); //> true

This on its own is pretty interesting. But async also gives you the ability to use the await keyword inside of your function body. So, what does the await keyword do?

Take a look at the example below and see if you can determine what's happening.

async function getConstellationNameById(id) {

  const url = `${BASE_URL}/constellations/${id}`;

  const { data } = await axios.get(url);


  return data.name;

}


getConstellationNameById("n2OEOzp").then(console.log);

//> "Libra"

As you may have figured out from the above code, the await keyword allows you to treat asynchronous requests as if they were synchronous!

Using the await keyword before axios.get() forces the execution of the code to pause until that asynchronous operation is finished. Once it is, you can then use the resolved response.

In the case above, the object returned by axios has a data key, which you can then immediately use. You can then access it like you would any other object, without having to use then() and catch().

It's important to note that whatever comes after await should be a promise. This means that await will work with class methods like Promise.all().
Error handling

When the promise that follows await is resolved, your code will end up looking like synchronous code. However, what happens when the promise is rejected?

Instead of using catch(), the code will throw an error. This means that when you use async and await, you should also use try and catch, like so:

async function getConstellationNameById(id) {

  const url = `${BASE_URL}/constellations/${id}`;

  try {

    const { data } = await axios.get(url);

    return data.name;

  } catch (error) {

    throw `Constellation with id of ${id} could not be found.`;

  }

}

If the GET request fails, the error will be caught, and a new, custom error will be thrown.

And yet, the code above can be used like any other promise, as follows:

getConstellationNameById("n2OEOzp").then(console.log);

//> "Libra"


getConstellationNameById("error").catch(console.log);

//> Constellation with id of error could not be found.

With async and await, you can update your code so that asynchronous code can look more similar to your synchronous code.
Caveats

Using async and await can feel like magic, but it really isn't. Keep in mind the following issues or misconceptions that can arise when using async and await.
Awaiting asynchronous operations on their own

You may assume that, with the await keyword, you can treat all asynchronous calls as if their values were immediately available. But this isn't quite true. Take a look at the following:

async function getConstellationNameById(id) {

  const url = `${BASE_URL}/constellations/${id}`;

  try {

    return await axios.get(url).data.name;

  } catch (error) {

    throw `Constellation with id of ${id} could not be found.`;

  }

}

In the above code, an assumption is made that the code will pause for axios.get(url), and only then will it evaluate data.name. This isn't true, and the operation will fail.
Returning awaited code

Although it won't cause an issue, there is no need to return an awaited response. There is no difference between returning a promise or returning an awaited promise.

async function getConstellationNameById(id) {

  const url = `${BASE_URL}/constellations/${id}`;

  try {

    return await axios.get(url);

  } catch (error) {

    throw `Constellation with id of ${id} could not be found.`;

  }

}

In the above code, regardless of whether or not await is before the axios request, this function will return a promise. In fact, async is also unneeded here.

The async and await keywords are useful when you want to perform additional operations on the values returned from promises. So if you don't care about the return value in a specific function, you don't really need them.
** unsorted

1. Understand the problem - aka "reflect the question back into your our words."
    -  Do you understand all the words used in stating the problem?
    -  What are you asked to find or show?
    -  Can you restate the problem in your own words?
    -  Can you think of a picture or diagram that might help you understand the problem?
    -  Is there enough information to enable you to find a solution?

2. Devise a plan - aka "Pseudocode"
    * Guess and check           |   * Look for a pattern
    * Make an orderly list      |   * Draw a picture
    * Eliminate possibilities   |   * Solve a simpler problem
    * Use symmetry              |   * Use a model
    * Consider special cases    |   * Work backwards
    * Use direct reasoning      |   * Use a formula
    * Solve an equation         |   * Be ingenious

3. Carry out the plan - aka "code your Pseudocode"
    * Third. Carry out your plan.
    * Carrying out your plan of the solution, check each step. Can you see clearly that the step is correct? Can you prove that it is correct?

4. Look back - aka "refactor"
    * Fourth. Examine the solution obtained.
    * Can you check the result? Can you check the argument?
    * Can you derive the solution differently? Can you see it at a glance?
    * Can you use the result, or the method, for some other problem?

Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly

different type data type
loop over objects
destructing
rest
scope
array method
arrows function
git, github
