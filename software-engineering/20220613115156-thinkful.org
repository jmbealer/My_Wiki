:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]


Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly

* mod 3 JavaScript on your machine


** javascript with node

REPL stands for read, evaluate, print, and loop.
REPL is a program that will allow you to run code and see the output from it.
REPL use to run short snippets of code.
can't save using a repl
The Node REPL is particularly useful for trying out snippets of code, such as short functions, methods, or statements.

node - runs the js repl


Multiple lines of code
You can write multiple lines of code in the REPL.
If you do so, you will need to be careful about your curly braces {} and parentheses (), because you cannot go up a line.

Writing multiple lines will look like this:
Writing a function in the REPL
As you can see, three dots ... denotes that you are currently writing a statement that has not yet ended.
You will see this same thing if you were to write an if/else statement or for loop.

Quitting the REPL
To quit the REPL, you have three options:
Press Control+D (or Command+D on a Mac).
Press Control+C (or Command+C on a Mac) twice.
Type .exit.

Running JavaScript files

touch myFile.js - create a javascript file named myFile
node myFile.js - run a javascript file named myFile

From the command line, you can then run this file with Node by running the following:

node ~/thinkful/my-other-file.js

** automated testing primer

Writing code is about solving problems without creating new problems (bugs).

Unit test A test that checks a small piece of code, generally a single function
These tests can help you understand when your code is working as requested and when it is falling short.

Automated testing: The practice of running tests against your code using automated software, with the overall goal of creating high-quality, error-free code

Understanding how testing works is therefore crucial for your success both as a student and in the workforce.

Intro to automated testing
Automated testing helps developers recognize issues as they occur so that the issues can be remediated before the software is released into production.
It's typically easier and less expensive to identify and fix an issue before rather than after putting the software in the hands of end users.

The majority of the assessments in this program contain automated test code.
The benefit of this approach is that you can get immediate feedback on your code and identify errors in your programs prior to submitting your work.

Although there are many different types of automated tests, the majority of the tests that you will encounter in this program are unit tests, which are one of the most common types of automated tests in the industry.

Unit tests are automated tests created by software developers to test the individual parts of a program.
They ensure that the program does what it's designed or programmed to do.
Each unit test tests only a small part of a program, which makes it easy to track down where the issues are.


Folder structure for a typical Eng assessment
The two folders of interest here are the src and the test folders.

The src folder (also called the source folder) is the folder where you will usually be asked to provide your solution code, inside either a single file or multiple files.

The test folder is the folder that stores the test file (or test files) for the assessment.
Test files are generally stored in a folder labeled test (or some variation of this name) for easy reference.
Note that the names of test files typically end with the .test.js extension so that the computer can easily identify them.

Whenever you run the automated tests, your computer will find and execute the test files, which will in turn import and test the code that you wrote inside the src folder.

While you're working on an assessment, feel free to look at the contents of the test files, but don't worry about trying to understand what each line of test code is doing for now.
For now, just keep in mind that the test files contain a set of instructions on how to test your code.

Automated test output
Whenever you run the tests for each assessment, you will be presented with some output in the terminal (if you're running the tests locally) or in the Qualified window (if you're using the qualified-attach command).
The test output will indicate whether or not you're on the right track with the assessment, so it's important that you understand how to interpret the basic parts of the test output.

Automated testing is an important technique in software development, and knowing how to interpret basic test outputs is a good first step to mastering this skill, which you will continue to develop throughout the program.

** environment variables and script arguments

Environment variable Also called an env var, a key-value pair held by your current operating system and user
Command-line script Also called a script or a command-line program, a reusable program that can be run on your command line

Running JavaScript on your computer instead of on the web comes with some advantages.
 Node has access to the environment variables running on your machine, which allows you to customize the JavaScript programs that you write.
 Additionally, Node lets you parse arguments used with the Node command.
 This allows you to write command-line programs.

You are learning about environment variables and script arguments now because they are used sparingly when learning to build servers or running React.

Environment variables
Your computer currently has several stored variables that help it run.
Just like JavaScript variables, these environment variables have a name and point towards a specific value.
Environment variables, or env vars, are key-value pairs held by your current operating system and user.
Like variables in JavaScript, they are used to perform and configure certain actions.

The convention is that all environment variables are written in screaming snake case.
 In other words, letters are capitalized and separated by underscores, like this: ENV_VAR.



env Echo environment variables
You can print a value to the terminal by using the echo command.
Choose one of the variables from the list above and print it out, replacing ENVIRONMENT_VARIABLE in the code below with the name of the variable.

echo $ENVIRONMENT_VARIABLE
Use environment variables with JavaScript
Whenever you run a JavaScript file with Node, it gives you access to a number of global variables.
One of those variables is process, which is an object.

For this program and the majority of web development, you can ignore most of what is in the process object.
However, there are a couple of keys in this object that can be useful for building different types of programs.
One of those keys, .env, gives you access to all of the environment variables on your system.


console.log(process.env);
Run the file using the node command.
You will see that process.env prints another object.
Update your code above to print a single environment variable from this object. (Be careful about the capitalization!)

Set temporary environment variables
You can also temporarily set an environment variable, just for however long it takes to run the program.
Update your file to include the following:

console.log(process.env.NODE_ENV);
Then, run the command shown below, replacing <filename> with a path to your file.

NODE_ENV=development node <filename>
You will see the word development printed back to your terminal. If you run the file without setting the environment variable, you won't see anything printed to your console.

Script arguments
Node also allows you to build complex command-line scripts with JavaScript.
A command-line script, also called a command-line program or simply script, is an often small program that can be run on your command line to achieve any number of effects.
You can think of it as a function for the command line.

Command-line scripts can be used to do just about anything, from creating a new HTML and CSS project to printing out a fun message.
Often, command-line scripts contain arguments, just like functions do.
Whereas a function has parameters that are a part of the function's definition, a Node script with arguments might look like the following:

node plant-facts.js "Pretzel Bean"
In this case, there is a single argument: "Pretzel Bean".

You can access what was run on the command line through the process object as well. Running process.argv will print an array of what was on the command line, separated by spaces.

For example, for the above line, process.argv would print the following:

[
  "/Users/your-username/.nvm/versions/node/v13.12.0/bin/node",
  "/Users/your-username/path/to/your/plant-facts.js",
  "Pretzel Bean",
];
In the above array, you can see the following:

The full path to the node command

The full path to the plant-facts.js file

"Pretzel Bean", which was the argument

It is important to note that the quotation marks in the command matter! Instead of the above, imagine that you ran the following command:

node plant-facts.js Pretzel Bean
The output of process.argv would be as follows:

[
  "/Users/your-username/.nvm/versions/node/v13.12.0/bin/node",
  "/Users/your-username/path/to/your/plant-facts.js",
  "Pretzel",
  "Bean",
];
Notice that it now sees Pretzel Bean as two distinct arguments.

** modules

Learning Objective
By the end of this lesson, you will be able to create and connect your own modules.

Overview
Using JavaScript with Node is quite powerful. However, this combination can become even more useful when you add Node modules into the mix. In this lesson, you will learn about local modules, which are one of the three different types of modules. At this point in your journey, learning how to make use of modules will allow you to better organize the JavaScript code that you write on your machine.

What is a module?
In Node, each file is treated as a separate module. A module, sometimes also referred to as a package, can contain any JavaScript code. It most commonly exports an object or a function. The exported value then becomes available in other modules.

Put simply, each file in a Node project is its own module. You can then export data from that file to be used in another file.

Do this
Create a new folder
In this lesson, you will be asked to make a few different files to practice the concepts that you are learning. Create a new folder with a memorable name, like learning-node-modules/.

Local modules
The best way to understand modules is to create and use them. For example, take a look at the following code. Imagine that it is in a file called plants.js.

function findPlantById(plants, id) {
  let result = null;
  for (let i = 0; i < plants.length; i++) {
    let plant = plants[i];
    if (plant.id === id) {
      result = plant;
    }
  }
  return result;
}

module.exports = findPlantById;
The above function expects an array of objects as the first argument passed to the function, where each object has an id. It then accepts an id. The function then loops through all of the plants and returns the one that has a matching id. If none match, it returns null.

At the end of the code block shown above, you may have noticed the following line:

module.exports = findPlantById;
This line indicates that the file is a module. A function is being exported from this file.

You can use this function in another file. For example, take a look at the following code. Imagine that it is in a file called main.js.

let find = require("./plants");
let plants = [
  { id: 1, name: "Garden Rocket Arugula" },
  { id: 2, name: "Watercress" },
  { id: 3, name: "Royal Rose Radicchio" },
];

const result = find(plants, 2);
console.log(result);
The new and important part of the code above is the require() function. The require() function takes a path as an argument. If no file extension is given, it will assume that the file is a JavaScript file. It looks into that file and then finds what is exported, and whatever is exported is returned from the require() function.

So, in the above file, the following happens:

The findPlantById() function is imported from the plants.js file. Notice that it is assigned to a new name, find, although it can be assigned any name.

A plants variable is declared, which points to an array of objects with IDs.

The find() function is called with the appropriate arguments.

Do this
Create a module
In the folder that you've created, create two new files: plants.js and main.js. Copy the above content into the files as appropriate, and then run the main.js file.

You will see the following output:

{ id: 2, name: "Watercress" }
View the default value
In your plants.js file, comment out the line that is exporting the function, as follows:

// module.exports = findPlantById;
Then, at the top of your main.js file, add the following line:

console.log(require("./plants.js"));
What do you see? You should see an empty object. By default, if you require a file that doesn't have a module.exports statement, you will receive an empty object.

Now, undo the changes that you made in this step.

Export an object
After you've undone the changes from the above task, update your plants.js file with the following export statement. This export statement should replace the one that you already have.

module.exports = { findPlantById: findPlantById };
Now, you are exporting an object instead of a function. How would you update your code in main.js so that you can still call the function?

There are a few ways that could work, but one option is to update the code as follows:

let plantFunctions = require("./plants");
let plants = [
  { id: 1, name: "Garden Rocket Arugula" },
  { id: 2, name: "Watercress" },
  { id: 3, name: "Royal Rose Radicchio" },
];

console.log(plantFunctions.findPlantById(plants, 2));

** the package.json file

Configuration file Any file that's necessary to run an overall project but may not have explicit code inside of it

Each folder that you create and plan to run with Node can be considered a Node package or project.
These projects can contain a configuration file, package.json, which gives additional information about the project.
This configuration file also allows for some interesting functionality through the use of npm, the command-line tool that you installed at the beginning of this module.

Configuration files
So far, the files that you've created have been JavaScript files that you've been able to run with Node.
These files are, obviously, critical to running code in that they have code in them.
As you advance throughout this program, you will also come across a number of configuration files, which are essential to larger projects.
Configuration files can generally be described as any file that's necessary to run an overall project but may not have explicit code (functions) inside of it.

For example, your text editor (whether it's Visual Studio Code, Sublime, or something else) likely has a settings file that defines how your text editor works. These settings may determine how your code is spaced or what colors your text editor shows. These settings don't explicitly run your text editor, but they do shape how the text editor is run.

The package.json file
For Node projects, the main configuration file is the package.json file. This file contains meta information about the project and allows you to customize some commands that can be run.

The package.json file can be created through npm. After navigating to the folder where you want to create your project, you can create a package.json file by running the following command on the command line:

npm init -y
The above command will create a new package.json file in the directory where it was run. It will also fill in some default values.

Note: Each Node project should only have a single package.json file.

Do this
Create a package.json file
Create a new directory called first-package-json on your computer. On your command line, navigate to that directory and run the above command to create a package.json file.

Take a look at the file that was just created. Note that it looks similar to a JavaScript object.

JSON
The file that you created isn't a JavaScript file—it's a JSON file. JSON stands for JavaScript Object Notation, which is different from JavaScript. JSON looks like a JavaScript object but has more limitations. In particular, when writing JSON, you must consider the following:

All keys in a JSON file must be wrapped in quotations.

A JSON file cannot include JavaScript comments or variables. Instead, the file must only contain a single JavaScript object.

Values such as booleans, numbers, strings, arrays, and other objects are valid in JSON.

Keys
If you used the command suggested earlier in this lesson, your package.json file will look something like this by default:

{
  "name": "first-package-json",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
All of the above keys are optional. But there are a few that you will want to keep—especially the following:

name: This is the name of your package. By default, it will take the name from your folder's name.

description: This is a description of your project. You can place whatever you want here.

scripts: This is where you will set up scripts to be run through npm. You will learn more about scripts below.

You can learn more about the package.json file and other keys in the package.json documentation.

Scripts
Right now, one of the most useful skills that you can learn is how to build scripts with the package.json file. The scripts key has a value that is an object. Each key in that object is the name of a script that can be run from the command line. The value associated with that key is a string containing any valid command-line code. Running that script with npm will execute the code on the command line.

For example, take the following default script:

{
  "test": "echo \"Error: no test specified\" && exit 1"
}
This script can be run with the following command:

npm run test
When the above command is run on the command line in the folder where the package.json file exists, it will run the value as a script. Here's an example:

Example of running npm test
After npm run test was run, the value of the test command was run. That is, a specific message was echoed.

You can create new scripts by adding new key-value pairs. For example, the following script will simply run the pwd command on the command line.

"print-working-directory": "pwd"
To run the command, you would type the following:

npm run print-working-directory
Note: If you try to include the above script, make sure to use the correct syntax for your JSON file.

Do this
Run JavaScript with npm
In the first-package-json folder, create a new file called main.js. Add the following code to it:

console.log("Hello, world!");
Then, add a script called dev that will run the following command:

node main.js
Afterward, on the command line, you should be able to run the following command and see "Hello, world!" printed to the console.

npm run dev
Default commands
The npm program expects you to use some common terms like start and test. For these common terms, you can skip the run part of the command.

npm test
However, you will still need to use the run part of the command for custom scripts.

npm run dev
More of the supported scripts can be found in the npm scripts documentation.

** installing packages


Open-source Code that is available to be viewed, downloaded, and edited by anyone

The npm tool can help you install and manage these packages.

Viewing packages
https://npmjs.com/ - where javascript packages can be found


Moment
Take a look at the Moment package.
This page shows you information about how to install the package, how it can be used, and various statistics on the package's usage.
For example, this package describes itself as "a lightweight JavaScript date library for parsing, validating, manipulating, and formatting dates."

You also can see that this package has been downloaded often and has been updated recently.
When you're assessing whether or not to use a package, it is a good idea to look at these statistics.

Note: You may notice from the documentation that the Moment package is now a legacy project and is no longer being updated. However, Moment continues to be a very popular and useful package, and you'll work with it throughout this lesson.

Reading documentation
You learned that the Moment package can help parse and format dates in JavaScript.
How does it do this? To answer this question, you will need to read the documentation.

So far, you have likely only seen documentation on the official JavaScript language from MDN.
MDN is a great resource, but it doesn't contain documentation on packages.

Now, you will need to look instead at the specific package and its documentation.
Thankfully, Moment has fantastic documentation, which can be found at Moment's website.

Reading documentation is its own skill, and it can be challenging at first. As you come across phrases and terms that you don't understand, you will need to be patient and look up new concepts.

Installing
You can install a package with a simple npm command:

npm install <package-name>
npm i <package-name>

Running this command (while changing <package-name> to the name of the package) will do the following:
If a node_modules/ folder doesn't already exist, a node_modules/ folder will be created in the current directory.
If a package-lock.json file doesn't already exist, a package-lock.json file will be created in the current directory.
If a package.json file does already exist, the package and its version number will be recorded in the package.json file.
The package will be downloaded from the web to your computer.
In general, you always want to have a package.json file before running any install commands.


Do this
Create a JavaScript project
First, complete the following steps:

Create a new directory called installing-packages.

Then, create a package.json file and a main.js file.

In the package.json file, create a start script that runs your main.js file with Node.

Finally, include the following in your main.js file:

console.log("The current date is: " + Date.now());
When you run your script, you will see something like the following show in your terminal:

The current date is: 1592329893846
Install the Moment package
The above date isn't very useful! Instead, try using the Moment package. Install Moment using the following command:

npm install moment
Then, require the Moment package in your main.js file:

let moment = require("moment");
Run your code and confirm that the output looks the same as it did before.

Use Moment
Now it is time to actually use Moment. Before looking at the solution below, try reading the Moment documentation yourself, and look for how you might display a more human-readable date format.

If you're having a hard time, try looking at the display format section of the documentation. As you can see, there are actually several ways to display dates with Moment.

If you're still having trouble, you can replace your console.log() statement with the following:

console.log("The current date is: " + moment().format("MMMM Do, YYYY"));
Dependencies
Whenever you install a package with npm install or npm i, the installation will be recorded in your package.json file under a key titled dependencies. It will look something like this:

"dependencies": {
  "moment": "^2.26.0"
}
The string value next to the package name is the version number for that package. If you are interested in the version number syntax, you may optionally read more about it in the package.json dependencies documentation.

Developer dependencies
In the future, you may also see a command like this:

npm install <package-name> --save-dev
The --save-dev flag will be included for packages that are necessary only for the development of the project, not for running it. Packages installed with that flag will show up under the devDependencies key instead of dependencies.

The reason behind this will be explained whenever it is asked of you. For now, just keep in mind that you may see this flag.

The package-lock.json file
The package-lock.json file is automatically created whenever you install a package. Similarly to package.json, package-lock.json is a configuration file.

The difference is that you will never need to edit this file. The package-lock.json file is essentially metadata for package.json. Although it is required, it does not require any management by you.

You can read more about the package-lock.json file in the package-lock.json documentation.

Node modules
When you install a package, that package's code will be added to a node_modules folder. Modules that aren't created by you or installed in Node will be contained in this folder.

As you'll see, the installed packages also have a package.json file. If the installed package has its own dependencies, those packages will also be installed.

You can delete the node_modules folder at any time and reinstall the packages by using the npm install command without providing a package name. By default, npm install will install everything listed in your package.json file.

Do this
Browse the node_modules/ folder
Take a look inside the node_modules/ folder inside your installing-packages/ directory. You will see a single folder: moment/.

Look around the folder briefly, and try to find the package.json file. As you can see, Moment is just another Node project, like the one that you have!

** Assesment: JavaScript on your machine

* mod 4 JavaScript foundations

** error types
*** Runtime errors

errorType: description of the error
SyntaxError: function statement requires a name

*** Reference errors

Reference error - An error that occurs when some variable being referenced doesn't exist or can't be accessed

In console.log statement the variable customerName is misspelled

A reference error tells you that some variable being referenced doesn't exist.
You can fix this kind of error by finding the offending reference and checking for the correct name.

But a ReferenceError could also surface if the variable cannot be accessed at all.

In the above example, the result variable does exist, but it exists only inside the addSalesTax() function.
Attempting to access that variable outside of that function would lead to a ReferenceError.
(This is because of a concept called scope, which you'll learn about later in this module.)

#+begin_src js
// reference error caused by misspelling variable name
const customerName = "Alfie Lee";
// customerName is mis-spelled
console.log(customrName); // returns ReferenceError: customrName is not defined

// reference error caused variable can't be accessed
function addSalesTax(total, salesTax) { //func takes parameters total and salesTax
    let result = total * (1 + salesTax); // declare result asign total times (salesTax plus one)
    return result; // return results
}
// trying print result but result but result only exist is local scope of function
console.log(result); //returns ReferenceError: result is not defined
#+end_src

*** Syntax errors

Syntax error - An error that occurs when some part of the predefined JavaScript syntax is being used incorrectly

A syntax error will occur when some part of the predefined JavaScript syntax is used incorrectly, such as a character is used twice or not used at all.
These errors are common for developers due to the simple fact that coding uses many symbols and characters that people don't otherwise use.
For instance, because curly brackets {} are unusual in regular typing, it can be easy to forget one.

Take a look at the following code. Can you find what's missing?

function printWelcome () {
  console.log("Welcome to our store!";
}
Above, you'll see that the console.log() statement is missing a closing parenthesis ).
The error that would surface because of the above code would be as follows:

SyntaxError: missing ) after argument list
Although that message is fairly straightforward, it often isn't that simple.
It can be challenging to actually resolve a SyntaxError with longer, more complex code.
In the case of a SyntaxError, you often just need to look through your code patiently and carefully for the missing or extra symbol.

Correctly indenting your code and using a code formatter can be useful for identifying (and preventing) issues like this.
For example, take a look at the following code.

function openInstructions (weather, temperatureInCelsius) {
if (weather && temperatureInCelsius) {
  if (weather === "sunny") {
  if (temperatureInCelsius > 20) {
    return "Set up the patio and put out umbrellas. Open indoor windows.";
  } else { return "Set up the patios, umbrellas optional. Open indoor windows."; }
  } else if (weather === "rainy") {
    if (temperatureInCelsius > 10) {
      return "Open indoor windows slightly.";
    } else { return "Keep windows closed." } }
  }
} else {
  return "Please set the `weather` and `temperatureInCelsius` variables.";
}
}

openInstructions("sunny", 18);
If you were to run the above code, you would receive this message in the console:

SyntaxError: expected expression, got '}'
That isn't very helpful, and you'd have to do the legwork of resolving the issue.
This is one of the many reasons that it's important to write your code legibly.

*** Type errors

Type error - An error that occurs when you misuse a data type in JavaScript, meaning that an operation can't be performed

And finally, you'll learn about the TypeError.
A type error will occur when you misuse a data type in JavaScript, meaning that an operation can't be performed.
One of the most common ways that this error will occur is through a situation like this:

price.trim(); //> TypeError: price.trim is not a function
As it turns out, the trim() function, when called on a string, removes extra whitespace from the beginning and the end of that string.
So in this case, why would price.trim() not be a function? Well, this error is likely telling you that price isn't actually a string.

To better understand what's going on, take a look at the whole picture:

let price = 9.99;
price.trim(); //> TypeError: price.trim is not a function
You might expect this error to tell you that price isn't the right data type, rather than telling you that trim() isn't a function. To better understand why the error is described the way it is, try running the following code:

let price = 9.99;
console.log(price.trim); //> undefined
You may be surprised to find that calling trim as a property on price doesn't fail—instead, it returns an undefined. But when you try to invoke the undefined property, that is when you get your error.

*** Silent errors

Silent error - An error that doesn't immediately surface when the code is run

The three errors described above are caught and revealed to you when you run your JavaScript code. However, it's also possible for errors to occur as you are writing code but not immediately surface when you run it. This type of error is called a silent error.

For example, take a look at the following code. Do you see any problems?

function formatPrice(priceInCents) {
  let formattedPrice = "$" + (priceInCents / 100).setFixed(2);
  return formattedPrice;
}
You may not notice any issues with this code right off the bat. And even when you run this code sample, no errors will surface. It is only when you invoke the function that you will see the error:

TypeError: (priceInCents / 100).setFixed is not a function
In this case, the function uses setFixed(), which is not a function, instead of toFixed(), which is a function. When working with complex applications with multiple functions, you'll need to be aware of silent errors like this one.

** variables

In your earlier work with JavaScript, you practiced the basics of declaring variables with the let keyword.
But that was just the beginning! In this lesson, you'll learn about two other methods of declaring variables, and you'll explore when you should use each approach.

The let keyword

As you've learned, the let keyword is used to declare variables in JavaScript. Here's some refresher code for your review:

let price = 9.99;

You can also reassign variables that have already been created using let. Here's an example:

let price = 9.99;

price = 8.5;

However, if you declare a variable with let, you cannot use let to later define that same variable. See the error below:

let price = 9.99;

let price = 8.5; //> Uncaught SyntaxError: Identifier 'price' has already been declared

This SyntaxError is pretty useful. It will stop you from accidentally recreating the same variable later on in your program when you don't intend to do so.

But here's something that might surprise you: let is actually a fairly new feature of JavaScript. Now, you'll take a step back to learn about two other variable-declaring features: var and const.
The var keyword

In the past, variables were declared with the keyword var. Here is what var looks like in action:

var productName = "Jogger Sweatpants";

Just like with let, variables created with the var keyword can be reassigned. However, var doesn't have the same restrictions as let when it comes to declaring variables with the same name. See the example below:

var productName = "Jogger Sweatpants";

productName = "Men's Jogger Sweatpants";

var productName = "Woman's Jogger Sweatpants";

Because var is an older method of declaring variables, you will often see var referenced in older code. However, you shouldn't use var in your code unless you have a very specific reason to do so. This lesson aims only to briefly introduce you to the concept of var and how it works. Later in this program, you will learn more about when, where, and why you might use var in your work.
The const keyword

At first blush, the const keyword may seem very similar to let. Using const, you can declare variables much like you would with let. And just like let, you also can't use it to create another variable of the same name.

const size = "M";

const size = "L"; //> Uncaught SyntaxError: Identifier 'size' has already been declared

However, with const, you also can't reassign the value. See below:

const size = "M";

size = "S"; //> Uncaught TypeError: Assignment to constant variable.

Ultimately, there is no performance benefit to using one method over another—const, let, and var will each allow you to declare a variable, which is what you want to do. But there is a workflow benefit. The intended purpose of both const and let is to help developers make fewer mistakes.

By allowing developers to create variables that cannot be declared again, const and let act a bit like a safety net. As you develop larger applications, you will find it challenging to create concise, descriptive, and unique variable names. Often, developers will attempt to use a variable name in their code, forgetting that they've already used that variable name higher up. That's where const and let can help. They prevent developers from making unintended mistakes when declaring their variables.
Warning: Using const with arrays and objects

But const also has some other traits that are worth discussing. And when it comes to arrays and objects, using const can be a bit tricky.

Take a look at the following code. It works as you may expect:

const product = { priceInCents: 2100, name: "Yellow Beanie", size: "M" };


product = { priceInCents: 2100, name: "Red Beanie", size: "L" };

//> Uncaught TypeError: Assignment to constant variable.

In the above case, you aren't able to reassign the value of const, as intended. The following code, on the other hand, does run.

const product = { priceInCents: 2100, name: "Yellow Beanie", size: "M" };

product.name = "Red Beanie";

product.size = "L";

Although you can't reassign the variable completely with const, you can change the values inside of the object. The same goes for arrays. Take a look:

const sizes = [8, 10, 12, 14];

sizes[4] = 16;

The reasons behind this behavior will be covered in a later lesson. For now, you're just getting familiar with the way that const works.
What method should you use?

At this point, you might be wondering which method of declaring variables you should use. Here's the process that you should follow when determining whether to use let, const, or var:

    Use const primarily; this will be your go-to. Moving forward, you'll want to declare most of your variables using const.

    Use let if you need to reassign a value. This is a common requirement during for loops and sometimes with if statements.

    Don't use var unless necessary, like when working in a codebase that uses it. However, that will likely only happen in the distant future. As mentioned above, there are other reasons to use (and to not use) var, but those will be covered in a different lesson. For now, just avoid it.

    var makes variable global even in functions

** strings

1.5 hoursAverage Reading Time
Learning Objective

By the end of this lesson, you will be able to access parts of a string with bracket notation and methods. You'll also be able to create an array from a string, join arrays into strings, and write strings that embed expressions using template literals.
Overview

In this lesson, you'll learn more about how to write strings in JavaScript and explore new ways to access different parts of a string. You'll also learn how to transform a string into an array.
Key Terms

Template literal
    A JavaScript feature that makes string concatenation, embedded expressions, and formatting easier

Remember when you first started learning about JavaScript data types? Now that you're familiar with some of the basics, you're ready to dive deeper into one specific data type: the string.
Accessing strings

As you know, a string data type is used to represent text. Strings are set off in quotes, and they can contain a variety of characters, such as letters, numbers, and symbols. So when it comes to accessing strings, you'll essentially be targeting individual characters in order to perform a specific task.

Take a look at the following string. What do you see?

const pangram = "The Five Boxing Wizards Jump Quickly.";

As you may have noticed, the pangram string uses every letter of the alphabet. The string is also written in Title Case—in other words, the first letter of every word is uppercase. Imagine you want to update this string so that it's in Sentence case, which means that only the first letter of the sentence is uppercase. How might you do that? You'd follow these general steps:

    Make sure that the first letter of the sentence is uppercase.

    Make all other letters lowercase.

To do this, you'll need to access individual characters in the string.
Characters: A refresher

Before moving forward, you may need a quick refresher on characters. As mentioned above, characters in strings can be alphanumeric characters, punctuation marks, spaces between words, or other types of symbols that increase the length of the string. Consider the example from above:

const pangram = "The Five Boxing Wizards Jump Quickly.";

pangram.length; //> 37

The pangram string is 37 characters long. That includes the period . and empty spaces between words, but not the double quotes (" and ") enclosing the string. You'll learn a bit more about how to work with quotes in strings below.
Bracket notation

Back to the task at hand: changing this string from title case into sentence case. One way that you could do this is by using bracket notation. Just like with arrays, bracket notation can be used to access individual characters at any given index of a string. Here's an example of how bracket notation can be used:

const word = "Wizards";

word[0]; //> "W"

word[2]; //> "z"

word[9]; //> undefined

Now, take a look at the following function, which will solve the case problem that you've been given. What do you notice?

function sentenceCase(sentence) {

  const firstCharacter = sentence[0];

  let result = firstCharacter.toUpperCase();


  for (let i = 1; i < sentence.length; i++) {

    const character = sentence[i];

    result += character.toLowerCase();

  }


  return result;

}

Take a moment to walk through the above code. Here's what it's doing:

    It creates a new variable called firstCharacter. It sets firstCharacter to be equal to the first character of the inputted sentence string, using bracket notation.

    It creates a new variable called result. It sets that variable to be equal to the firstCharacter variable, set to uppercase with the toUpperCase() method.

    It begins a for loop, which starts at an index of 1, thus skipping over the first character of the sentence.

    In the for loop, the variable character is created, which is set to be equal to sentence[i]. With bracket notation, you can access each character of a string, just like you would each item of an array.

    The code adds the character to the result variable, setting it to lowercase at the same time.

    Finally, return result will return the result for you.

The substr() method

But bracket notation is just one approach. You can also solve your casing problem using a built-in JavaScript method, called the substr() method, which will actually make this process a little easier. Check out the code sample below:

function sentenceCase(sentence) {

  const first = sentence.substr(0, 1);

  const rest = sentence.substr(1);


  return first.toUpperCase() + rest.toLowerCase();

}

The substr() method, also called the substring method, allows you to extract a specific section of characters in a string. It takes two arguments:

    The index of the first character to include in the substring

    The number of characters to extract

The above function works as follows:

    It sets the first variable to be equal to only the first character. In other words, substr(0, 1) means that the substring will begin on index 0 and only include 1 character.

    It sets the rest variable to be equal to every character starting from the first index. If you do not include a second argument, like in substr(1), the substring will consist of every character following the given index.

    It joins the two strings together, using toUpperCase() and toLowerCase() as appropriate.

Do this
Use substr()

Time to try it yourself. Take a look at the following examples of substr(). Before running the code on your own, evaluate the code in your head and predict what will happen.

const title = "Guards! Guards!";

// Use console.log(); to see the output

title.substr(3); //> ?

title.substr(6, 4); //> ?

title.substr(25); //> ?

Splitting and joining strings

Now that you've looked at a couple of ways to access string characters, take a step back to analyze the functions at work here.

As the name suggests, the sentenceCase() function could be described as one that capitalizes the first character in a string and sets all other characters to lowercase. That's what you were trying to do above. But you could also reuse this function to create a titleize() function in order to turn phrases into titles (with title case formatting). For example, you could expect the titleize() function to work like this:

const title = "the light FANTASTIC";

titleize(title); //> "The Light Fantastic";

There are a few ways to accomplish this task. Below is one approach that makes use of the split() and join() methods, seen below.

function titleize(title) {

  const words = title.split(" ");

  let result = [];


  for (let i = 0; i < words.length; i++) {

    const capitalized = sentenceCase(words[i]);

    result.push(capitalized);

  }


  return result.join(" ");

}


titleize("the light FANTASTIC"); //> "The Light Fantastic"

In the code sample above, the split() method separates the string based on the string given to it as an argument. Here's an example:

const title = "the light FANTASTIC";

title.split(" "); //> [ "the", "light", "FANTASTIC" ]

The argument given to split() is a string with a space. Therefore, an array is created in which each new item is separated by the string. Notice that in the resulting array above, all of the spaces have been removed.

Now, take a look at the join() method. The join() method is called on an array and joins all the elements in that array together with the supplied argument. In the case of the titleize() function, the join() joins all the capitalized words into a single string, separated by spaces.

const result = ["The", "Light", "Fantastic"];

result.join(" "); //> "The Light Fantastic";

If you want to learn more, check out the Mozilla Developer Network (MDN) resources on the split() method and the join() method.
Do this
Use split() and join()

Take a look at the following examples of split() and join(). Before running the code on your own, evaluate the code in your head and predict what will happen.

const title = "Guards! Guards!";

title.split("!"); //> ?

title.split(""); //> ?

title.split("guards"); //> ?


const titleArr = ["The", "Light", "Fantastic"];

titleArr.join("-"); //> ?

titleArr.join("_-_"); //> ?

titleArr.join(); //> ?

Template literals

Joining together multiple strings can end up looking pretty messy. Previously, you've had to concatenate multiple parts of a string with the + operator to accomplish this task. Take a look at how the following function concatenates strings.

function bookSale(title, priceInCents) {

  const price = (priceInCents / 100).toFixed(2);

  return titleize(title) + " is on sale for $" + price + ".";

}


bookSale("the light fantastic", 950); //> "The Light Fantastic is on sale for $9.50."

The above function works, but it doesn't look that great. Fortunately, JavaScript has a feature called template literals, which can help make this function look cleaner and clearer. Check it out:

function bookSale(title, priceInCents) {

  const price = (priceInCents / 100).toFixed(2);

  return `${titleize(title)} is on sale for $${price}.`;

}

Template literals allow you to embed expressions and avoid using multiple + operators just to join a string. The syntax of a template literal is seen here: `${titleize(title)} is on sale for $${price}.` Here are the key pieces:

    Begin and end your string using backticks, which look like this `. They are accessible on the tilde ~ key on your keyboard.

    Place variables or expressions inside of curly braces {}, which should be preceded by a dollar sign $. It should look like this: ${}.

Do this
Use template literals

Given the variables below, construct a string using template literals that results in the following sentence.

The price of 'Interesting Times' by Terry Pratchett is $8.99.

const title = "Interesting Times";

const author = "Terry Pratchett";

const price = 8.99;

If you're having trouble, you can peek at the answer below.

`The price of '${title}' by ${author} is $${price}.`;

Escaping strings

When reviewing older code, you may see examples like the snippet below:

const firstSentence = "Will tugged at his mother's hand and said, \"Come on, come on...\"";

This string was created with double quotes, but that there are also double quotes in the string. The backslash \ that you see here is used to escape the string.

Escaping a string means that you're providing a backslash to allow for the following character to be seen as part of the string rather than part of the syntax. In the example above, the \ tells JavaScript that it should treat this double quote as part of the string, not as the closing quotation.

The sample string above is just fine. But as you've learned, template literals offer a better way to write it:

const firstSentence = `Will tugged at his mother's hand and said, "Come on, come on..."`;

** control flow

Control flow
1.5 hoursAverage Reading Time
Learning Objective
By the end of this lesson, you will be able to write if/else statements concisely. You'll also be able to use switch statements to control the flow of programs.

Overview
You already know how to use if/else statements to control the flow of code. And although you can always effectively control the flow of the code with the if/else statements that you've learned so far, there are some additional tools that can make your code simpler. In this lesson, you will explore different ways of writing if/else statements. You'll also learn about switch statements, which offer another way of controlling the flow of programs.

It's important to know the various tools that you have available as a developer. Ultimately, the tool that you'll use in specific cases will likely come down to your personal preferences.

Start by watching the video below, which provides a brief introduction to simple if statements and the switch statement. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.


Single-line if statements
There's a lot of talk about if/else statements. And with good reason—they're pretty useful. But sometimes you don't need an else statement as part of your conditional. Take a look:

function getPrice(product) {
  let price = product.priceInCents;
  if (product.onSale) {
    price = price * 0.9;
  }

  return price;
}

const product = {
  priceInCents: 2100,
  name: "Red Beanie",
  size: "L",
  onSale: true,
};
getPrice(product); //> 1890
Here, the getPrice() function applies a 10% discount to any item that has onSale set to a truthy value. And although the above code sample is perfectly fine, you may also see the following:

function getPrice(product) {
  let price = product.priceInCents;
  if (product.onSale) price = price * 0.9;

  return price;
}
This function definition, by contrast, has removed that set of curly brackets {} and has instead added the remaining line, price=price*0.9, to the line above it. However, you should only consolidate lines like this in your own code if the content inside the block is very short. Otherwise, it will be too difficult to read.

It's important to note that there is no substantive difference between these two options. They simply look different.

The conditional operator
The conditional operator, also commonly called the ternary operator, is a way to write a short if/else statement. It should be used only if the overall if/else statement is very short. The syntax works like this:

(conditional expression) ? (expression if true) : (expression if false)
Take a look at the following rewrite of the getPrice() function. As you can see, this function is now much more concise, which makes it cleaner and easier to read.

function getPrice(product) {
  return product.onSale ? product.priceInCents * 0.9 : product.priceInCents;
}
To make sure you understand what is happening here, take a moment to break this down. The expression before the question mark is the conditional. If it evaluates to a truthy value, the expression after the ? will be returned. But if the conditional evaluates to a falsy value, the expression after the colon : will be returned.

When it comes to comparing the options discussed here, there's no one best approach. The single-line if statement, the conditional operator, and a full if/else statement can all work for you. Over time, you'll develop preferences based on which method you find to be clearest and easiest to read. However, because you're still learning the ropes, you should default to writing out the full statement for the time being. This will help you become comfortable with the process before you start abbreviating it.

To learn more, check out MDN's page about the conditional operator.

The switch statement
Sometimes, like in the cases noted above, your if/else statements can be quite short. But sometimes, they can be very long.

Take a look at this example. What do you think this code does?

function getStateSalesTax(stateAbbreviation) {
  let result;
  if (stateAbbreviation === "CA") {
    result = 0.0725;
  } else if (stateAbbreviation === "CO") {
    result = 0.029;
  } else if (stateAbbreviation === "GA") {
    result = 0.04;
  } else if (stateAbbreviation === "VT") {
    result = 0.06;
  } else {
    result = 0;
  }

  return result;
}
The code above is actually pretty straightforward—depending on the state that is inputted, a different value (in this case, a sales tax amount) is returned. But this might feel a bit clunky. Fortunately, there's another way that you could write the function above: with the switch statement.

function getStateSalesTax(stateAbbreviation) {
  let result;
  switch (stateAbbreviation) {
    case "CA":
      result = 0.0725;
      break;
    case "CO":
      result = 0.029;
      break;
    case "GA":
      result = 0.04;
      break;
    case "VT":
      result = 0.06;
      break;
    default:
      result = 0;
  }

  return result;
}
So, what's happening here? Right after the switch keyword is introduced, the given expression is evaluated. Then, a matching case is searched for using strict equality. If anything matches, it runs the code in that case. The break keyword stops the current switch statement, preventing the code from running for any more cases. If no matching value is found, the default runs.

Usually, case statements will use break between each case. This can help you avoid getting behavior or results that you don't expect.

Sometimes, the fallthrough behavior is helpful. For example, look at this code sample:

function getStateSalesTax(stateAbbreviation) {
  let result;
  switch (stateAbbreviation) {
    case "CA":
      result = 0.0725;
      break;
    case "CO":
      result = 0.029;
      break;
    case "GA":
      result = 0.04;
      break;
    case "MD":
    case "VT":
    case "WV":
      result = 0.06;
      break;
    default:
      result = 0;
  }

  return result;
}
In this example, "MD", "VT", and "WV" all have the same sales tax. Entering any one of those values will set the result to the same value.

The two functions discussed above will work in similar ways. Ultimately, it'll be up to you when you want to use a switch statement instead of a longer if/else statement.

If you want to learn more, consult MDN's page on the switch statement.

** looping over objects

Transforming objects into arrays
One way of looping over objects is to "cheat."
In this context, "cheating" means that instead of looping over an object, you'll actually transform part of the object into an array.
There are two methods that allow you to "cheat" in this way: Object.values() and Object.keys().

Accessing values
Often, you'll use objects to connect two pieces of information together.
For example, the following object connects names with addresses.

const people = {
  "Lee Finch": { address: "913 Hunts Lane", isCustomer: true },
  "Whitney Shawna": { address: "392 Norfolk Street", isCustomer: false },
  "Gabrielle Mayo": { address: "934 Engert Avenue", isCustomer: false },
};

However, what if you need to access just the values? You can do this by using Object.values(), passing in the object.
This method will return an array of all the values in any given object.

See the example below:
const addresses = Object.values(people);
//> [
//>   { address: "913 Hunts Lane", isCustomer: true },
//>   { address: "392 Norfolk Street", isCustomer: false },
//>   { address: "934 Engert Avenue", isCustomer: false },
//> ]
You can now loop over these values as you would in an array. Pretty nifty!

Accessing keys
Now, imagine that you need to access just the keys of an object.
This is where a similar method, Object.keys(), comes in handy.

Take a look:
const names = Object.keys(people);
//> [ "Lee Finch", "Whitney Shawna", "Gabrielle Mayo" ];
And yet again, you're set up to loop over this array however you like.

Looping over objects
Generally, the two methods described above will be sufficient for the work that you'll do.
They'll help you "cheat" to create an array that you can then loop over as needed.
However, sometimes it'll be easier to loop through an object on its own.
In those cases, you will use a for/in loop.


Now, take a look at the code sample below:
for (let name in people) {
  const person = people[name];
  const address = person.address;
  console.log(`Sending mail to ${name} at ${address}.`);
}
In the above for/in loop, people is the entire object, and name will be every object key. The code will run as many times as there are keys within the for/in loop block. This will allow you access to every key and value in the object.

This same process can be performed by using Object.keys() in place of the for/in syntax.
However, the for/in syntax is generally recommended because it takes less code and more clearly demonstrates the purpose of the code.

Do this
Use a for/in loop

Try running the following code directly. Can you identify the data types of people, name, person, and address here? Take a moment to consider what those data types might be and to predict what the code will do before you run it.

const people = {
  "Lee Finch": { address: "913 Hunts Lane", isCustomer: true },
  "Whitney Shawna": { address: "392 Norfolk Street", isCustomer: false },
  "Gabrielle Mayo": { address: "934 Engert Avenue", isCustomer: false },
};


for (let name in people) {
  const person = people[name];
  const address = person.address;
  console.log(`Sending mail to ${name} at ${address}.`);
}

for-in loops
use it to iterate over the keys of objects
let object = {
  name: "Alice",
  location: "Sealand"
};
for (let key in object) {
  //  Logs "name Alice",  "location Sealand"
  console.log(key, object[key]);
};

** destructuring and rest

Deep destructuring The process of destructuring multiple levels of an array or other object
Destructuring The process of unpacking the properties or values in an array or other object and assigning them into distinct variables
Rest operator An operator that condenses entries in arrays and other objects

Destructuring objects


Now, take a moment to examine the object in the code sample below.
const product = {
  title: "The Golden Compass",
  priceInCents: 799,
  author: {
    firstName: "Philip",
    surname: "Pullman",
  },
};

When working with an object, you'll often need to use some, but not all, of the available keys.

Consider this example:
function printAuthorAndTitle(product) {
  return `${product.title} by ${product.author.firstName} ${product.author.surname}`;
}

The above function works just fine.
However, the return statement ends up being a bit long because you have to repeat the product variable multiple times.
In this case, you might update the above function to the one below, hoping to make it easier to read:

function printAuthorAndTitle(product) {
  const author = product.author;
  const title = product.title;
  return `${title} by ${author.firstName} ${author.surname}`;
}

The second function is more legible than the first.
But it still looks clunky; after all, the product variable continues to be repeated multiple times.
Fortunately, there's another option: destructuring.
When you destructure an object or array, you're unpacking the properties or values and assigning them into distinct variables.

Take a look at the following version of the function above, which makes use of destructuring. What do you notice?

function printAuthorAndTitle(product) {

  const { author, title } = product;

  return `${title} by ${author.firstName} ${author.surname}`;

}

In this example, two new const variables are being created: author and title.

Notice how these new variables are wrapped in curly brackets {} before the = sign.
This is the destructuring syntax.
Those variables are set to whatever keys can be found inside of the product object.
If a key isn't found, it will be set to undefined.

Take a look:
const { yearPublished } = product;
console.log(yearPublished); //> undefined
Because product doesn't contain a yearPublished key, undefined would be logged to the console.

And what's more, you can destructure multiple levels into an object. Check it out.

function printAuthorAndTitle(product) {
  const {
    author: { firstName, surname },
    title,
  } = product;
  return `${title} by ${firstName} ${surname}`;
}

In the above function, the author key, which also points to an object, is further destructured to access the firstName and surname keys.
Note that there is no author variable in this function.
The only variables that are created are firstName, surname, and title.

Do this
Destructure an object

Take a look at the following object. Practice destructuring all of the keys from this object.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

When you're done, you can compare your work to this solution:

const {name} = author;

const firstName = name.firstName;

const surname = name.surname

console.log(firstName); //> 'Philip'

console.log(surname); //> 'Pullman'

Missing keys

Review the following code. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};


const { firstName } = author;

console.log(firstName);

As you can see, firstName ends up being undefined because the author object doesn't have a key called firstName. The firstName key belongs to the nested object that the name key points to.

Deep destructuring
Examine the code sample below. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;
console.log(firstName);
console.log(name);

In this case, firstName will be printed out as "Philip". But trying to print name will cause a ReferenceError.

When you use the syntax above to do deep destructuring, you're able to dive into and unpack multiple levels of an object. However, you won't have access to every value along the way. Furthermore, deep destructuring can cause some issues if the key is missing.

For example, take a look at the code below.

const author = {
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;

If you run this code, you will receive the following error:

Uncaught TypeError: Cannot read property 'firstName' of undefined

If you use deep destructuring, you'll need to make sure that the inputted object or array is of the right shape. This will help prevent errors like this one.
Destructuring arrays

As you know, objects are accessed by their keys. Arrays, on the other hand, are accessed by their index. In the above example, object keys were used to destructure objects and create variables. The process for arrays is similar, except that you'll use those specific positions in the array to create the variables. To begin, check out the array below:

const genres = [
  "Fantasy",
  "Fiction",
  "Nonfiction",
  "Science Fiction",
  "Young Adult",
];

You can destructure this array by doing the following:

const [first, second] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'

In the above example, two new variables are created: first and second. Those variable names are set to the elements at index 0 and index 1. The rest of the elements are ignored.
Do this
Destructure an array

Take a look at the following array. Practice destructuring the first, second, and third values from this array.

const authors = [
  "Ursula K. Le Guin",
  "Brandon Sanderson",
  "Terry Pratchett",
  "Neil Gaiman",
  "J. R. R. Tolkien",
];

const [first, second, third] = authors;

The rest operator

As you've seen, destructuring is an extremely valuable tool. But that being said, destructuring an array on its own is only so useful. It's much more useful when it pairs up with another tool: the rest operator.
Take a look at the code sample below. What do you notice?

const [first, second, ...otherGenres] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'
console.log(otherGenres); //> [ 'Nonfiction', 'Science Fiction', 'Young Adult' ]

In this example, there are two variables: first and second. Those are followed by the syntax that makes up the rest operator: the three periods ... and a variable name, which in this case is otherGenres. The variable that follows ... will contain all of the remaining array elements that weren't destructured. This can be very useful for splitting apart an array.
Destructuring parameters

You can also use destructuring in functions in order to destructure the parameters. Take a look at this example:

function printAuthorAndTitle({ author, title }) {

  return `${title} by ${author.firstName} ${author.surname}`;

}


printAuthorAndTitle(product); //> 'The Golden Compass by Philip Pullman'

The above syntax, once understood, is useful for at least two reasons:

    You know that the expected input into the function is an object.

    The function is concise and easy to read.

However, there is a downside to this approach: if you need to access the entire inputted object, you have no way to do so.

object destructuring
quickly extract prop values from objects and assign to local variable.
commonly used to aid readability.
const car = {
  make: "Toyota",
  model: "Corolla",
  drive() {
    console.log("The car is driving!");
  }
}

// Destructure values from car
const {make, model, drive, numberOfWheels} = car;

console.log(make); // "Toyota"
console.log(model); // "Corolla"
drive(); // The care is driving!
console.log(numberOfWheels); // undefined

peculiarities of accessing objects
const littleYacht = {
  floorColor: "red",
  maximumLbs: 1000,
  inOperation: true,
  christened: false,
  hornSound: "Ride of the Walkeries",
  "Dock Name": "oceania",
  //Dock Name: "oceania",

  playHorn: function() {
    console.log(littleYacht.hornSound);
  }
};

console.log(littleYacht.floorColor);
console.log(littleYacht["floorColor"]);
// console.log(littleYacht[floorColor]);

console.log(littleYacht["Dock Name"]);
// console.log(littleYacht.Dock Name);

the in operator
check existence of a key in an object:
const myObj = {
  color: "red",
  shape: "circle",
  size: "4cm"
}

console.log("shape" in myObj); // => true
console.log("height" in myObj); // => false

methods are properties of objects which are functions
const car = {
  make: "Toyota",
  model: "Corolla",
  // this is a method
  drive() {
    console.log("The car is driving!");
  },
  // it's shorthand for this
  useHorn: function() {
    console.log("Beep");
  }
}

car.drive(); // Logs out "The car is driving!"
car.useHorn(); // Logs out "Beep"

** object shorthand and spread

Object shorthand JavaScript syntax that supports the creation of objects using values stored in variables, where the variable name becomes the key and the stored value becomes the value in the key-value pair
Spread operator An operator that expands entries in arrays and other objects

Object shorthand
Newer versions of JavaScript have made it even easier for you to streamline your code by allowing you to create object shorthands.
Object shorthand syntax means that you can create objects using values that you've stored in variables.

Take a look:
const title = "Infernal Devices";
const author = "K.W. Jeter";
const book = { title, author };

Notice that in the above code, there is no colon : symbol to distinguish a key from a value. So, what are the keys and values of this object?

console.log(book); //> { title: "Infernal Devices", author: "K.W. Jeter" }

Here, JavaScript takes the name of the variable and sets that to be the key. It then sets the value to be whatever is stored in that variable. This works with more complicated data types, as well.

const product = { book, priceInCents: 1950 };

With this shorthand tool, you can write cleaner code. The above code would result in the following:

{
  book: {
    title: "Infernal Devices",
    author: "K.W. Jeter",
  },
  priceInCents: 1950,
};

The spread operator
The spread operator allows you to easily combine arrays and objects without a lot of complicated code.
For example, with what you know now, how would you go about combining the following two arrays?

const ownedBooks = ["Infernal Devices", "Foundation"];
const wishlist = ["Good Omens", "Guards! Guards!"];

At first glance, you'd probably see that you could loop through one array and push each item into the other, or you could use the concat() method, which you can learn more about in MDN's array documentation.
And yet, it can be even easier than that.

Review the code below. What do you notice?

const allBooks = [...ownedBooks, ...wishlist];
//> [ "Infernal Devices", "Foundation", "Good Omens", "Guards! Guards!" ]

Do you see the three periods ...?
When ... is used with an existing array on the right side of the = sign, it will expand the entries inside of that array.
In the above case, both arrays are expanded into a new array, so that all of the array elements appear next to one another.

This can also be accomplished with objects, as follows:

const salesTax = { state: "Washington", tax: 0.065 };
const sale = { ...product, ...salesTax };
/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 1950,
    state: "Washington",
    tax: 0.065
  };
*/

In the example above, the product object contains the book key and the priceInCents key.
The salesTax object contains the state and tax keys.
Those keys are all placed into a new object in the variable sale.
Note how the book object wasn't expanded; the spread operator expands only one level deep.

You also can overwrite keys in an object where you're using shorthand. You can do this by simply using the key once again. Take a look:

const sale = {
  ...product,
  ...salesTax,
  priceInCents: product.priceInCents * (1 + salesTax.tax),
};

/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 2076.75,
    state: "Washington",
    tax: 0.065
  };
*/

In the above example, the product and salesTax values are expanded with the spread operator, just like before. But this time, the priceInCents key is added to overwrite the priceInCents key that was stored in the product variable.


Property value shorthand (for Objects)
A convenient shorthand method for creating an object if your local variable name matches the new object's key

// Function that returns a new 'cat' object:
function createCat(name) {
  const color = getRandomColor();

  return {
    eyes: 2,
    legs: 4,
    name,     // same as name: name
    color,    // same as color: color
  };
}

const myCat = createCat('tabby');

example:
{
  eyes: 2,
  legs: 4,
  name: 'tabby',
  color: 'blue'
}


Spread operator (...) with objects
    Helps us manage merging objects
    Creates a new object
    Be aware of the order in which merging is done

const littleYacht = {
    "Dock Name": "oceania",
    floorColor: "red",
    christened: false,
    hornSound: "Ride of the Walkeries",
    playHorn() {
        console.log(littleYacht.hornSound);
    }
};

const littleYacht2 = {
    roofColor: "green",  // new key, will be added
    christened: true     // duplicate key, will be overwritten
};

const newYacht = { ...littleYacht, ...littleYacht2 };

The this keyword
    (Generally) used in methods to refer to properties of an object
    Don't need to know the variable name of the object itself

const littleYacht = {
    hornSound: "Ride of the Walkeries",
    playHorn: function() {
      // Equivalent to littleYacht.hornSound
      console.log(this.hornSound);
    }
};

littleYacht.playHorn(); // Ride of the Walkeries


What does this refer to?
    this is assigned a value at the moment the method is invoked, and not when it is defined
    this is assigned to the object to the left of the dot when the function was called

const littleYacht = {
  hornSound: "Ride of the Walkeries",
  playHorn: function() {
    console.log(this.hornSound);
  }
};

littleYacht.playHorn(); // Ride of the Walkeries

const biggerYacht = {
  hornSound: "Fog Horn",
  playHorn: littleYacht.playHorn
};

biggerYacht.playHorn(); // Fog Horn

** scope

Sibling scopes Two or more scopes that share a common parent scope

Complex scope
The following video breaks down how to evaluate functions with complicated scope and diagram the scope of programs.
Start by watching the video, and then read through the rest of the lesson and complete the practice work required.
This will give you a full understanding of these concepts.

When you use let and const, you can easily separate scope by simply looking for the curly brackets {}.
Each pair of curly brackets gives you a new level of scope.

Additionally, anything inside of a set of curly brackets can access reference variables that are set outside of it.
See if you can separate the scopes in the code sample below:

const DISCOUNT_PERCENTAGE = 0.15;
function discountPricesInCents(products) {
  const result = [];

  for (let i = 0; i < products.length; i++) {
    const product = products[i];
    let price = product.priceInCents;
    if (DISCOUNT_PERCENTAGE > 0) {
      const multiplier = 1 - DISCOUNT_PERCENTAGE;
      price = product.priceInCents * multiplier;
    }
    result.push(price);
  }

  return result;
}

The above code relies on different rules for block scope and global scope. Here are the details:

    In the discountPricesInCents() function, you can access DISCOUNT_PERCENTAGE because it's part of the global scope.
    Later on, if you were to call discountPricesInCents(), you would be accessing it from the global scope.
    In the for loop statement, you're able to access the products parameter because it is shared inside the function scope. If you tried to log products outside of the function, you would get an error.
    Inside of the for loop, you're able to access products and DISCOUNT_PERCENTAGE because they are both in outer scopes.
    However, i, product, and price are accessible only within the for loop. You can't access those variables outside of the curly brackets.
    Finally, multiplier is accessible only inside of the if statement. It can't be accessed outside of that statement.

Diagramming scope
As you can see above, a complex scope can be hard to understand. To gain some clarity, developers often find it useful to diagram out the scope for a particular function or program. Here's one way to diagram scope:
Diagramming scope

The above diagram demonstrates the following:
    Each distinct background color represents a level of scope. For example, the if statement scope is enclosed inside of the for loop scope.
    At each arrow, a new scope is introduced. For example, inside of the function scope is a for loop scope.
    Each scope has access to the variables of its containers. For example, the function scope has access to the global scope, and the if statement scope has access to all other scopes.

Reminder: Variable declarations and scope
As you know, variables declared with let and const can only ever be declared once.
But there's one exception to this rule: you may declare variables that are in sibling scopes.
For example, pay attention to the price variable in the following code sample:

const DISCOUNT_PERCENTAGE = 0.15;
const product = {
  name: "Black Longline T-Shirt",
  priceInCents: 1500,
  availableSizes: ["XS", "S", "XL", "XXL"],
};


if (DISCOUNT_PERCENTAGE > 0) {
  const multiplier = 1 - DISCOUNT_PERCENTAGE;
  const price = product.priceInCents * multiplier;
  console.log(price);
} else {
  const price = product.priceInCents;
  console.log(price);
}

In the case above, price is declared twice as a const variable, but the scopes are separate. That means that they can both be declared successfully on their own.

** default parameter

Setting defaults
Take a look at the following function. What do you notice?

function calculatePriceInDollars(priceInCents) {
  return priceInCents / 100;
}

This simple function converts cents to dollars.
It takes a number—in this case, a specific amount of money—and then divides it by 100.
However, if no argument is entered when the function is called, it will result in NaN.
This can be seen below.

calculatePriceInDollars(100); //> 1  (Returns 1 because 100 cents = 1 dollar)
calculatePriceInDollars(250); //> 2.5
calculatePriceInDollars(); //> NaN

But imagine that you want the value to be 0 instead of NaN if no argument is entered.
In this case, you can set 0 as the default for the priceInCents parameter.
Setting a default means that you've identified a value to be there even if a specific value is missing from the function call.

function calculatePriceInDollars(priceInCents = 0) {
  return priceInCents / 100;
}

calculatePriceInDollars(); //> 0

To set a default, place an equals sign = after the parameter name, followed by whatever value you want to use as the default. This value can be anything valid in JavaScript.

If the value of that parameter is undefined when the function is called, it will be replaced with the value that you've provided.

Why use defaults?
At this point, you may be wondering: instead of using default parameters, shouldn't you just make sure that your functions are always called correctly?
Indeed, in the above example of the calculatePriceInDollars() function, it might seem like it would make more sense to just always use an argument.
And in general, this is true—it is better to simply use your functions as intended rather than set numerous defaults.

However, defaults can be particularly useful in a few circumstances:
    If there is a typical case for your function, but you want to allow for certain options, you might use defaults.
    If one or more of the argument values that you're using come from an outside source, you might use defaults because you won't necessarily be able to control the input values.

Consider the example below.

function welcomeMessage(name, isReturnCustomer = false) {
  const message = isReturnCustomer ? "Welcome back" : "Welcome";
  return `${message}, ${name}!`;
}

You may expect the above function to pass in only a single argument typically. However, if the customer is a returning customer, you could easily change the message by adding a second argument. In this case, the function could use defaults to allow for a typical case with some options.

Object defaults
Now, you'll investigate object defaults.

Code setup
You'll use the code below for the following examples. So take a moment to review this function and figure out how it's used.

// Function definition
function calculateTotal(products, { discountPercentage, salesTax }) {
  let result = 0;
  for (let i = 0; i < products.length; i++) {
    const { priceInCents, quantity } = products[i];
    result += priceInCents * quantity;
  }

  if (discountPercentage) result *= 1 - discountPercentage;
  return result * (1 + salesTax);
}

// Inputs
const products = [
  {
    name: "Black Longline T-Shirt",
    priceInCents: 1500,
    size: "M",
    quantity: 2,
  },
  {
    name: "Light Wash Stretch Skinny Jeans",
    priceInCents: 6000,
    size: 32,
    quantity: 1,
  },
];
const options = { discountPercentage: 0.1, salesTax: 0.0825 };

// Function call
calculateTotal(products, options); //> 8768.25

The above function takes in an array of products and calculates the total. If discountPercentage is included in the options parameter, it will apply a discount. It will then add salesTax to the total.

Do this
Run calculateTotal()

Copy the function above and paste it into a place or program, such as a code editor, where you can edit it and then run the function. Try changing the quantities and options to see what happens.
Set an object as a default

Now, in the case of the function above, imagine that there are no discounts, and you just want to use a standard sales tax. In this situation, you may want to just call the function without passing anything in. However, this will result in an error.

calculateTotal(products);
//> Uncaught TypeError:
//> Cannot destructure property 'discountAmount' of 'undefined' as it is undefined.

The issue above is that there is no object to destructure, so the code fails to create those variables. But just like you saw above, you can set a default parameter by adding an = sign followed by the default value.

function calculateTotal(products, { discountPercentage, salesTax } = {}) {
  // ...
}

What is happening in the function signature above? Take a look:
    If there is an object passed in as the second argument, the code will destructure that argument and assign the discountPercentage and salesTax variables.
    If there isn't an object passed in as the second argument, the code will default to an object. Then it will attempt to destructure that empty object. The variables will exist, but they will both be set to undefined.

Update calculateTotal()
Update the calculateTotal() function with the above code. Try running it once more, only passing in products as an argument. Is the result what you expected? Or is it different?

Default key values
If you run the function above without a second argument, it will run. But it will give you an undesirable result.

calculateTotal(products); //> NaN

In this case, the result will be NaN because salesTax is undefined. This problem can be solved by using more defaults.

function calculateTotal(products, { discountPercentage, salesTax = 0.0825 } = {}) {
  // ...
}

The code above sets a default value for the key in the object. If salesTax is undefined, salesTax will in fact be set to the value of 0.0825.
Now, if you call this function with products as the only argument, it will work correctly.

calculateTotal(products); //> 9742.5

Do this
Include default values

Update your calculateTotal() function so that it includes a default for the salesTax value. Try running the function once again. What is the result?

Setting a default array
With this practice under your belt, you're ready for one final modification. You can update the code so that if products happens to be undefined, the function will just return 0. Specifically, you would change the function signature to look like the one below:

function calculateTotal(products = [], { discountPercentage, salesTax } = {}) {
  // ...
}

The above code sets the default for products to be an empty array. This means that the for loop will still be able to run.

calculateTotal(); //> 0

The entire updated function is below.

function calculateTotal(products = [], { discountPercentage, salesTax = 0.0825 } = {}) {
  let result = 0;
  for (let i = 0; i < products.length; i++) {
    const { priceInCents, quantity } = products[i];
    result += priceInCents * quantity;
  }

  if (discountPercentage) result *= 1 - discountPercentage;
  return result * (1 + salesTax);
}


An aside: Pass by reference or value?

    Primitives (string, number, boolean) are passed by value
    Complex data types (arrays, objects) are passed by reference

let myNumber = 10;

function passedPrimitive(num) {
  num = 20;
}

passedPrimitive(myNumber);
console.log(myNumber);   // => 10

function receives a copy of the value - local scope cannot impact the original variable

const mySequence = [1,2,3];

function passedComplex(arr) {
  arr.push(4);
}

passedComplex(mySequence);
console.log(mySequence);  // => [1,2,3,4]

function receives a reference to the item - the local variable assigned to this item is impacting the original item

** references

Primitive data type Also called a primitive or a simple data type, a data type containing variables that store values
Reference data type Also called a reference or a complex data type, a data type containing variables that store addresses to locations in memory

Primitive data types
JavaScript has several data types that are passed by value.
These are often called primitive data types, or simply primitives, and you've already learned a bit about them!
Primitive data types in JavaScript include strings, numbers, and booleans, as well as null and undefined.
When a primitive data type is assigned to a variable, that variable gets its own copy.

Take a look at the following line of code:

const title = "Mort";
In this example, the variable title contains the string "Mort". If you reassign the value contained by title to another variable, such as name, both variables will contain their own copy of that value. You can see this below.

let title = "Mort";
const name = title;
title = "Equal Rites";
console.log(title, name); //> "Equal Rites", "Mort"
The above code is very important. Although it may seem obvious, you should take a moment to understand what's happening here. When title is reassigned to "Equal Rites", notice that the name variable still holds its own copy of "Mort".

Now, take a look at another example. As you read over this, what do you expect to be logged?

let price = 1000;
let salePrice = price;
salePrice -= 100;
console.log(price, salePrice); //> 1000 900
In the code above, the price variable will still be the number 1000, while the salePrice variable will be 900. Despite the modification of salePrice, price retains its own copy of the value 1000.

Reference data types
But there's another kind of data type: reference data types. Reference data types, sometimes just called references, in JavaScript include functions, objects, and arrays. When a reference data type is assigned to a variable, the variable will contain a reference (also called a pointer) to the data.

Take a look at the following example. What do you expect to happen here?

const book = { title: "Mort", author: "Terry Pratchett" };
const mort = book;
book.price = 789;
console.log(mort); //> { title: "Mort", author: "Terry Pratchett", price: 789 }
Are you surprised by the result? Both the book variable and the mort variable point toward the same reference. That means that if you modify the object through one variable, the other variable will have that same modification.

This is further illustrated by the following two examples. Here's the first:

const author = {};
const book = {};
console.log(author === book); //> false
In the above console.log() statement, two empty objects, author and book, are compared with one another. When the === sign is used, it compares these objects' references.

These objects may look the same. However, the statement resolves to false. That is because author and book each store their own references to different objects.

Now, check out this example:

const sourcery = { title: "Sourcery", author: "Terry Pratchett" };
const favoriteBook = sourcery;
console.log(sourcery === favoriteBook); //> true
In the above console.log() statement, sourcery and favoriteBook contain references to the same object. When the === sign is used, it compares these references and resolves to true.

This works the same way for arrays, as well. Take a look:

const books = ["Mort", "Sourcery", "Equal Rites"];
const series = books;
series.push("Guards! Guards!");
console.log(books); //> [ "Mort", "Sourcery", "Equal Rites", "Guards! Guards!" ]
In the above example, push() changes the array to include a new title. This mutates the original array, which both books and series are pointing toward.

Note: In the examples above, const is used instead of let to store an array or object. And yet, the values inside of these arrays and objects can be changed. Ultimately, const only stops reassignment, without changing the values inside of the reference itself (in other words, the array or object).

** writing readable code


earning Objective
By the end of this lesson, you will be able to refactor code to be more readable and more efficient.

Overview
At this point, you've learned several important JavaScript concepts. You're familiar with some essential JavaScript syntax, statements, and code-writing tools. And now, it's time to take those skills and refine them. In this lesson, you'll learn some techniques and best practices for writing readable code.

Key Terms
Guard clause
A statement that evaluates to a boolean that determines whether or not a function should continue running
As you know, developers should aim to write code that is clear, clean, and easy to read. And this lesson is all about helping you do that. Of course, there are different approaches and techniques, and the advice provided in this lesson reflects that subjectivity. None of the techniques included here are required. However, they will improve the readability of your code, and using them will show other developers (and potential employers) that you're thoughtful, careful, and professional.

For more advice on how to write code well, speak with experts in the field. Many developers have strong opinions on how to write code that is more legible and maintainable. Gathering information from different experts will help inform your preferences and practices.

Don't repeat yourself
One important rule that you will often hear as a developer is not to repeat yourself. In fact, don't repeat yourself is often abbreviated to DRY, and the whole idea is often captured in the following advice: write DRY code. Generally, this idea is used specifically in the context of functions. Because functions allow you to wrap up repeated code within a function, they can be particularly helpful when it comes to writing DRY code.

However, this is only one way to think about the phrase "don't repeat yourself." Take a look at the following data and function. Spend a few moments reviewing it to make sure you understand what is happening. What do you notice? Then, try running the function yourself.

const authors = [
  {
    id: 1,
    name: {
      firstName: "Philip",
      surname: "Pullman",
    },
    series: ["His Dark Materials", "Sally Lockhart"],
  },
  {
    id: 2,
    name: {
      firstName: "Terry",
      lastName: "Pratchett",
    },
    series: ["Discworld", "Long Earth"],
  },
];

function getAllSeries(authors) {
  const result = [];
  for (let i = 0; i < authors.length; i++) {
    for (let j = 0; j < authors[i].series.length; j++) {
      result.push(authors[i].series[j]);
    }
  }
  return result;
}

getAllSeries(authors);
//> [ 'His Dark Materials', 'Sally Lockhart', 'Discworld', 'Long Earth' ]
In the above function, there is some duplicate code. Can you see it? The code shows authors[i] multiple times.

But maybe that can be tightened up. Instead, you could assign this value to the variable. Check it out:

function getAllSeries(authors) {
  const result = [];
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    for (let j = 0; j < author.series.length; j++) {
      result.push(author.series[j]);
    }
  }
  return result;
}
Although you've technically made the above function a bit longer, it's now much clearer. It also avoids using authors[i] multiple times.

If you want to try out the code, you can use this REPL:


Return early
Another important rule is to return early. At its most basic level, the return-early mindset involves writing a function that terminates or throws an error as soon as something is wrong, with the goal of yielding the correct result—the one that you'd expect—at the end of the function.

To better understand this idea, take a look at the following function. This code sample expects inputted data that is similar to that authors array from above.

function getSeriesListById(authors, id) {
  let selected = null;
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    if (author.id === id) selected = author;
  }

  if (id) {
    if (selected) {
      const message = `Series list: ${selected.series.join(", ")}`;
      return message;
    } else {
      return [];
    }
  } else {
    return "No ID provided.";
  }
}
In the above function, the authors array and an id are given to the function. If the id matches one of the authors, the code returns the series for that author. Otherwise, it returns an empty array. If no id is inputted, it returns a string at the end saying so: No ID provided.

The above code isn't that complicated. But it can be made simpler by returning early. Check it out:

function getSeriesListById(authors, id) {
  if (!id) return "No ID provided.";

  let selected = null;
  for (let i = 0; i < authors.length; i++) {
    const author = authors[i];
    if (author.id === id) selected = author;
  }
  if (!selected) return [];

  return `Series list: ${selected.series.join(", ")}`;
}
In this modified example, the function stops if there is no id inputted rather than running despite the lack of id. In fact, when the function stops, the same string from above, No ID provided, is returned. But you'll notice that this happens near the beginning of the function, rather than at the end. This means that the code below that point does not have to run, and it is letting you know as soon as possible that there's no id inputted.

This is sometimes referred to as a guard clause. A guard clause is a statement that evaluates to a boolean that determines whether or not a function should continue running. Implementing guard clauses in your code will make your code much more efficient and easier to read.

Avoid boolean returns
One final rule is to avoid boolean returns when possible. Although this isn't always possible, you can often avoid explicitly returning true and false by returning the expression that is evaluating the statement.

For example, take a look at the following function. What do you notice?

function moreThanThreeAuthors(authors) {
  if (authors.length > 3) {
    return true;
  } else {
    return false;
  }
}
The function above just checks if there are more than three authors in the given array. But you can actually write a stronger, shorter function with the following:

function moreThanThreeAuthors(authors) {
  return authors.length > 3;
}
The conditional statement will already be evaluated to a boolean, so you don't need to explicitly return true or false.


DRY (Don't repeat yourself) & Writing readable code

Simplify condition based functions by returning the comparison instead of true or false explicitly

function isAdult(age){
  if(age > 17){
    return true;
  } else {
    return false;
  }
}


function isAdult(age){
  return age > 17;
}


DRY (Don't repeat yourself) & Writing readable code

const characters = [
  {
    id: 1,
    name: {
      firstName: "Sonic",
      lastname: "Hedgehog",
    },
    games: ["Sonic 1", "Sonic 2"],
  },
  {
    id: 2,
    name: {
      firstName: "Lara",
      lastName: "Croft",
    },
    games: ["Tomb Raider", "Tomb Raider 2"],
  },
];

function getAllGames(characters) {
  const result = [];
  for (let i = 0; i < characters.length; i++) {
    for (let j = 0; j < characters[i].games.length; j++) {
      result.push(characters[i].games[j]);
    }
  }
  return result;
}

getAllGames(characters);

function getAllGames(characters) {
  const result = [];
  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    for (let j = 0; j < character.games.length; j++) {
      result.push(character.games[j]);
    }
  }
  return result;
}

getAllGames(characters);

** assessemnt: js foundations

* unsorted

1. Understand the problem - aka "reflect the question back into your our words."
    -  Do you understand all the words used in stating the problem?
    -  What are you asked to find or show?
    -  Can you restate the problem in your own words?
    -  Can you think of a picture or diagram that might help you understand the problem?
    -  Is there enough information to enable you to find a solution?

2. Devise a plan - aka "Pseudocode"
    * Guess and check           |   * Look for a pattern
    * Make an orderly list      |   * Draw a picture
    * Eliminate possibilities   |   * Solve a simpler problem
    * Use symmetry              |   * Use a model
    * Consider special cases    |   * Work backwards
    * Use direct reasoning      |   * Use a formula
    * Solve an equation         |   * Be ingenious

3. Carry out the plan - aka "code your Pseudocode"
    * Third. Carry out your plan.
    * Carrying out your plan of the solution, check each step. Can you see clearly that the step is correct? Can you prove that it is correct?

4. Look back - aka "refactor"
    * Fourth. Examine the solution obtained.
    * Can you check the result? Can you check the argument?
    * Can you derive the solution differently? Can you see it at a glance?
    * Can you use the result, or the method, for some other problem?


