:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]

these are my notes on the thinkful program
this is a staging area for my notes need to summarize and move to a better place

[[id:63bc8d8d-4fc8-4b34-8881-43ace1415a53][JavaScript]]
[[id:6df2c337-4b01-470f-9028-d0745498f8a6][devWorkflow]]
[[id:dea16eb4-d34a-421b-b037-9f3e606ec001][git]]
[[id:43e93100-42e8-432e-99bb-ecdd6f6b7097][devCollab]]
[[id:a3333ce5-86aa-4729-af16-cd8dafd42149][Node.js]]
[[id:c1cbc82c-ad99-4ae6-80a8-a9d83d2e71b8][careerNetworking]]
[[id:0b027db0-6cea-4c7a-81fa-05115bd10590][problemSolving]]
[[id:bc9d12ba-1f84-4599-9fe3-bcba0d2f5cb4][reactjs]]

* Frontend development - Modules 18-29
** module 18 frontend foundations
*** 18.2 developer tools

Developer tools

In this lesson, you'll focus on the Chrome developer tools (sometimes referred to as DevTools).
However, many browsers have similar developer tools.

The developer tools offer several useful features, including the following:
+ The Element inspector, which allows you to inspect a particular element on the page
+ The Styles tab, which allows you to see which styles have been applied to a particular element
+ The Device toolbar, which allows you to see what your website will look like on various devices

Learning more

For now, the inspector will be your most valuable tool for working with HTML and CSS.
If you want to learn more about the developer tools (and especially Chrome's version), you can visit Google's Chrome DevTools page.
[[https://developers.google.com/web/tools/chrome-devtools][Google's Chrome DevTools]]

*** 18.3 intro to flexbox

Key Terms

Flexible box module
    Flexbox, a CSS module that provides a robust set of tools for developers to solve common layout problems

Introduction to flexbox


The flexible box module (or flexbox) provides a robust set of tools for developers to solve common layout problems, including the problem of building for various screen sizes.




Do this
Adding flexbox

.group {
  display: flex;
  flex-direction: row; /* or column */
}

Within the .group container, the default setting for displaying this container is block.
But to apply the flexbox properties to it, you should set the display property to flex.
This will tell the browser that all the items within this container should display as either a single row or a single column.

When you change the display property to flex, the default value for flex-direction is row.
If you run your code, you'll see that all three items now display within a single row.

Keeping flex-direction set as row is perfect for larger monitors.
And setting flex-direction to column is perfect for displaying the content on mobile devices.


Do this
Set the flex property
To change it so that all three items display with the same width, you can change the flex setting to 1, as shown here:

.item {
  flex: 1;
  margin: 10px;
}

The flex: 1 declaration tells the .group container that each item should be the same width, regardless of its content, and it will fill the container appropriately.

At this point, you should have three items within a group, and the items should display as equal in size.

Do this
Add margins

Set margin: 10px, as shown below. This margin is useful because it creates a little visual barrier between the .item containers. You can add or decrease this value to see what happens to the .item containers in the web page.

.item {
  margin: 10px;
}

Modifying the flex value

The flex: 1 value is currently telling the .item containers to all display at the same width.
You can change the ratio of these containers by changing the flex value to different values.

For example, you could create an additional .item-double class and set that flex value to 2.
When this is applied in addition to the .item class, the new container will display at double the size of the others within that group.

Do this
Create an .item-double class

Add the following .item-double class to your CSS file:

.item {
  flex: 1;
  margin: 10px;
}

.item-double {
  flex: 2;
}

Within the HTML, you can also create columns with different widths, as shown below. To do this, keep the original item class for all the same width elements and the margin. Then use item-double as a modifier style to override item with flex: 2 rather than creating a completely separate style.

The containers that have the item-double class will now display at twice the width of their sibling containers.

*** 18.4 intro to media queries
Overview

Media queries are a CSS feature that allows content to adapt to different screen sizes, such as mobile and desktop screens.
With a simple media query, you can easily modify a website's appearance on different devices.

Media queries

With a simple media query, you can quickly provide a responsive layout to nearly any standard website.


Media queries are essentially an if statement for CSS.
A condition is set, and if that condition is met, then the CSS rules within it will be applied.
Typically, media queries are used for changing the CSS of a website based on screen size.

The basic syntax for a media query is as follows:
@media <media type> (<media features>) {
  <CSS Rules>
}

Media types can be set to all, print, screen, or speech.
The all type, which is the most common type and the default in HTML5, applies the media query to every media type.
But if you want the styles within the media query to apply only when the web page is printed, you can use print instead.

The complete list of media features is long, but these are the most common ones:
+ width
+ height
+ orientation

Do this
Use media queries to adjust your paragraph's font size

In the style.css file, add the following rules:

p {
  font-size: 14px;
}

@media all and (min-width: 800px) {
  p {
    font-size: 24px;
  }
}

The code above is saying that the paragraph should generally display at 14 pixels in size.
The paragraph should only be displayed at 24 pixels when the browser has a width of 800 pixels or greater.

*** 18.5 mobile-first development
Overview
As you'll explore in this lesson, a mobile-first approach involves designing the mobile version of a website first, and then adapting the display to larger screens like a desktop.
When you follow a mobile-first approach, you start by building your website with your mobile users' experience in mind.

Key Terms

Graceful degradation
    A desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen
Progressive enhancement
    A mobile-first approach that involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes
Viewport
    The area of a browser's window in which web content can be seen

Mobile-first development


There are two approaches to media queries.

The more traditional approach is known as graceful degradation.
Graceful degradation is a desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen.
It's considered the old way of creating responsive websites.

The code below represents this traditional desktop-first approach; this kind of approach is built for desktop screens and then adapted for smaller screens.
This code assigns the background of a website shown on a desktop to be green.
However, if a screen's width is smaller—specifically, if the width is between 0 and 600 pixels—the code will assign the background to be red.

body {
  background-color: green;
}

/* This applies from 0px to 600px */
@media all and (max-width: 600px) {
  body {
    background-color: red;
  }
}

The newer and preferred method is known as progressive enhancement.
Progressive enhancement involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes.

As it turns out, progressive enhancement ensures that there is a good enough user experience on all screens.
Designing your pages to work on smaller screens first is the generally accepted approach to making web pages today.

The code below is targeting mobile-first design.
It assigns the background of the website to be red.
However, if a screen width has 600 or more pixels, like on a desktop computer, the code will assign the background to be green.

body {
  background-color: red;
}

/* This applies from 600px and larger */
@media all and (min-width: 600px) {
  body {
    background-color: green;
  }
}

Do this
Implement a mobile-first responsive flexbox

Before you add any media queries to your projects in these lessons, you should first make your project adhere to mobile-first design.

Adjust your screen width to below 800 pixels, to display the smaller screen view.
Notice that the items are arranged horizontally on the same row.
Ideally, they'd be stacked vertically on a small screen.

To do this, you just have to alter how .group classes display; change the flex-direction from row to column, as in the code below:

.group {
  display: flex;
  flex-direction: column;
  margin-bottom: 100px;
}

Now, you can add a media query after the .group and .item classes, like this:

/* Groups and items (Desktop) */

@media all and (min-width: 800px) {
  section,
  h1 {
    padding: 0 10%;
  }

  .group {
    flex-direction: row;
  }
}

Here's a breakdown of the syntax above:

+ The media query @media all and (min-width: 800px) is saying to only apply these CSS rules when the web browser is 800 pixels or larger.

+ When this condition is met, it adds a bit of padding to each <section> and <h1> element.

+ Then, it changes the flex-direction of each group; on larger browsers, the flex-direction becomes row instead of column. This displays the columns appropriately, as you can see in the image below of this code displaying on a larger browser.



Viewport

<meta name="viewport" content="width=device-width">

The viewport is the area of a browser's window in which web content can be seen.
Mobile devices usually render the page as if it were to be displayed on a larger screen, then shrink it to fit within the visible area.
However, if your page is already optimized to work with the small screen, this may cause a suboptimal experience.
The viewport meta tag was introduced to help with this problem; this tag lets you control the way that your pages are scaled when rendered by the browser.

For this meta tag to display the website properly on all devices, you need to add initial-scale=1.
When the initial scale is set to 1, it keeps the same zoom scale.
This presents the text much better as web pages change between vertical and horizontal views.

For any responsive web page, this entire tag is required:

<meta name="viewport" content="width=device-width, initial-scale=1">

Responsive images

Working with images inside responsive layouts can get a little complicated; it would be really difficult to track the changing .item container sizes and then update the image sizes appropriately.
Luckily, there is a very easy solution here: you can set all the image widths to be 100% using CSS, and the images will match whatever container width that they are placed within.

Do this
Adding images to group items

The files for this part of the lesson are stored in the responsive-images folder. Start by opening the index.html file with VSCode Live Server.

Notice that the images displayed in the browser are very large. So now, make them responsive.

Add the following code to the style.css file. Set the width of images to 100%, as follows:

img {
  width: 100%;
}

This code sample targets all the images within the .group container to display at 100%.
If you don't want to force the 100% resizing of every image, you can be more selective in how you target your images.

This code below, for example, will target only the images within the main container to be 100% in width.
Try it out in style.css by replacing the previous CSS code snippet with the following:

main img {
  width: 100%;
}

Because the img and main img selectors target the same images on the page, you won't actually see a visual difference between using img versus main img in this example.

But the four items that are pictures of the ocean aren't.
This is an example of why it is important to understand image size ratios.
When the images aren't the same height and width (in other words, when they have different ratios), they won't display properly.
To get these images to align properly, you need to crop them so that they all have the same ratio.
Images of different sizes that aren't aligned properly.

Most designers use graphical programs like Adobe Photoshop to edit images.
Luckily, there are also alternative apps online that make this process easy.
Of course, third-party tools available for free could disappear anytime.
But hopefully the tool shown below, [[https://www.birme.net/][BIRME]], can help if you find that you need to resize images for your own projects.

*** 18.6 deeper with flexbox

Key Terms

Main axis
    The row or column orientation established by the flex-direction property
Cross axis
    The axis perpendicular to the main axis


Flexbox properties

Certain properties are applied to the group (or parent), and other properties are applied to the items nested within the group (or children).

The following is a list of parent properties:

+ flex-direction
+ flex-wrap
+ justify-content
+ align-items
+ align-content

And here is a list of children properties:

+ order
+ flex-grow
+ flex-shrink
+ flex-basis
+ align-self

Group (parent) properties
The flex-direction property

The flex-direction property establishes the main axis, telling the items to display as either a horizontal row or vertical column.
There are also two other values, row-reverse and column-reverse, which reverse the display order of the items.
The following table summarizes the possible values for the flex-direction property.

Value Effect:
+ row :: Left to right (the default)
+ row-reverse :: Right to left
+ column :: Top to bottom
+ column-reverse :: Bottom to top

The flex-wrap property

By default, the items within a flex group container will display on a single line.
This can be changed to allow items to wrap as needed with the flex-wrap property, as described in the table below.

Value Effect:
+ nowrap :: All flex items will be on one line. This is the default.
+ wrap :: Flex items will wrap onto multiple lines from top to bottom.
+ wrap-reverse :: Flex items will wrap onto multiple lines from bottom to top.

The justify-content property

This is a useful property when there is available space around the items of the group.
That space can be distributed in various ways, as described in the table below.

Value Effect:
+ flex-start :: Items are packed toward the start of the flex direction. This is the default.
+ flex-end :: Items are packed toward the end of the flex direction.
+ center :: Items are packed centered along the line.
+ space-between :: Items are evenly distributed along the line; the first item is on the start line and the last item is on the end line.
+ space-around :: Items are evenly distributed, but have a half-size space on either end.
+ space-evenly :: Items and spacing are both evenly distributed.

The align-items property

This property is similar to the justify-content property, but it aligns items on the cross axis, which is perpendicular to the main axis that is used in the justify-content property
The following table summarizes the possible values for the align-items property:

Value Effect:
+ stretch :: Items are stretched along the cross axis to fill the container, but any defined minimum and maximum item widths are still respected. This is the default.
+ flex-start :: Items are placed at the start of the cross axis.
+ flex-end :: Items are placed at the end of the cross axis.
+ center :: Items are centered on the cross axis.
+ baseline :: Items are aligned along their baseline.

The align-content property

This property will apply only when there is more than one line of flex items.
When there is extra space in the cross axis, it will align the flex group on that axis (similar to how justify-content aligns individual items on the main axis).
The following table summarizes the possible values for the align-content property:

Value Effect:
stretch :: Items stretch along the cross axis to take up the remaining space. This is the default.
flex-start :: Items are packed to the start of the container's cross axis.
flex-end :: Items are packed to the end of the container's cross axis.
center :: Items are packed in the center of the container.
space-between :: Items are evenly distributed with the first line at the start and the last one at the end of the container.
space-around :: Items are evenly distributed with equal space around each line.
space-evenly :: Items are evenly distributed with equal space around them.

Item (child) properties
The order property
By default, flex items will display in the order they are added to the HTML page.
But with the order property, the items in the flex container can be adjusted.
This can be useful if you want the items ordered one way for mobile and another way for desktop.

The flex property
The flex property for items is actually shorthand for three properties:

+ flex-grow
+ flex-shrink
+ flex-basis

These properties are all tied to items, and it is recommended to use this shorthand property instead of setting the individual properties.
The default is 0 1 auto, which assigns flex-grow to 0, flex-shrink to 1, and flex-basis to auto.
But if you set the flex property with a single number value, like 1, the shorthand will use the single value to define the flex-grow property and will then set the other values appropriately.

The flex-grow property

The flex-grow property is quite useful.
By default, the value is set to 0.
If an item is set to 1, it will size all the items equally, so that they are all the same size.
If an item is set to 2, it will set the size of that item as twice as large as the other items.

The align-self property
This property lets the default alignment (or the one specified by align-items) be overridden for individual flex items.

Flexbox layouts

There are many great online resources that demonstrate different layout patterns using flexbox.
If you'd like to see some example flexbox layouts with CSS, visit [[https://tobiasahlin.com/blog/common-flexbox-patterns/][Common CSS Flexbox Layout Patterns with Example Code]].

Helpful games and resources

For practice using flexbox, you can play around with flexbox properties using the games and apps listed below.

    Flexbox Defense teaches flexbox via a casual strategic defense game.
http://www.flexboxdefense.com/
    Flexbox Froggy is a game that lets you practice writing CSS code.
http://flexboxfroggy.com/
    Flexy Boxes shows code samples and allows you to change parameters to help visualize how flexbox works.
https://the-echoplex.net/flexyboxes/
    Flexbox Patterns features many flexbox examples.
https://www.flexboxpatterns.com/
*** 18.7 navigation

Responsive navigation

**** Mobile-first approach


Now, you will learn how to build this CSS code piece by piece. You'll look at the CSS selectors that you need to target the various HTML elements, and you'll learn how to write declaration blocks that style each selected element to match the navigation shown in the image above.

For each selector, the HTML element that the CSS selector targets will be marked by a red border (border: 1px solid red;). This will help you visually connect the code with the element and the space that it occupies in each of the images below.
**** Do this

Make sure to keep the style.css file open in VS Code, as you will be adding CSS code to that file for the remainder of this lesson.
Style the header
Navigation with a styled header.

The header selector is the primary container to hold both the name of your page and its navigation.

Add the following CSS to style the header:

header {

  /* Sets background color to black. */

  background-color: #000;

  /* Adds 40 pixels of space under the header

     so that the main content isn't so close

     to the navigation. */

  margin-bottom: 40px;

}

**** Do this
Style the title of your document
Navigation with a styled title.

The header h1 selector targets the title of your document. Adding a unique font will give this text more style, too.

Add the following CSS to style the title of your document:

header h1 {

  /* Sets text color to white. */

  color: #fff;

  /* Centers the text. */

  text-align: center;

  /* Removes the default margin and spacing around the `h1` element. */

  margin: 0;

  /* Pushes the text down 20 pixels from the top of the page. */

  padding-top: 20px;

}

**** Do this
Style the container for the navigation
Navigation in a styled container.

The header nav selector targets the container for the navigation. Targeting only the nav container that's within the header allows for other navigation containers to be styled differently in the footer or elsewhere on the page.

Add the following CSS to style the container for the navigation:

header nav {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /* Centers an element defined as `display: flex`. */

  justify-content: center;

}

**** Do this
Style the unordered list
Navigation in a styled unordered list.

This header nav ul selector targets the unordered list that is within the header's nav container.

Add the following CSS to style the unordered list:

header nav ul {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /*

    You want the navigation to display in a single row. This is

    the default value for `display: flex`, so you don't need

    to define its `flex-direction` in this case.

  */


  /*

    Removes the default padding to the left of the

    unordered list.

  */

  padding-left: 0;


  /*

    Removes the bullet points from the list items within the

    unordered list.

  */

  list-style: none;

}

**** Do this
Style the anchor tags of the list items
Styled anchor tags of the list items.

The header nav ul li a selector targets the anchor tag (link) of the list items within the unordered list that is within the header's nav container.

Add the following CSS to style the anchor tags:

header nav ul li a {

  /* The link color is white. */

  color: #fff;

  /* Removes the underline from the link. */

  text-decoration: none;

  /* Applies 20 pixels of margin to the right of each link

     creating a visual gap between the navigation links. */

  margin: 0 20px 0 0;

}

**** Do this
Style the last list item's anchor
Last list item of the navigation is styled.

The header nav ul li:last-child a selector targets the last list item's contained anchor (link).

Add the following CSS to style the last list item's anchor tag:

header nav ul li:last-child a {

  /* Removes the margin to the right of the last anchor tag

     so that the nav appears centered. */

  margin-right: 0;

}

Great job on making it this far in the lesson! So far, you've created a navigation bar for the mobile view using flexbox. Next, you will add a media query for the desktop view.
**** Media query for desktop

As mentioned earlier, the code that you've worked through so far was designed to be viewed on mobile devices. To tell the browser how to change the header, title, and navigation when viewed on a desktop, you need to add a media query for desktop.
**** Do this
Add a media query

Add the following media query for desktop:

/* When a web browser is larger than 600 pixels,

   apply these rules. */

@media all and (min-width: 600px) {

  header {

    /* Changes the default setting from `block` to `flex`. */

    display: flex;

    /* Pushes the items (the title and nav) to the far sides of the

       browser with space between them. */

    justify-content: space-between;

    /* Adds 0 pixels padding top and bottom, and 30 pixels padding

       left and right. */

    padding: 0 30px;

  }


  header h1 {

    /* Sets 14 pixels of margin above and below the `h1` and sets

        0 pixels of margin to the left and right. */

    margin: 14px 0;

    /* Removes or sets 0 pixels of padding above the `h1`. */

    padding-top: 0;

  }


  header nav {

    /*

      Pushes the navigation container down by 8 pixels to make it

      present a little better visually within the space.

    */

    margin-top: 8px;

  }

  /* Users cannot hover on mobile devices, so that is why you

     implement this behavior only for larger screens. */

  header nav ul li a:hover {

    /* Targets the change when a user holds the pointer over the anchor tag

       (link) within the list items within the unordered list that

       is within the navigation that is within the header. */

    color: #bdbdbd;

  }

}

At this point, your navigation bar will be fully responsive. Try it out in the browser.
**** Linking navigation

There are different navigation rules depending on if you are creating a single-page website or a multipage website.
**** Single-page navigation

When you create a single-page website, you'll add anchor IDs to the sections or other primary containers in your page. Don't forget to add the hash symbol # in the link; this will tell the link to look for the anchor ID somewhere on the page and jump to it when clicked. The navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="#home">Home</a></li>

      <li><a href="#about">About</a></li>

      <li><a href="#portfolio">Portfolio</a></li>

      <li><a href="#contact">Contact</a></li>

    </ul>

  </nav>

</header>

<main>

  <section id="home">

    <!-- All the Home section can be placed here. -->

  </section>

  <section id="about">

    <!-- All the About section can be placed here. -->

  </section>

  <section id="portfolio">

    <!-- All the Portfolio section can be placed here. -->

  </section>

  <section id="contact">

    <!-- All the Contact section can be placed here. -->

  </section>

</main>

**** Multi-page navigation

When you're linking to other pages that are all within the same directory, the navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="/">Home</a></li>

      <li><a href="about.html">About</a></li>

      <li><a href="portfolio.html">Portfolio</a></li>

      <li><a href="contact.html">Contact</a></li>

    </ul>

  </nav>

</header>

Tip

Websites usually set the home page link to the public root ("/"). This is because index.html is the default file in that directory, so it hides the /index.html filename from displaying in the browser address.
*** 18.8 html forms

**** Introduction to forms
HTML forms are very useful for web users. Below are just a few examples of what they can be used for:

Sending an email through a web page

Submitting purchase order information

Completing survey questions

Collecting user registration

Here are three examples of websites that make very good use of HTML forms:

First example of a website that makes good use of HTML forms.
Image source: HotJar's registration page

HotJar uses the HTML form to collect the user's full name and email address so that they can create a free basic account.

Second example of a website that makes good use of HTML forms.
Image source: Omada's contact page

Omada uses the HTML form in three different ways: asking if the customer has a Sales Inquiry, needs User Support, or wants Something Else. This way, Omada can tailor the input fields for the HTML form to collect the data that is most useful for their team.

Third example of a website that makes good use of HTML forms.
Image source: YummyGum's contact page

YummyGum uses HTML forms in a method that's similar to Omada's usage of forms. This page filters the user through four radio buttons, and then delivers tailored input fields for each topic.

**** HTML form basics
To create an HTML form, you can begin in one of these two ways:

<form action="process-form.js" method="post">
  <!-- Add the HTML input elements here -->
</form>

<form action="baseball-stats.js" method="get">
  <!-- Add the HTML input elements here -->
</form>
The <form> element does not have any visual design by default—but of course, you can still apply a background color or a border using CSS.

Within each <form> element are two attributes: an action and a method.

action: This attribute holds the URL to the server-side file where the data will be sent.

method: This attribute specifies the HTTP method—post or get—that will be used with the action.

post: This method can involve anything from storing or updating data, ordering a product, or sending an email.

get: Put simply, this method is used to retrieve data to display in the form.

There are various kinds of form fields that you can add to a form, including, but not limited to:

Text fields

Text areas

Radio buttons

Checkboxes

Drop-down list

Submit and reset

Fieldset and legend

Password field

You'll explore these commonly used form fields next.

**** Text fields
First name text field.
<form>
  <label for="name">First name:</label>
  <input id="name" type="text" name="name" />
</form>
The example above has two HTML elements: a label and an input.

The label tells users what information needs to go in a text field. It's connected to the input element with the for attribute as it links to the input's id.

The label is also important for accessibility. Assistive technologies such as screen readers use the label to tell the user what text should go in the text field. The label also makes it easier for users to interact with the text field by providing a larger hit area to click or touch.

The input has three attributes:

id: The id attribute gives the element a unique name so that the label knows how to connect with it.

type: The type attribute determines what type of control to render (for example, whether the user clicks a radio button, checks a checkbox, or enters text). For a text field, the type is set to text, which creates a single line of input text.

name: The name attribute is used to identify the input field when the entire form is submitted to a server.

**** Text field options
There are three additional attributes that can be used to style the text field.

autofocus: on: The autofocus attribute will set the first input to autofocus to help draw the user's attention to it. You only want this once on your page.

required: The required attribute will tell the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters added to the text field.

Here's an example of these attributes in use:

Attributes for text field styling
<form>
  <label for="location">Zipcode:</label>
  <input
    id="location"
    type="text"
    name="zipcode"
    autofocus="on"
    maxlength="5"
    required
  />
</form>
**** Do this
Add text fields to your form
In index.html, add the following code to create text fields to collect the user's name and zipcode:

<form>
  <div>
    <label for="name">Full Name:</label>
    <input id="name" type="text" name="name" />
  </div>
  <div>
    <label for="location">Zipcode:</label>
    <input
      id="location"
      type="text"
      name="zipcode"
      autofocus="on"
      maxlength="5"
      required
    />
  </div>
</form>
**** Text areas
Text area fields present the user with a multi-line input field so that they can enter an unlimited number of characters. These are best used for collecting a longer message. Here's what these fields look like:

Text area field example
As you can see in the code below, this HTML element has its own label.

<form>
  <label for="form-message">Your message:</label>
  <textarea id="form-message" name="message"></textarea>
</form>
These are the attributes that can change the way that the text area looks and works:

cols: Sets the visible width of a text area in character spaces. But it's better to use the width attribute in CSS.

rows: Sets the visible number of lines in a text area in character spaces. But it's better to use the height attribute in CSS.

autofocus: on: The autofocus attribute sets the first input to autofocus to help draw the user's attention to it. Remember, you only want this once on your page.

required: The required attribute tells the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters that can be added to the text field.

**** Do this
Add text areas to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
    ></textarea>
  </div>
</form>
This form states that it is a multi-line text field that will store the data within the name message. The autofocus is set to on, the field is required, and only 200 characters can be entered.

**** Fieldset and legend
The <fieldset> element is used to group together related inputs and labels. This will help web crawlers and screen readers, even if there is no visual representation here. The <legend> element is like a title for the <fieldset>.

Here's what these elements look like:

Related elements grouped by fieldset.
**** Do this
Add a fieldset and legend to your form
In the index.html file, group your name and location input fields within a set of fieldset tags, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input id="name" type="text" name="name" />
    </div>
    <div>
      <label for="location">Zipcode:</label>
      <input
        id="location"
        type="text"
        name="zipcode"
        autofocus="on"
        maxlength="5"
        required
      />
    </div>
  </fieldset>
  ...
</form>
Notice how the <fieldset> element is used to group the shipping information (i.e., name and location) together.

**** Placeholder text
The text field and text area field can both use the placeholder attribute to briefly describe the information that is expected in the field. This should just hint at what should be inputted rather than providing a full explanation; it's best to use a simple word or short phrase that demonstrates the expected type of data. The placeholder text cannot include carriage returns or line feeds.

Keep in mind that for accessibility and usability reasons, labels shouldn't be replaced by placeholders. Placeholder text disappears when the user types in the field, so if the user forgets what the form field is expecting as an input, the user would have to delete what they wrote to reveal the placeholder text again. Moreover, some screen readers may not even read placeholder text aloud.

Also, make sure that the placeholders you use have the appropriate CSS styling so that it is easy to read for your users.

Placeholder text examples.
**** Do this
Add placeholder text to the name and message fields
Add the placeholder attribute to your name and form-message fields, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input
        id="name"
        type="text"
        name="name"
        placeholder="Enter your full name"
      />
    </div>
    ...
  </fieldset>
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
      placeholder="How can I help you?"
    ></textarea>
  </div>
  ...
</form>
**** Password field
As you build more complicated forms, there may be times when you want to mask sensitive input fields by using the password field.

Password field.
Review the code below to get an idea of how the HTML works.

<div>
  <label for="password">Password:</label>
  <input id="password" type="password" name="password" minlength="8" />
</div>
The attribute minlength can be used to force the entry to be at least eight characters in length.

**** Do this
Add a password field to your form
In the index.html file, add the following password field to your form:

<form>
  ...
  <div>
    <label for="password">Password:</label>
    <input id="password" type="password" name="password" minlength="8" />
  </div>
</form>
Type into the password field and observe how the characters you type are hidden.

**** Radio buttons
Radio buttons allow the web user to select only one of the limited number of choices available. They look like this:

Radio buttons for colors.
To create a radio button, you'd have to set the type attribute of an input tag to "radio", as follows:

<input id="red" name="color" type="radio" value="red" />
The new attribute here is the value. The value is important because that is the data for the one selected item that will be submitted with the form data.

**** Do this
Add radio buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Favorite Color:</h2>
    <div>
      <input id="red" name="color" type="radio" value="red" />
      <label for="red">Red</label>
    </div>
    <div>
      <input id="blue" name="color" type="radio" value="blue" />
      <label for="blue">Blue</label>
    </div>
    <div>
      <input id="white" name="color" type="radio" value="white" />
      <label for="white">White</label>
    </div>
  </div>
</form>
There is no necessary order for the radio button's parameters, so you can place the input, name, and value in any order that you wish. When you click on the text of the radio button, the color is selected. That's because of the for attribute and how it matches up with the ID of the <input> element.

**** Checkboxes
Checkboxes allow the user to select one or more options from the number of choices available. They look something like this:

Check boxes for monster features.
To create a checkbox, you'd have to set the type attribute of an input tag to "checkbox", as follows:

<input name="scales" type="checkbox" id="scales" />
**** Do this
Add checkboxes to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Choose your monster's features:</h2>
    <div>
      <input name="scales" type="checkbox" id="scales" />
      <label for="scales">Scales</label>
    </div>
    <div>
      <input name="horns" type="checkbox" id="horns" />
      <label for="horns">Horns</label>
    </div>
    <div>
      <input name="wings" type="checkbox" id="wings" />
      <label for="wings">Wings</label>
    </div>
  </div>
</form>
**** Drop-down list
A drop-down list, also called a select menu list, is a toggleable menu that allows the user to choose one value from a predefined list. It tends to be more user friendly than a list of radio buttons when there is a long list of items. Drop-down lists look something like this:

Drop-down list for fonts.
To create a drop-down list, you'd have to use the <select> tag in conjunction with <option> tags. The <select> tag accepts the following attributes:

size: This sets the display of the drop-down menu to show a specified number of items. For example, if you wanted to show a list with 4 items out of 10, you'd set the size to 4 (size="4").

multiple: This option allows for the user to choose multiple sections in the drop-down menu.

**** Do this
Add a drop-down list to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="fonts">Choose a font:</label>
    <select name="fonts" id="fonts" size="1">
      <option value="arial">Arial</option>
      <option value="times">Times New Roman</option>
      <option value="comicsans">Comic Sans</option>
      <option value="papyrus">Papyrus</option>
    </select>
  </div>
</form>
In the above code, size="1" sets the display of the drop-down menu to show a single item, with the first of the list by default. Unlike all of the other inputs, it isn't recommended to try to update the style of an HTML drop-down menu using CSS. As you learn more about JS, you'll be able to create a clickable drop-down menu without using this input at all.

**** Submit and reset
Buttons are similar to links, but they are really important to have in forms. Whereas a link is used to navigate the user to a new page or resource, a button toggles something in the interface—which makes buttons perfect for submitting or resetting the data in a form. Buttons look something like this:

Submit and Reset buttons.
There are three types of buttons:

submit: Submit buttons send the data in the form to the backend program that collects the data.

reset: Reset buttons clear all of the data that has been changed in the existing form elements.

button: Buttons with type="button" have no default behavior. They are often used to trigger client-side functions or scripts that listen to the element's events.

**** Do this
Add Submit and Reset buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <button type="submit">Submit</button>
  <button type="reset">Reset</button>
</form>
Notice that the default presentation of a button looks very different compared to a link. A link may display as blue text with an underline, whereas a button is a rounded rectangle around the text.

Buttons have many uses beyond forms once you start working with JavaScript, but when you're only working with HTML and CSS, their use is usually limited to simple form controls.

**** Patterns
The pattern attribute is used to supply patterns that the user's input must match in order to be valid. A complete list of useful patterns can be found at HTML5Pattern.

For example, the pattern "\d{3}[\-]\d{3}[\-]\d{4}" will warn the user if they are not providing a correct 10-digit phone number in the xxx-xxx-xxxx format. The visual error that appears is a default with the browser.

**** Do this
Validate the phone number
Add the following phone input field, right above the Submit and Reset buttons:

<form>
  ...
  <div>
    <label for="phone">Phone #:</label>
    <input
      id="phone"
      type="text"
      name="phone"
      pattern="\d{3}[\-]\d{3}[\-]\d{4}"
      placeholder="xxx-xxx-xxxx"
    />
  </div>
  ...
</form>
An error message "Please match the requested format" will display if the phone number format is wrong when you press the Submit button.

**** More input types
There are many more input types that you can use in a form. You can find additional ones at MDN: Input Types.

** module 19 css frameworks
*** 19.1 overview: css frameworks

Key Terms
CSS framework
A library of various web design components that can be applied to multiple projects

To help with this complexity, some designers have created CSS frameworks.
A CSS framework provides various components that you can plug in to your website and thoroughly customize.
CSS frameworks can increase your productivity and help you design a clean-looking website, even if you're not a great designer yourself.

*** 19.2 using a framework

Key Terms
Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly
Spaghetti code
A pejorative term used for program code written without a coherent structure

**** What is a framework?
You'll often hear about CSS frameworks, but the concept of a framework actually appears across the technology stack. A framework, when applied to any language, typically refers to reusable code that provides an opinionated solution to common problems. For example, a CSS framework typically provides prestyled elements and requires that you use certain elements or classes to design your website. In short, a CSS framework is CSS that someone else wrote to help you make incredible websites.

In exchange for following a preset pattern, you gain a number of benefits from the imported code. CSS frameworks vary immensely, but almost all of them allow you to achieve some things much more quickly and easily than would be possible if you were to write all of your own CSS.

These are some time-saving functionalities that are common across most CSS frameworks:

Organizing the layout of your page

Building responsive websites

Maintaining consistency across your pages

In exchange for these benefits, you often have to do the following tasks when using CSS frameworks:

Use certain elements or class names

Organize and nest your elements in a particular way

Include external stylesheets and potentially external JavaScript

**** Examples
The most popular CSS framework by far is Twitter Bootstrap. With robust documentation and plenty of support from one of the largest tech companies, Twitter Bootstrap has come to define CSS frameworks.

In large part, this is because Bootstrap looks both simple and clean.

Screenshot of the Bootstrap home page, reading "Build fast, responsive sites with Bootstrap."
There are also other popular CSS frameworks, a few of which are listed below. Note that although each of these frameworks can differ, they have more similarities than differences.

Pure.css

Materialize CSS

Bulma

**** Customization
CSS frameworks typically provide a few CSS files to include as part of your project. But this doesn't mean that you can't write your own CSS to go on top of it!

In fact, many websites start with a CSS framework as a base, and then design on top of it. For example, all of the websites showcased on Bootstrap Expo make use of Bootstrap—and yet each one looks very different. If you're interested, take a moment to scroll through Bootstrap Expo and get an idea of what's possible with Bootstrap.

With that said, just adding CSS on top of existing CSS can lead to confusing code. It's important to be thoughtful when adding to or modifying existing CSS—and this is particularly crucial if you're working on a large project.

**** Problems
CSS frameworks can be powerful tools, but they don't come without their own problems and detractors. Here are some of the biggest complaints about CSS frameworks:

CSS frameworks can lead to what is known as spaghetti code. This occurs when developers don't understand how the CSS code they are adding to works but continue to add more and more CSS elements, making the code even more difficult to understand.

CSS frameworks often rely on <div> elements and other non-semantic elements, making pages less accessible to certain types of users.

CSS frameworks can lead to websites looking too similar to each other. When you get familiar with Bootstrap, you'll start to notice lots of websites that use Bootstrap.

As with any tool, using a CSS framework should be a conscious and active choice that you're making. You'll make use of CSS frameworks in this module, but keep in mind that a CSS framework won't always be the best decision.

**** How to add a CSS framework
Installing and getting started with using a CSS framework is quite simple; many frameworks make it as easy as possible to begin using them.

There are a few ways to include a CSS framework, depending on your setup. However, the most common method is to include a link to a file hosted on a content delivery network (CDN). A CDN is a distributed group of servers used to host files for the web. CDNs make it efficient for many people to access the same file at the same time.

To link to a CDN, you essentially add a stylesheet that has an external URL as its href value. You can usually find a framework's CDN link early on in its documentation.

**** Do this
View your index.html file
Before you add Bootstrap, use your browser to open your existing index.html file. Take notice of the style and formatting, even though there's only an <h1> element.

**** Use Bootstrap on your page
Your page will look something like the image shown below:

Your index.html page before adding bootstrap
To add Bootstrap to your page, visit Bootstrap's website and scroll down to the jsDelivr section shown in the image below.

A screenshot of the jsDelivr section on the installation page
Copy the <link> element that's referenced in that section, and add it to the <head> of your index.html page. For now, ignore any requirements to include <script> tags.

Tip
You don't need to run npm install or anything from your command line. Make sure that you look for the CDN instructions.

When you refresh your page, you will notice that the style is slightly different. You're now using Bootstrap on your page!

The index.html page after using Bootstrap

*** 19.3 grids



Key Terms
Grid
A structural system of horizontal and vertical gridlines that helps ensure that your website is well-aligned and quickly scalable
Responsive
The property of allowing a layout to change dynamically based on the size of the screen
Mobile-first
A layout where the default configuration is for narrow screen and mobile devices
CSS container
The most basic conceptual element in most frameworks, used to encapsulate and pad the rest of the page

**** The grid system
Many websites are organized in very similar ways. The existence of headers, footers, and sidebars showcases that when it comes to the design of many web pages, developers and designers rely on certain elements to convey their sites' messages.

One way that CSS frameworks make this easier is by providing a grid. A grid allows you to easily organize your website so that it is well aligned and quickly scalable. Modern CSS frameworks also include classes that make it easier to build responsive grids, making the transition from mobile to desktop seamless.

A grid in most CSS frameworks is separated into columns and rows. It's standard for most CSS grid frameworks to have 12 columns and any number of rows.

An example of a grid in CSS
In the above example, you can see 12 columns marked in dark gray. Each colored section generally represents a horizontal row.

In terms of the grid system, the following statements are true of the above image:

The header is the first row on the page. It spans all 12 columns.

The nav spans three columns, in contrast to the container that is wrapping both the content and the footer. The nav also goes across two different rows.

Both the content and the footer are included together in their own container. They span nine columns. The content and footer are each in their own separate row.

Most websites fit into this kind of structure that prioritizes containers, rows, and columns. In the following sections, you'll learn more about these concepts and how they apply to Bootstrap.

**** Do this
Grid your view
Take a look at the page on which you're currently reading this lesson. Can you visualize it as a grid? Take a moment to think about how many columns each part of the page might be, as well as how many distinct rows you see on the page.

**** Containers
A CSS container is the most basic conceptual element in most frameworks. CSS containers are used to encapsulate and pad the rest of your page. CSS containers aren't usually nested inside of each other.

If you use the grid system from Bootstrap, you will need at least one container on your page.

To make an element into a container, you simply need to add a class of .container to it. Any element can be a container, but it's most typical for the .container class to be added to a <main> or <section> element.

<main class="container">
  <!-- ... -->
</main>
**** Do this
Use a container
The best way to see what a container does is to use one. Replace your <body> code with the following code:

<body class="container">
  <h1>Hello, there!</h1>
</body>
Refresh your page to see the difference. Do you see how there's now padding to the left of the heading? This padding is provided by the container.

**** Rows and columns
Rows wrap around any elements that are grouped horizontally on the page. Rows must be inside of a container element.

As you might expect, rows use the .row class, and columns generally use the .col class.

Each row contains a number of columns. Bootstrap allows for a lot of variety in how columns are used, but columns must be inside of a <div> with a .row class element.

Take a look at the Replit below, which shows a single row with a single column in a single container.


In general, there isn't much that is remarkable about this code. But you should notice that several wrapping <div> elements are needed to make use of rows and columns.

Now, take a look at the Replit below. It makes use of two columns, and each column is outlined in a different color. If the screen is too small, try opening this Replit in its own tab.


As you might have noticed, the above Replit has two columns of equal width taking up the page. You can continue to add more columns next to each other, and each one will take up a similar width. That's because rows and columns make use of flexbox.

**** Do this
Include rows and columns
Replace your <body> element with the following code:

<body class="container">
  <div class="row"></div>
</body>
Then, add three columns inside of the .row. Add a paragraph with some text to each, so that you can see the separation.

Below, you can see a potential solution to this challenge.

<body class="container">
  <div class="row">
    <div class="col">
      <p>
        Bears are mammals that belong to the family Ursidae. They can be as
        small as four feet long and about 60 pounds (the sun bear) to as big as
        eight feet long and more than a thousand pounds (the polar bear).
      </p>
    </div>
    <div class="col">
      <p>
        They're found throughout North America, South America, Europe, and Asia.
      </p>
    </div>
    <div class="col">
      <p>
        They have nonretractable claws, short tails, and excellent sense of
        smell. They're typically solitary, except for mothers with cubs.
      </p>
    </div>
  </div>
</body>
**** Varied column sizes
In the documentation, you might have noticed .col classes with additional text next to them. When a number follows a column, as in .col-4, it defines the size of the column. Recall that the grid system is typically based on 12 columns. The .col-4 class means that the selected element will take up 4 out of the 12 columns. Any columns with a .col class will equally share the rest of the space.

In the following Replit, the first column is set to .col-9.


As you can see, this first column takes up more space than the remaining column.

**** Responsiveness
Similarly, it's possible to make your columns and rows responsive. Bootstrap is developed to be mobile-first, which means that it's assumed that users will be viewing your site on mobile.

Bootstrap has a feature that you can use to make the column sizes adapt to different screen sizes. There are four different sizing terms that you can add to your columns:

sm: For small devices and landscape phones

md: For tablets and smaller computers

lg: For desktop computers

xl: For large monitors

More information about the exact breakpoints can be found at Bootstrap's documentation on responsive breakpoints.

Here's an example:

<body class="container">
  <div class="row">
    <div class="col col-lg-8">
      <p>col col-lg-8</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
  </div>
</body>
In the example above, on large screens, the left column (.col-lg-8), will take up most of the space. As the screen size decreases, all of the columns will eventually end up being the same size.

**** Do this
Add responsive classes
Add responsive classes to your current work. Use a mix of lg and md classes and test out the difference.

**** Using the documentation
This lesson won't cover every single aspect of the grid system. Instead, you can explore the Bootstrap documentation. The bootstrap documentation is excellent and gives many examples.

For example, Grid: Setting one column width, which is part of Bootstrap's grid documentation, lays out information on varied column widths.

And Grid: Responsive classes describes how rows and columns can be set to be responsive.

You don't need to memorize everything on the Bootstrap website. Instead, rely on it as a tool for learning and solving problems.

*** 19.4 common components and utilities

**** What else can Bootstrap do?
CSS frameworks gained popularity through the grid system, but many of these frameworks now also include common components and utility classes that you can add to your website. This makes it easy to quickly add common styling. In the following sections, you'll learn about some of the most common components and classes. Wherever possible, links to the appropriate documentation will be included.

**** Common components
There are too many components to cover here, and many of them have already been described on the Bootstrap website. For demonstrations of available components, visit Bootstrap's page on components.

Below is a list of some of the most common components:

Alerts

Buttons

Card

Forms

Jumbotron

Navs

You can use these components in Bootstrap and other frameworks.

Some components require supporting JavaScript files to use. Although you can use these components, it's suggested that you actually avoid them until you've learned more about using JavaScript with HTML and CSS.

The components described above require the use of certain classes and structures to make them work. Note that the majority of these are intended to be used inside of a container, row, or column.

**** Do this
Include common components
Add a styled button to your page. To keep things organized, make sure that it appears inside of a .col class. Try changing the color and size using the various classes described.

Next, add a card to your page. Try placing it inside a column and adding or removing elements.

**** Borders and colors
There are a few classes in Bootstrap that allow you to add borders and colors to your containing elements. These are easy to use and can be useful for quickly adding a bit of style to your code.

You can explore the documentation using the links below:

Bootstrap: Borders
Bootstrap: Colors
**** Do this
Use borders and colors
Use the .border border-primary class, the .text-danger class, and the .bg-dark class on your page.

**** Text
Bootstrap allows utility classes that you can use to modify text in a variety of ways.

You can explore the documentation here:

Bootstrap: Text
Perhaps the most useful text-modification classes are those that allow you to align your text quickly, like .text-center.

**** Do this
Align your text
Use the .text-center class on your index.html page. Notice from the documentation that this class also allows for responsive text!

**** Spacing
Bootstrap also provides a few utility classes that make it easy to add margins or padding to elements. These rely on a lot of abbreviations, so you'll need to read the documentation carefully.

You can explore the documentation here:

Bootstrap: Spacing
**** Do this
Add margin and padding
Try using the .py-2 class and .mb-4 class. What does each abbreviation represent?

**** Flex
It's important to know that Bootstrap can't solve every layout problem with rows and columns. Some layout problems require a more nuanced solution.

Bootstrap provides some utility classes that allow you to apply CSS rules to individual elements. For example, there are a few classes that just apply flexbox rules to elements.

You can explore the documentation here:

Bootstrap: Flex
Note that using these classes can conflict with rows and columns. That doesn't mean that you can't use them together; just be wary of overlapping styles!

** module 20 javascript and the DOM
*** 20.2

Key Terms
Document Object Model
DOM, the data representation of the HTML elements that make up the structure of a web page, serving as a way for JavaScript to understand the structure of an HTML page in order to make it dynamic
Child element
An element that's nested inside another element
Parent element
An element that has one or more elements nested inside it

**** Why use JavaScript?
JavaScript was originally designed to work with HTML on a web page. When applied to a web page, JavaScript is used to add some interactivity or to make the page more dynamic. You may have seen websites that use JavaScript to do the following:

Create animations

Respond to actions that the user performs

Validate user input on forms

Load data dynamically

**** The <script> tag
To include some JavaScript on a page, add an HTML <script> tag to the bottom of the <body> element. The <script> tag takes an attribute named src; this attribute specifies the JavaScript file to be included. Here's an example:

<script src="/path/to/your/script.js"></script>
If your browser happens across a <script> tag when it's rendering a requested web page, it will request the file and execute it immediately.

**** Do this
Create two files
On your machine, create a new folder for a new project. In that folder, create two files named index.html and index.js. The index.html file is a simple HTML page with a <script> tag referencing index.js. Copy the following code into the respective files.

Here's the code for the index.html file:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <h1>Welcome to my website</h1>
    <script src="index.js"></script>
  </body>
</html>
And here's the code for the index.js file:

console.log("Hello!");
Once you've added the code to both files, open the HTML page in your browser and observe the console in the developer tools. Notice that the JavaScript code is executed as the page loads.

**** Embedding JavaScript
In addition to linking to an external file, you can include JavaScript directly on the HTML page within the <script> tags. Here's an example:

<script>
  console.log("This is embedded JavaScript");
</script>
But generally, it's best to avoid embedding JavaScript in an HTML page like this; it isn't a very scalable solution.

**** Do this
Add some <script> tags
Add a few <script> tags to the HTML page from above, and open it in the browser. Each set of tags may simply log some text. Notice that each <script> tag is executed in turn as the page loads.

Tip
The <script> tags should be added to the bottom of the <body> element.

**** The <noscript> tag
What happens if one of your users cannot run your script? You still want that user to have a good experience on your website. Some users deliberately turn off scripts or may be unable to run scripts for a number of reasons. At the very least, you should show these users a message indicating that the website depends on scripts. To do so, use the <noscript> tag, like this:

<noscript>This site requires JavaScript.</noscript>
To see this in action, you will need to temporarily disable JavaScript in your browser.

**** Do this
Add <noscript> to page
Add the <noscript> tags (as shown above) to the HTML page. Then reload the page in the browser.

**** Disable JavaScript
Open the Chrome DevTools console by pressing Control+Shift+J (or Command+Option+J on a Mac). Then press Control+Shift+P (or Command+Shift+P on a Mac) to open the command palette.

The Chrome DevTools console
Type javascript to filter the commands to show only those that relate to JavaScript.

Type javascript to filter the commands
Click the Disable JavaScript option, and JavaScript will be disabled in your browser. Try reloading the page, and observe that the <noscript> tag kicks in now that JavaScript isn't available.

**** Document Object Model
When your web page is loaded by the browser, it is parsed, and the browser constructs an internal representation of the HTML. This facilitates the browser's interaction with the HTML. You can also use JavaScript to interact with the HTML via this internal representation. This representation, which is called the Document Object Model (DOM), is the data representation of the HTML elements that make up the structure of a web page. The DOM is how the browser sees your HTML.

Consider the following simple HTML file:

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <header>
      <h1>List of Parks</h1>
    </header>
    <main>
      <ul>
        <li>Biscayne</li>
        <li>Grand Canyon</li>
        <li>Gateway Arch</li>
        <li>Indiana Dunes</li>
      </ul>
    </main>
  </body>
</html>
Notice that the entire document is enclosed in the <html> element. The <html> element is called the root of the DOM.

Observing carefully, you can see that there are two elements directly inside the <html> element: the <head> and the <body>. These are called the children of the <html> element, and the <html> element is the parent of these two elements. The following diagram illustrates this relationship:

Parent and children elements
A parent element nests other elements. An element that is nested inside another element is called a child element.

As you examine the HTML document further, you can see that the <body> element itself also nests some elements. That is, <header> and <main> are children of <body>. Additionally, the <h1> inside the <header> is a child of the <header>. And <main> contains a <ul>, which in turn contains four <li> elements. You can also see that the <head> element has three children.

All of these relationships can be added to the diagram. The result, shown below, is a complete diagram of the DOM the way that the browser represents it.

Diagram of the DOM the way that the browser represents it
You may have noticed that the structure of the DOM resembles a family tree, except that each child has a single parent. The family tree terminology is used when talking about the relationships between the elements of the DOM. You may refer to the parent of an element, the grandparent of an element, the siblings of an element, and so on.

**** Summary
As you learned in this lesson, adding JavaScript to an HTML page is as simple as adding a <script> tag to the page. Although it is possible to write JavaScript directly on the page, it is preferred to link to external JavaScript files.

The DOM is a treelike structure used by the browser to represent and interact with the HTML document.

*** 20.3


Key Terms
Node
An element in a tree structure
NodeList
A list of elements that match a given selector

**** Exploring the HTML
Before you start writing code to work with this HTML, examine the HTML a bit and see if you can think of it in terms of the DOM. Look at the index.html file and try to think about what the DOM structure may be.

You can see that in the <body>, there is a <main> containing four <section> tags. Each of these contains the details of one park. Look carefully at the structure of the HTML in those <section> tags.

**** Do this
Sketch the DOM
Use a piece of paper (or any online drawing tool) to quickly sketch the DOM structure diagram for one of these sections. Do not spend more than five minutes on this exercise. When you are done, compare your sketch to the illustration below.

The following diagram shows one possible solution; note that it shows only part of the DOM. For convenience, siblings are colored the same, and the class names have been included.

DOM structure diagram
**** Accessing the DOM
The browser makes all of the page's HTML accessible via a global variable named document. This variable is available to your JavaScript and contains a reference to the entire HTML document. You can see this by logging the document variable and observing it in the console.

**** Do this
Log the document variable
Add the following code to the index.js file and reload the page in the browser.

console.log(document);
Then open Chrome DevTools and take a look at the console.

Chrome DevTools console with document
Notice that the entire HTML document is logged to the console. You can use the expander arrows to drill down into the document and verify that all of the elements of the HTML are present.

**** Finding an element with querySelector()
Now that you have access to the entire HTML document, you can try to select some elements in the DOM. You can use the built-in querySelector() method to search the DOM. The querySelector() method accepts a string representing a CSS selector. Then it returns the first element in the DOM that matches that selector.

For example, to find an <h1> element on the page, you can use the following syntax:

const heading = document.querySelector("h1");
console.log(heading);
Place the above code in the index.js file and reload the page in the browser. The querySelector() method will traverse the DOM, starting from the root, and find the first <h1> element. In the case of the example web page, the first <h1> element is <h1>National Parks</h1>.

**** Selectors
In the querySelector() example above, the string "h1" was used as a selector. What are some of the other ways that you can specify selectors?

Well, there is a very simple rule: a selector is any valid CSS selector.

You have already seen several types of CSS selectors. Here are just a few of them:

Selector
Description
Examples
Type selector
Targets any HTML element name
h1, p, section
Class selector
Targets elements based on the value of the class attribute
.location, .stats
Id selector
Targets elements based on the value of the id attribute
#rating, #area
Note that in the selector string, a period . prefix is used to indicate a class, and a hash symbol # prefix is used to indicate an ID.

All the CSS selectors are fully documented on MDN's CSS selectors page. You may use any of those selectors as an argument for querySelector().

**** Do this
Select elements
For each of the elements described below, write a statement in the index.js file to find the element. To check that you found the right element, you may log the element that you find to the console.

Find an element with the class value.

Find a <button> element.

Find an element with the class area.

Find a <div> that is a descendant of an element with the class stat. (Hint: Look up descendant selectors in the documentation).

Find an element with the class hello. Take careful note of what is returned there.

**** Collections of elements with querySelectorAll()
You may have noticed that querySelector() returns the first matched element in each example above. But what if you wanted to get all the matched elements? For that, you can use querySelectorAll(). The querySelectorAll() method accepts a string representing a CSS selector. It then returns a list of elements that match the selector.

The selector used for querySelectorAll() follows the same format as with querySelector(). The main difference is that querySelectorAll() returns a list of all matched elements.

**** Do this
Find all <button> elements on the page
Add the following code to the index.js file and reload the web page in the browser.

// Find all the buttons on the page
const buttons = document.querySelectorAll("button");
console.log(buttons);
Then look at the console to see what was logged. You'll see something like this:

Buttons logged to the DevTools console
You may use the expander arrows to drill down into the elements if you wish.

**** Working with NodeList
When you logged the value returned by the querySelectorAll() method, it stated that it was a NodeList. But what exactly is a NodeList?

Node is a term used to describe an element in a tree structure. Sometimes, the elements in the DOM are referred to as nodes, because the DOM is a tree structure. A NodeList, then, is a list of elements that match the selector.

Typically, you'll want to iterate over the list of elements found and process them in some way. The NodeList isn't an array, but it provides several properties and methods that allow it to be processed like an array.

You can iterate over the NodeList using the values() method, as shown below:

// Get a list of all `<h3>` elements
const heading3List = document.querySelectorAll("h3");

// Iterate over the list and print each one
for (let element of heading3List.values()) {
  console.log(element);
}
Or you can use a simple for loop to iterate over the NodeList, like this:

for (let i = 0; i < heading3List.length; i++) {
  const element = heading3List[i];
  console.log(element);
}
Notice that in this second example, the length property of the NodeList and the square bracket [] notation are used to access individual items in the NodeList.

**** Do this
Use querySelectorAll()
First, run the two examples above to verify that they behave the way that you expect. Then try the following:

Get a list of all the <div> elements containing ratings on the page. Log them to the console using the values() method.

Get a list of all the <div> elements containing areas on the page. Log them to the console using a simple for loop.

**** Supporting older browsers
Very old browsers (and Internet Explorer in particular) don't fully support the NodeList interface. As such, the code above may not work as intended. If you need to support Internet Explorer, you can use the Array.prototype.forEach() method, like this:

// Get a list of descriptions
const list = document.querySelectorAll(".description-display");

// Log them to the console
Array.prototype.forEach.call(list, function (element) {
  console.log(element);
});
Note: Recall that in JavaScript, arrays are list-like objects. The Array class is used to construct new arrays. The prototype constructor is commonly used to add new properties and methods to the Array object. You can find a list of available instance methods for Array.prototype in Mozilla's JavaScript Reference.

*** 20.4

**** Modifying an element
Once an element has been selected using querySelector() or querySelectorAll(), you have access to many of its properties and can change some of them. In this section, you'll learn how to implement three common changes that may be made to an element. You'll learn how to change the text contained in an element, change the value of an attribute, and change the CSS style of an element.

**** Changing the content
When you look at the National Parks example web page, you can see that the descriptions of the various parks are all of different lengths. Suppose that you wanted to limit the length of these descriptions to 250 characters and add an ellipsis ... to those that were truncated.

First, you will have to select all the descriptions on the page. You can use a class selector, because all the descriptions are in <div> elements with the class description. Here's an example:

const descriptions = document.querySelectorAll(".description-display");
Next, you will iterate through the list of descriptions and get the text for each one. Each item returned by querySelectorAll() is of type HTMLElement. HTMLElement is a built-in interface that exposes properties and methods common to all elements that are found in an HTML document. HTMLElement is fully documented on MDN's HTMLElement page.

**** The innerText property
One of the properties exposed by the HTMLElement interface is the innerText property. The innerText property contains any text that is contained between the opening and closing tags of the element.

For example, you can iterate through the descriptions and log the innerText value of each description, like this:

for (let desc of descriptions.values()) {
  let content = desc.innerText;
  console.log(content);
}
**** Do this
Log each description
Write the code above in the index.js file and reload the page in the browser. Notice that the description text of each park is logged to the console.

Truncate the text
You can now use string methods to truncate these strings to 250 characters and add ellipses if they are longer than that. You can use the slice() method.

Now, try updating the text using the slice() method to allow for only 250 characters.

If you get stuck, you can consult this solution:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  console.log(content);
}
Once you've accomplished this, observe that each description is truncated and ellipses are attached to the ends. The only exception is the description for Gateway Arch park; that description was already shorter than 250 characters.

Update the HTMLElement
You can now update the HTMLElement, using the innerText property and the truncated text.

Update your code to include the following assignment to desc.innerText.

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  desc.innerText = content;
}
Now, once the page loads, you'll see that the description of each park is less than or equal to 250 characters, plus the ellipses.

**** The innerHTML property
What if you wanted the ellipses that you added above to be clickable? You can wrap an ellipsis in <a> tags to make it into a link. Now, update the code above to use a link instead of a plain string, as follows:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerText = content;
}
Now, when you look at the resulting page, you can see that the browser didn't interpret the additional content as HTML at all. Rather, it displayed the string that was added literally, exactly as you wrote it. You can also see this in the image below:

Biscayne National Park
That literal interpretation isn't a good experience for the users. If you want the browser to interpret the string that you provide as HTML, use the innerHTML property. The innerHTML property represents the HTML markup contained inside of an element.

You can modify line 9 in the code above to use the innerHTML property instead of the innerText property, like so:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerHTML = content;
}
**** Changing the style
To change the CSS style of an element, you can use the element's style property. This property is used to get and set the inline styles of an element. This style property is an object representing all of the CSS styles associated with an element. You can use this object to set any style that you wish.

Suppose that you wanted to bold any rating value that is greater than 4.7. You would have to select all rating values, check if they match the condition, and add a style to those that do. You can start by selecting all rating values, as follows:

const ratings = document.querySelectorAll(".rating-display .value");
Next, iterate through the list and get each actual rating value using the innerText property. This returns a string value, but you want to work with the rating as a number. So, use the parseFloat() method to convert a string into a floating point number, as shown below:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);
  console.log(ratingValue);
}
Next, check the condition. If ratingValue > 4.7, then set the fontWeight style to bold, like this:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
  }
}
The name of the JavaScript property relates to the name of the CSS property. In CSS, a hyphen - is used in property names such as font-weight or background-color. But in JavaScript, the hyphen is dropped, and camelCase is used to create the property name. In other words, property names in JavaScript look like fontWeight or backgroundColor.

Here's another example of a modified style property. The following code sets the color of the rating text to a lighter green if the rating is greater than 4.7.

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
    rating.style.color = "#3ba17c";
  }
}
A complete list of the CSS style properties and the corresponding JavaScript names for those styles may be found in MDN's CSS Properties Reference.

**** The classList property
Alternatively, if you want to make many changes to the style of an element, you could create a CSS class for that style. You could then add or remove that class from the element using the classList property.

The classList property is a list of the classes that are applied to an element. It provides methods to add() and remove() classes.

**** Do this
Dynamically add classes
Add the following CSS class rule to the style.css file.

.high-rating {
  color: #3ba17c;
  font-size: 1.5rem;
  font-weight: bold;
  text-shadow: 1px 1px rgba(0, 0, 0, 0.2);
  text-align: center;
}
When the rating is greater than 4.7, you want to replace the value class with the high-rating class. Modify the JavaScript code to do this, as follows:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.classList.add("high-rating");
    rating.classList.remove("value");
  }
}
**** Creating DOM elements
In the examples above, you saw that you can add to the DOM using the innerHTML property of an element. Below is another example of creating new elements, using the createElement() method. The createElement() method creates a new element with the given tag name.

After creating an element, you will want to add the element to the page using the appendChild() method. This method adds a given element to the end of the list of children of a parent element.

**** Do this
Create a new element with text
Suppose that you wanted to dynamically add a statement to the page's heading, stating the number of parks on display. To do this, you would start by selecting all the parks on the page and getting the number of parks from that list. Then you would construct an element with this information and insert it on the DOM at the right place. Work through this process step by step below.

First, select the parks on the page using the park class as a selector:

const parks = document.querySelectorAll(".park-display");
Then, get the number of parks using the length property of the list:

const numberParks = parks.length;
Next, create a new element. In this case, you should use a <div>:

const newElement = document.createElement("div");
This creates an empty element. But, you have access to all the properties and methods that were used above to modify an element. You can set the text of this element with the innerText property, like this:

newElement.innerText = `${numberParks} exciting parks to visit`;
Add style and classes
You can also style this new element with either the style property or the classList property. Create a new CSS rule for the class header-statement in the style.css file, as shown below. Feel free to add any style that you wish.

.header-statement {
  color: #ffffff;
  font-size: 1.2rem;
}
Then add this class to the new element, as follows:

newElement.classList.add("header-statement");
Add the element to the page
Finally, to add the new element to the DOM, select the <header> element and use the appendChild() method to add the new element to the <header>, as shown below.

const header = document.querySelector("header");
header.appendChild(newElement);
**** Removing DOM elements
You can remove elements from the DOM via the removeChild() method, which removes the provided node from the DOM.

For example, you can select the first park on the page and remove it, as demonstrated here:

// Get the parent element of all parks
const main = document.querySelector("main");

// Select a single park
const park = main.querySelector(".park-display");

// Remove that park
main.removeChild(park);

*** 20.5

**** Event
When a web page is loaded in your browser, it basically sits there doing nothing, waiting for you to read it. As you start to read, you may attempt to scroll to view more of the page, or you may see links and buttons that invite you to click. As you move your mouse pointer around, the page starts to respond. You may see menus open, or animations start, or annoying ads pop up.

These actions, which are called events, all occur in response to some action that you are taking. An event is an action or occurrence that happens in the browser. The system fires an event when certain actions occur.

Key Term
Event: An action or occurrence that happens in the browser

There are many different types of events that occur in the browser. Here are some examples:

Mouse movement, clicks, or dragging

Typing on the keyboard

Touching and swiping on a touch screen device

Resizing the browser window

Closing the browser window or tab

Submitting a form

The web page finishing loading

To learn more about the many types of events that occur in the browser, check out MDN's Events page.

You can respond to these events by writing a function that will run when the event fires. These functions are called event handlers.

Key Term
Event handler: A function that is executed in response to an event occurring

**** Event listeners
When you create an event handler, you need to associate it with an element in the DOM. For example, the user may click a button. You then register an event handler on the button to run when the button's click event fires. The mechanism that detects the event is called an event listener. An event listener contains an event name and an event handler. When the event fires, the event handler is executed.

Key Term
Event listener: A mechanism that detects an event and contains an event name and an event handler

To create event listeners, use the addEventListener() method. This method takes two arguments: the name of the event and an event handler.

Using the National Parks repository, you can add some event listeners to the page.

**** Do this
Add event listener to a button
First, select a button on the page. Write the following code in the index.js file.

const firstBtn = document.querySelector("button");
Then call the addEventListener() method on this button. For now, you will write a very simple function for the event handler:

firstBtn.addEventListener("click", (event) => {
  console.log("You clicked the button", event);
});
Reload the page in the browser, and try clicking the first button on the page. The event handler accepts a single parameter representing an event object. This event object encapsulates some details about the event that occurred. Observe the output in the console.

**** Details about the event
The event object that is passed to the event handler contains some information that you can use while handling the event. The event object is automatically passed to event handlers when they are invoked. They contain information relevant to the event itself.

For example, you can get the specific element that fired the event with the target property of the event object, as shown here:

firstBtn.addEventListener("click", (event) => {
  console.log(event.target);
});
This is especially useful when you attach the same handler to multiple elements. For example, you may want to highlight a park when the button associated with that park is clicked. You could attach the same event handler to each of these buttons. Take a look:

// Select all the buttons for all the parks
const allBtns = document.querySelectorAll(".rate-button");

// Iterate through the list of buttons and add an event handler to each
allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target);
  });
});
Notice that when you click any of the buttons, you get the same result. So how would you know which park belongs to the button that was clicked?

The <section> element that represents a park is the parent of the button. Because event.target refers to the button that was clicked, then using the parentNode property of that button will get you the <section> element that was clicked. Here's what that looks like:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target.parentNode);
  });
});
Notice that each time you click the button, the <section> element in which that button resides is logged to the console. You can then manipulate this element in any way that you wish. For example, the following code changes the background color:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  });
});
**** A complete example
Suppose that you wanted to give the user the ability to sort the list of parks displayed on the page; you want them to be able to sort by either name or rating. You can add two links and allow the user to click whichever one they wish. You would then get the list of parks from the DOM, perform a sort on the list, and insert the parks back into the DOM in the new order.

Start by adding the following HTML to index.html. Insert this between the <header> and the <main>.

<div class="sorter">
  Sort by:
  <a href="" class="sort-link" id="name-sorter">Name</a> |
  <a href="" class="sort-link" id="rating-sorter">Rating</a>
</div>
Then, optionally, you could add some CSS to the style.css file.

.sorter {
  width: 90%;
  margin: 0 auto;
  padding: 6px;
}
Next, add an event listener to the link. You will build this in steps so that it is clear what each step does. The following code all goes in the index.js file.

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  console.log("You clicked the name sorter");
});
Notice that you are selecting the link by the ID. However, when you click the link, the log in the console blinks for a moment and then disappears. Why is that?

The default behavior of a link is to follow the link that was clicked. In this case, the browser is simply reloading the page. That clearly isn't what you want. You can stop this from happening using the preventDefault() method of the event object:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();
  console.log("You clicked the name sorter");
});
This time, when you click the link, the page doesn't reload. Here is the logic that you will implement in this event handler:

Get the <main> element that contains all the parks.

Get a NodeList of all the parks.

Empty the <main> element.

Convert the NodeList to an array for convenience of sorting.

Sort the array using techniques that you learned previously.

Iterate through the sorted array and append each park to <main>.

Remember, you'll build the event handler step by step. Start by reviewing the code for the first three steps:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";
});
If you run the above code, you will notice that the parks disappear from the page when the link is clicked. That is because you removed them from the DOM. However, they still exist and can be referenced from the parksList variable.

To create an array from the NodeList, use the Array.from() method, as shown below. This takes an array-like structure and constructs an array.

// 4. Create an array
const parksArray = Array.from(parksList);
You can now use the sort() method of the array to sort this array. However, you need to write the function that defines how to sort the parks. Given two park elements, you need to find the name of each park and then compare the names. The park names are the innerText of the <h2> element.

// 5. Sort the array
parksArray.sort((parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
});
The final step is to iterate over this sorted array and append each park element to the <main> element.

So, the full code may look like this:

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1. Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort((parkA, parkB) => {
    const parkAName = parkA.querySelector("h2").innerText;
    const parkBName = parkB.querySelector("h2").innerText;
    if (parkAName < parkBName) {
      return -1;
    } else if (parkAName > parkBName) {
      return 1;
    } else {
      return 0;
    }
  });

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
});
As you can see, the event handler code has gotten quite long. To help make the code more manageable, you can refactor this code by creating an external function for the event handler, and another for the sorting. The following code is equivalent to the above.

// Function for sorting by name
const sortByName = (parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};

// Function for handling the `nameSorter` click
const nameSorterClickHandler = (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort(sortByName);

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
};

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", nameSorterClickHandler);
**** Do this
Sort parks by rating
Implement an event handler for the ratingSorter link. Use the above example as a template.

**** The DOMContentLoaded event
So far, you have been writing the JavaScript code to interact with the DOM without regard to whether the DOM has been fully loaded by the browser. In this fairly small web page that you are using as an example, this hardly matters. But what happens when the web page becomes much larger, and the browser has a lot more work to do to render the page? Is it guaranteed that the JavaScript code will run only after the HTML is fully parsed and loaded by the browser? The short answer is no.

Therefore, you need some way of knowing that the DOM is ready for you to interact with it. Luckily, there is a built-in event that you can hook into. Once the HTML is fully parsed and loaded, the browser fires an event called DOMContentLoaded. The DOMContentLoaded event fires when the HTML is fully parsed and loaded, whether or not the stylesheets and images are done loading.

To make sure that your HTML has been loaded into the DOM before your JavaScript code tries to interact with the DOM, you can run your JavaScript code when the DOMContentLoaded event fires. This event is attached to the window object, which you can think of as the browser itself.

**** Do this
Add a DOMContentLoaded event handler
Add the following code to the JavaScript file, reload the page in the browser, and observe the console.

console.log("Before!");

window.addEventListener("DOMContentLoaded", (event) => {
  console.log("Loaded!");
});

console.log("After!");
You will see output similar to this:

Before!
After!
Loaded!
The code in the JavaScript file executes immediately as the file is parsed. However, the code inside the DOMContentLoaded event handler doesn't run until the HTML is fully parsed and loaded into the DOM.

**** Refactor the DOM manipulation code
It is common practice to move code that manipulates the DOM into a single DOMContentLoaded event-handler function. You can name that function anything that you want. For example, you might name it init, ready, or main, as in the example below. Notice how main is declared, then passed to window.addEventListener() as the event handler:

// Declare handler and support functions here

// Function for sorting by name
const sortByName = ...

// Function for sorting by rating
const sortByRating = ...

// Function for handling the `nameSorter` click
const nameSorterClickHandler = ...

// Function to handle the `ratingSorter` click
const ratingSorterClickHandler = ...


// The code that runs once the DOM is loaded
const main = () => {
  // Select the `nameSorter` link
  const nameSorter = document.querySelector("#name-sorter");

  // Add an event listener
  nameSorter.addEventListener("click", nameSorterClickHandler);

  // Select the `ratingSorter` link
  const ratingSorter = document.querySelector("#rating-sorter");

  // Add an event listener
  ratingSorter.addEventListener("click", ratingSorterClickHandler);
}

// Add event listener for `DOMContentLoaded`
window.addEventListener("DOMContentLoaded", main);

*** 20.6

Websites often capture data entered by users. The user enters data on the form and then submits it. At this point, some validation is typically performed. So, you need to write some code to handle the event of the form being submitted.

The submit event fires when the user submits a form. This event fires on the <form> element itself, not on any button on the form.

As you did with other events, you can simply provide a handler function for the submit event.

Starter code
You will use the same code repository that you used in the previous lessons. The starter code for this lesson is in the branch Form_Starter.

If you need to clone the repository, run the following command in the terminal.

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
Once the repository is cloned to your local machine (or if you had it already), navigate to the project folder and check out the branch.

git checkout Form_Starter
Examine the index.html file. There is a <form> for adding a new park, with inputs for the various park values.

Handling the submit event
To handle the form submission, you need an event handler function. You then create the event listener on the form. As you did in the previous lesson, you will perform this when the DOM is fully loaded.

Do this
Create a submit handler
In the index.js file, create a function named submitHandler(). This function will be used for handling the form submission.

const submitHandler = (event) => {
  console.log("The form was submitted");
};
Then add a main() function that creates the event listener for the form submission.

const main = () => {
  // Get the form element
  const form = document.querySelector("#park-form");

  // Attach the submit handler
  form.addEventListener("submit", submitHandler);
};
And finally, add an event listener for DOMContentLoaded that invokes the main() function.

window.addEventListener("DOMContentLoaded", main);
You will notice that when you try to submit the form, the page is reloaded immediately. That is the default behavior of forms in a browser. You can stop this default behavior using the preventDefault() method of the event. Modify the submitHandler() function with this statement:

const submitHandler = (event) => {
  event.preventDefault();
  console.log("The form was submitted");
};
You will notice that upon submitting the form, the page no longer refreshes.

The FormData object
Now that you have a handler that is invoked on a form submit, you need to get the data that the user entered on the form. There are a number of ways that you could do this.

You could directly select one of the <input> elements and use the value property to get data. To do this, you would add the following to the submitHandler() function:

// Get the name input
const parkName = document.querySelector("#name-input").value;

console.log(parkName);
Now, when you enter a name and submit the form, you'll see that value.

However, remember that there's more than one way to get the data. In fact, there is a built-in object that can automatically read the data from the form and present it in an easy-to-use interface. The FormData object can be populated with a form's data as a set of key-value pairs. To use the FormData object, simply instantiate one with the <form> element, as shown below.

const submitHandler = (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
};
The FormData object has several methods for working with the form. You can use the get() method to get a specific value. The keys in the FormData correspond to the names of the form's <input> elements.

For example, to get the park name value, you could use the following code:

const name = formData.get("name");
console.log(name);
Required validation
Before using the data entered by the user, you can do some validation on it. For now, you'll go through some basic required validation, just so that you can see that it is possible. You will notice that on the HTML form, there are some error messages that are currently hidden by the CSS.

You can validate that the user entered some text for each form input. And if they did not, you can display the corresponding error message. Since you will be using the same code to check each input encapsulating that logic in a function would make that easier.

Do this
Add validate function for required fields
Add the following function to the JavaScript file. It accepts a single string value and returns true if the value isn't null and the string contains at least one non-space character.

function validateExists(value) {
  return value && value.trim();
}
The main validation function
Placing all the code to perform the validation in its own function would be useful and make the code more readable. This function will take each input field, perform required validation on it, and generate a collection of error messages which may then be displayed for the user.

Here's an example of such a function. It performs the required validation on each of the fields on the form.

function validateForm(formData) {
  const errors = {};

  // Check if name was entered
  if (!validateExists(formData.get("name"))) {
    errors.name = "Please enter a name";
  }

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  }

  // Check if description was entered
  if (!validateExists(formData.get("description"))) {
    errors.description = "Please enter short description";
  }

  // Check if established date was entered
  if (!validateExists(formData.get("established"))) {
    errors.established = "Please enter date";
  }

  // Check if area was entered
  if (!validateExists(formData.get("area"))) {
    errors.area = "Please enter the area of the park";
  }

  // Check if location date was entered
  if (!validateExists(formData.get("location"))) {
    errors.location = "Please enter the location of the park";
  }

  return errors;
}
This function accepts a FormData object containing the data from the form and checks each one to ensure that some value was entered. Now, this function must be called from the submitHandler() function.

Do this
Validate the form
Add the validateForm() function to the JavaScript file then modify the submitHandler() function as follows.

const submitHandler = (event) => {
  event.preventDefault();

  const form = event.target;
  const formData = new FormData(form);

  const errors = validateForm(formData);

  // Clear all previous errors
  const errorElements = document.querySelectorAll(".error");
  for (let element of errorElements) {
    element.style.display = "none";
  }

  // Display any new errors
  Object.keys(errors).forEach((key) => {
    // Find the specific error element
    const errorElement = document.querySelector(`#${key}-form .error`);
    errorElement.innerHTML = errors[key];
    errorElement.style.display = "block";
  });
};
Of course, this is just a basic validation that is used for illustration. This could have been accomplished in a number of other ways.

For example, the ratings field is supposed to be a number in the range 1-5, inclusive. You can create validation functions to validate that a given value is actually a number and another that validates the number in a specific range.

function validateNumber(value) {
  return !isNaN(value);
}

function validateRange(value, min, max) {
  return value >= min && value <= max;
}
Then the validateForm() function may be modified to add these validations to the ratings.

  ...

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  } else {
    // Check if the rating is a number
    if (!validateNumber(formData.get("rating"))) {
      errors.rating = "Rating must be a number";
    } else {
      // Because it is a number, convert it
      const rating = Number.parseFloat(formData.get("rating"));
      // Check that the rating is between 1 and 5, inclusive
      if (!validateRange(rating, 1, 5)) {
        errors.rating = "Rating must be between 1 and 5 inclusive";
      }
    }
  }

  ...
Similarly, other validation for any constraints on the data may be implemented in this function.

Add a park
Finally, if all the validation passes, you could update the DOM with the new park information. This would involve creating a new element for the form, making sure that it is formatted the same way as all the other parks on the page, and appending it to the parent element of all the parks.

By observing the HTML, you can see that a park is constructed like this:

<section class="park-display">
  <h2>The park name here</h2>
  <div class="location-display">the park location here</div>
  <div class="description-display">The park description here</div>
  <button class="rate-button" title="Add to Favourites">&#9734;</button>
  <div class="stats">
    <div class="established-display stat">
      <h3>Established</h3>
      <div class="value">The date of establishment here</div>
    </div>
    <div class="area-display stat">
      <h3>Area</h3>
      <div class="value">The area of the park here</div>
    </div>
    <div class="rating-display stat">
      <h3>Rating</h3>
      <div class="value">The rating of the park here</div>
    </div>
  </div>
</section>
Most of this is just template data—that is, it's mostly parts that don't change, interspersed with some data to be filled in.

You can create a new <section> element and set the rest of the HTML as the innerHTML property of the new element. You can use template literals to construct the correct HTML.

Do this
Add a park to the DOM
Add the following code to the end of the submitHandler() function.

// If there are no errors
if (!Object.keys(errors).length) {
  // Create a new element
  const parkSection = document.createElement("section");

  // Add the park class
  parkSection.classList.add("park-display");

  // Construct the HTML for this element
  const content = `
    <h2>${formData.get("name")}</h2>
    <div class="location-display">${formData.get("location")}</div>
    <div class="description-display">${formData.get("description")}</div>
    <button class="rate-button" title="Add to Favourites">&#9734;</button>
    <div class="stats">
      <div class="established-display stat">
        <h3>Established</h3>
        <div class="value">${moment(formData.get("established")).format(
          "MMMM D, YYYY"
        )}</div>
      </div>
      <div class="area-display stat">
        <h3>Area</h3>
        <div class="value">${formData.get("area")}</div>
      </div>
      <div class="rating-display stat">
        <h3>Rating</h3>
        <div class="value">${formData.get("rating")}</div>
      </div>
    </div>
    `;

  // Set the innerHTML
  parkSection.innerHTML = content;

  // Append to the main element
  document.querySelector("main").appendChild(parkSection);
}
The Moment library, which is included in the index.html file, can help you format dates before displaying them in the DOM.

In the content HTML above, calling moment(formData.get("established")).format("MMMM D, YYYY") will format any valid date entered into the established field using the MMMM D, YYYY format (which looks like January 1, 1999).

For example, if you enter a valid date such as 12-06-1987 or 12/06/1987 into the established field and submit the form, the date will show up as December 6, 1987 in the DOM. Using the moment library to format dates in your website can therefore help you display dates in a consistent manner in the DOM, regardless of the user input (as long as it's a valid date).

Check out the Moment.js docs for other arguments that you can pass to the moment().format() method to control how dates are displayed in the DOM. Also check out how you can use the Moment library to verify a date's validity.

The full solution code for this lesson can be found in the Form_Solution branch on the starter repository.

*** 20.7

Key Terms
Event delegation
The process of handling events at a higher point in the DOM than where the event originated
Starter code
For this lesson, you will be using the same repository as in the previous lessons in this module.

If you haven't already done so, clone the repository to your local machine as follows:

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
The starter code is in the branch Render_Starter. Check out that branch using the command below, and load the index.html file in the browser.

git checkout Render_Starter
Data and the DOM
In the code that you have written so far, the data associated with the parks has all been contained in the HTML file. As a result, the structure of the HTML has become tightly coupled to the processing of the data.

For example, look at the way that the parks are sorted by rating. Here is the sortByRating() function used to perform the sort.

const sortByRating = (parkA, parkB) => {
  const parkARating = parseFloat(
    parkA.querySelector(".rating-display > .value").innerText
  );
  const parkBRating = parseFloat(
    parkB.querySelector(".rating-display > .value").innerText
  );
  return parkBRating - parkARating;
};
In particular, pay attention to the way that you got the rating value from the DOM. You selected an element with the class rating and looked for a direct descendant with the class value. This can be problematic for a number of reasons.

If the HTML structure is updated for any reason—such as to improve the layout or to add further data to the park—the JavaScript sorting code will break.

And if the style is updated and the class names are changed, that will also break the JavaScript code. For that reason, you can say that the HTML structure is tightly coupled to the JavaScript code. This coupling can make it very difficult to maintain code in the long run.

So how can you make the HTML and JavaScript files less dependent on each other? One way is to identify the data that you are concerned with and store that data separately. You can then generate the DOM based on the data.

The data
In the starter code, there is a file named data.js. This file contains a single array declaration, and the array contains several objects representing parks.

const parks = [
  {
    name: "Biscayne National Park",
    location: "Florida, United States",
    description:
      "Biscayne National Park encompasses coral reefs, islands and shoreline mangrove forest in the northern Florida Keys. Its reefs and islands are accessible only by boat. Dolphins, turtles and pelicans live in Biscayne Bay Lagoon. The underwater Maritime Heritage Trail links dive sites, most of them shipwrecks. On Boca Chita Key, Boca Chita Lighthouse has coastal views. A museum at Convoy Point explains local ecosystems.",
    established: "June 28, 1980",
    area: "172,971 acres (699.99 km^2)",
    rating: 4.7,
  },
  // ...
];
You can now write a function whose job it is to construct a DOM element for each park and insert it into the DOM at an appropriate place. If you update this data at any time, say in response to the user adding a new park, you can simply run the function again to update the DOM.

Similarly, if you want to sort the data, you can perform the sort on this array of data, and then execute the same function again to update the DOM with the sorted data.

When you generate the DOM in response to data in this way, you are rendering the user interface. For that reason, it makes sense to name this function render().

The render() function
To render the parks on the page, you will have to do the following:

Remove any existing content from the parent element.

Create the HTML for each park in the array.

Set the innerHTML of the parent element.

Do this
Create a renderOnePark() function
You can create a function named renderOnePark() that accepts a park and returns the HTML code for that park. To do so, add the following code to the index.js file.

const renderOnePark = (park) => {
  // Get the individual properties of the park
  const { name, location, description, established, area, rating } = park;

  const content = `
      <section class="park-display">
        <h2>${name}</h2>
        <div class="location-display">${location}</div>
        <div class="description-display">${description}</div>
        <button class="rate-button" title="Add to Favourites">&#9734;</button>
        <div class="stats">
          <div class="established-display stat">
            <h3>Established</h3>
            <div class="value">${established}</div>
          </div>
          <div class="area-display stat">
            <h3>Area</h3>
            <div class="value">${area}</div>
          </div>
          <div class="rating-display stat">
            <h3>Rating</h3>
            <div class="value">${rating}</div>
          </div>
        </div>
      </section>
  `;
  return content;
};
Create a render() function
The render() function will make use of the renderOnePark() function. Add the following code to the index.js file.

const render = () => {
  // Get the parent element
  const main = document.querySelector("main");

  // Empty the parent element
  main.innerHTML = "";

  // Get the parks HTML
  const content = parks.map(renderOnePark).join("");

  // Set the `innerHTML` of parent element
  main.innerHTML = content;
};
Call render() in the main() function
To call the render() function, add the following statement to the main() function.

const main = () => {
  // All the existing code

  render();
};
Refactor the sort
The two sort functions are still getting the data from the DOM. You can refactor these to directly sort the parks array itself and simply call render() when it is time to update the DOM.

The sortByName() function may be refactored to accept two park objects rather than two DOM elements.

const sortByName = (parkA, parkB) => {
  const parkAName = parkA.name;
  const parkBName = parkB.name;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};
Notice that you aren't querying the DOM anymore. You have direct access to the data. Correspondingly, the nameSorterClickHandler() function is now simpler. You can remove all the DOM access and manipulation. You just need to do two things:

Sort the array.

Render the page.

You can implement this as follows:

const nameSorterClickHandler = (event) => {
  event.preventDefault();

  parks.sort(sortByName);

  render();
};
Do this
Refactor the sort-by-rating functions
Using the above as a guide, refactor the sort-by-rating functions to use the render() function.

Adding new park
In the previous lesson, you added a new park by constructing the DOM element for the new park and appending it to the DOM. Now that you have separated the data from the DOM, you should instead insert a new park object into the parks array, and then render the page again.

You can modify the submitHandler() function to do this. Change the function as follows:

const submitHandler = (event) => {
  event.preventDefault();

  const form = document.querySelector("#park-form");
  const formData = new FormData(form);

  // Keep track of if any errors are found
  let hasErrors = false;

  // Validation code skipped for brevity
  // ...

  // If there are no errors
  if (!hasErrors) {
    // Create an empty object
    const park = {
      name: formData.get("name"),
      location: formData.get("location"),
      description: formData.get("description"),
      established: formData.get("established"),
      area: formData.get("area"),
      rating: formData.get("rating"),
    };

    parks.push(park);

    render();
  }
};
The favorite buttons
You may have noticed that now that you have refactored the code, the favorite buttons no longer work. This is because you are losing the event listeners associated with the button. Remember that the main function runs as soon as the DOM is loaded for the first time.

In the main function, all the buttons on the page are selected, and an event listener is attached to each one. However, you consequently remove that content from the DOM any time that you call the render() function. When you remove an element from the DOM, all associated event listeners are also removed.

But what if you instead attached the event listener to an element that remains on the page all the time? For example, what if you attached it to the <main> element? Because that element is never removed, if you attach an event listener, then it stays for the lifetime of the page.

Consider the following diagram:

The way a click event propagates up the DOM
This diagram shows how a button is positioned on top of the section, which is positioned on top of the main, which in turn is positioned on top of the body. Even though the mouse pointer is over the button, it is also over each of these elements in turn.

When you click the button, the click event propagates up the DOM from the button, to the section, to the main, and to the body.

You can modify the main() function by removing the event-handling code for the buttons and replacing it with this:

// Select all the buttons for all the parks
const main = document.querySelector("main");

// Add event handler to the main
main.addEventListener("click", favoriteButtonClickHandler);
Then you need to modify the favoriteButtonClickHandler() function. Because you attached the event listener to the <main> element, it triggers whenever a click happens anywhere on the <main>. You want to restrict the event handling to only the buttons.

You can do a conditional check to ensure that the element that triggered the event was the button.

Modify the favoriteButtonClickHandler() function as follows:

const favoriteButtonClickHandler = (event) => {
  if (event.target && event.target.nodeName == "BUTTON") {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  }
};
Here, you are checking that the target of the event—the actual element that was clicked—is a button. If so, you perform the action.

This way of handling events is called event delegation. Event delegation is the process of handling events at a higher point in the DOM than where the event originated. It's said that the event propagates up the DOM.

If you want, you can continue working on this application to improve it even further. But now, you're familiar with the essentials of interacting with the DOM, handling events, and separating the data processing from the DOM.

* Backend Development - Modules 30-40
** Node and Express - Module 30
** Robust Server Structure - Module 31
** Project - Module 32
** Postgres- Module 33
** Creating Relations - Module 34
** Node, Express, and Postgres - Module 35
** Backend Deployment - Module 36
** Connecting it all - Module 37
** Mock Interview: Backend - Module 38
** Node and Express - Module 39
** Node and Express - Module 40
* Data Structures and Algorithms - Modules 41-44
** Module 41 - Introduction to data structures and algorithms
*** 41.1 - Overview: Intro to data structures and algorithms
*** 41.2 - What are algorithms?

What are algorithms?
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to describe an algorithm.

Overview
Whether you are aware of it or not, you have been using algorithms your whole life. For example, in elementary school, you learned a series of steps for multiplying two numbers. You learned that if you follow those steps precisely, you will always get the correct result. That series of steps is an algorithm, and that's what you'll focus on in this lesson.

Key Terms
Time complexity of an algorithm
The number of instructions (or steps) needed to execute the algorithm
Space complexity of an algorithm
The amount of memory used by the algorithm
The video below provides a brief introduction to algorithms. Start by watching the video, and then read through the rest of the lesson. This will give you a thorough understanding of this topic.


An algorithm is defined as a well-defined sequence of steps for solving a computational problem. Even though this definition is simple, it covers a few concepts that may be expanded.

Key Term
Algorithm: A well-defined sequence of steps for solving a computational problem

First, break down the idea of a computational problem. A computational problem is a problem that a computer might be able to solve. For example, the problem of sorting a sequence of numbers in ascending order is a computational problem.

Problems must be well specified. That is, the statement of the problem must specify the inputs, outputs, and the relationship between the inputs and outputs. For example, the search problem may be defined as follows: given a sequence of n numbers and a number x as input, output the index of the first occurrence of the number x in the sequence. Output -1 if the number x isn't in the sequence.

There may be more than one way to solve that problem. An algorithm, then, is any sequence of steps that, if followed precisely, will solve the problem.

Next, note that the definition above specifies that the sequence of steps must be well defined. In other words, the steps must be unambiguous and complete. Here, unambiguous means that the instruction for a particular step can only mean one thing. And complete means that no steps are left out.

The linear search algorithm
Here is an example of an algorithm that solves the search problem defined above.

function linearSearch(sequence, x) {
  for (let i = 0; i < sequence.length; i++) {
    if (sequence[i] === x) {
      return i;
    }
  }

  return -1;
}
This algorithm is complete and unambiguous. The statement let i=0 can only mean one thing: declare a variable named i and initialize it to the value 0. Similarly, each statement has a precise meaning.

You'll study this algorithm in more detail in a later lesson.

A note on notation
In the study of algorithms, the programming language does not matter. An algorithm may be implemented in any programming language. What is relevant is what steps are needed to complete the task.

For this reason, you can write an algorithm using pseudocode. As you learned earlier in this program, pseudocode is a form of structured English used for describing algorithms. It resembles programming code but isn't concerned with details such as semicolons. The exact syntax of pseudocode is not important as long as it is unambiguous and clear.

The linear search algorithm above is written in JavaScript. In pseudocode, that algorithm may look like this:

 function linearSearch
   input: sequence - an unsorted array of numbers
   input: x - a number

   Initialize a variable i to 0
   Iterate while i is less than the length of sequence
     if the ith element of sequence is equal to x, then return i

   if no element of sequence matches x, then return -1
Alternatively, an algorithm may be depicted in a flow diagram, like this:

Algorithm represented as a flow diagram.
In this module, JavaScript will be used to specify the algorithms. This is because of the following reasons:

You are already familiar with the syntax.

Programming code is by definition unambiguous.

Having the ability to directly run the code may help you to understand the algorithm.

Properties of algorithms
The following video provides an introduction to the properties of algorithms.


Imagine that you are the judge at a baking contest. You would make your decisions by comparing the properties or characteristics of various cakes. For example, you would look at the fluffiness, aroma, moistness, taste, and appearance of each cake. It is by comparing these properties that you know which cake is the best.

Similarly, algorithm design and analysis involves a disciplined approach to studying the properties of algorithms. It is by comparing these properties that you can know which algorithm may be most suitable for use in a particular scenario.

The properties of an algorithm are as follows:

Correctness: The output produced by the algorithm is correct for all valid input.

Efficiency: The algorithm minimizes the use of the available computing resources.

Determinism: The result of each step of the algorithm is determined only by the inputs and the results of the preceding steps.

Finiteness: The algorithm must stop. It may take many steps, but eventually, it must terminate.

Generality: The algorithm applies to a set of inputs.

Proving that an algorithm is correct for all valid inputs requires some rigorous mathematics that is beyond the scope of this module. Rather, you will take a more informal approach to determining the correctness of an algorithm.

In this module, you are going to focus your attention on the efficiency of algorithms.

Efficiency
Computing resources are limited. A good algorithm makes efficient use of these resources. Providing that an algorithm satisfies all the other properties, it is efficiency that differentiates various algorithms.

The resources that are most relevant are the memory of the computer and the CPU. An algorithm may be correct, but if it requires more RAM than is reasonably available, then it is useless. Similarly, if the algorithm requires more processing time than is available, it is useless.

The number of instructions (or steps) needed to execute an algorithm is called the time complexity of the algorithm. The amount of memory used by the algorithm is called the space complexity.

Algorithms are usually discussed in terms of their time and space complexity. Normally, the concern is with the time complexity rather than space complexity. This is because it is easier and cheaper to obtain space, and there are techniques for achieving space efficiency by spending more time.

*** 41.3 - Why study algorithms?
Why study algorithms?
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to describe why studying algorithms is useful.

Overview
Computers are getting faster every year, and memory is getting cheaper all the time. So is it still important to study algorithms? The answer is yes. In this lesson, you will examine some of the reasons why the study of algorithms is essential.

Some real-world algorithms
The video below provides a brief introduction to why algorithms are important. Start by watching the video, and then read through the rest of the lesson. This will give you a thorough understanding of this topic.


Algorithms are everywhere. They impact your life in meaningful ways, even if you do not directly use them yourself. Take a look at a few examples below.

Google's PageRank algorithm
PageRank is one of the algorithms that Google uses to order search results. If you have ever done a search on Google, you have used their PageRank algorithm. This algorithm attempts to measure the importance of a web page and its relevance to your search query.

Internet routing
The internet is made up of millions of nodes (computers and routers and other devices) that are all connected together in a vast array of connections. Moving data from one computer to another is an extremely complicated task. Yet, you do it every day with every web page that you visit, every email that you send, and every video call that you make.

To make this all work, there are a series of different routing algorithms that attempt to find the fastest route from your computer to any other computer that you are connected to on the internet.

The problem of routing is an area of active research. As internet access continues to grow cheaper, the number of nodes grows, and it becomes more and more critical to identify more efficient algorithms to enable routing.

Cryptography
The modern world would not be possible without encryption. Encryption is the process of obscuring a message so that third parties may not access the content of the message. Encryption is used to secure communication on the internet. If you have ever used online banking, done a credit card transaction, or even used an online email service like Gmail, then you have used an encryption algorithm.

Ride-sharing
The chances are good that you have used a ride-sharing service while hardly giving a thought to the technology behind such a service. The ride-sharing service wishes to optimize the use of its drivers and minimize idle time as well as wait times for its customers. Tracking numerous drivers on the move and numerous customers waiting for rides is a complex task that requires sophisticated algorithms.

GPS
Today, it is trivial to pinpoint your exact position on the surface of the planet with GPS. Your phone seems to know—with relative ease—that you visited your local Starbucks. But the technology behind this is far from trivial; it involves several complex systems all working together to find your position as you buy your coffee. GPS works by synchronizing atomic clocks on a constellation of satellites orbiting the Earth with a ground-based control system and your phone. The algorithms involved are as complex as anything that humankind has ever created.

Usefulness of algorithms
Just from the examples above, it should be clear that there are many useful algorithms already at work in the world today. But the story is far from complete. The hardware that makes up your computer implements many algorithms that enable the tasks that you do on your computer. The operating system is made up of a series of advanced algorithms for file management, CPU usage, networking, security, and a host of other services within the computer. Your browser uses many algorithms just to display a web page. And games that you play are possible because of sophisticated algorithms.

Generally, algorithms are a technology that has been used for commercial advantage and military benefit. For these reasons alone, the study of algorithms is a useful pursuit.

But computers are so fast!
The video below provides an example to illustrate why algorithms are important.


Computers are fast and getting faster. Memory is cheap and getting cheaper. So why study algorithms at all? If you wanted to solve some problem at a faster rate, you could just wait a few years, and computers would solve the problem faster—right? Well, the story isn't quite that simple. Below, explore this through a concrete example.

Suppose that you had an array of 10 million elements, and you needed to sort those elements. There are two programmers, and they both say that they can write a program to sort those numbers for you. The first programmer, Bob, claims that he has a computer that can perform 10 billion instructions per second. The second programmer, Alice, says that she has a computer that can perform only 10 million instructions per second. So Bob's computer is 1,000 times faster than Alice's. It would seem that if you use Bob's computer, you will get your sorted array 1,000 times faster than using Alice's computer.

Sketch of Bob and Alice with their computers.
Intuitively, you may understand that as the size of the array increases, the length of time needed to sort the array also increases. So sorting 10 million elements will take longer than sorting 1 million elements. The question is, how much longer?

Bob's sorting algorithm uses n² instructions to sort n elements. For example, to sort 5 elements, Bob's algorithm will use 5², or 25 instructions (5²=5*5=25). And to sort 6 elements, it will use 6², or 36 instructions (6²=6*6=36). This is known as the running time of the algorithm. You will be taking a deep look at running time in the next few lessons.

On the other hand, Alice's sorting algorithm takes n log n (that is, n times log to base 2 of n) instructions to sort n elements. Don't worry if the math is starting to look complicated; it won't get any more complex than this. In this case, sorting 5 elements would take 12 instructions (5*log₂5=5*2.322=11.6), and sorting 6 elements would take 16 instructions (6*log₂6=6*2.585=15.51). (Note that the numbers are rounded for simplicity.)

How long would it take to sort 10 million elements using Bob's algorithm on Bob's computer? And how long would it take for Alice's computer using her algorithm?

Calculation of sorting times for Bob and Alice with their respective computers and algorithms.
Incredibly, Alice can sort 10 million elements in an array in just 24 seconds—while Bob would take almost 3 hours. That is more than 400 times as fast!

This gap grows significantly as the size of the array grows. You can use your calculator to see how long it takes to sort 20 million elements or 100 million elements. You will see that to sort 100 million elements, Alice's algorithm completes in 265 seconds, while Bob's algorithm completes in one million seconds—almost 12 days! That is almost 4,000 times as fast!

Of course, this is just a made-up example, but it serves to illustrate that a well-designed algorithm can produce benefits far beyond that of a faster computer.

*** 41.4 - An efficiency example
An efficiency example
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to describe the efficiency of an algorithm in terms of its running time as a function of the size of input.

Overview
At this point, you can define an algorithm, you know some examples of famous algorithms, and you understand why the study of algorithms continues to be an important pursuit. In this lesson, you'll begin to take a closer look at what it means for an algorithm to be efficient. Efficiency, as you have already seen, is the main measured characteristic of an algorithm.

In a previous lesson, it was stated that an algorithm is a solution to a well-defined computational problem. It was also stated that there might be many algorithms that solve the same problem. So in this lesson, you'll define a problem and consider some possible solutions.

The problem
The video below provides a brief introduction to solving an algorithm using a naive approach. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of this topic.


Given an integer n, find the sum of all integers from 1 to n inclusively.

For example, if n=4, the solution involves the sum 1+2+3+4=10.

The first solution
To solve this problem, you could use a loop to count every integer from 1 to n and sum as you go. At the end of the loop, you will have the required sum.

Here is one way that the solution may be written:

function sumIntegers(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum = sum + i;
  }
  return sum;
}
The question is now the following: how long does it take for this program to run? To find the answer, you can check the system time before you run the function and then check the system time again after the function is complete. Then you can find the difference to see how long it takes. There are some problems with this approach, as you will see, but it can give you a feel for the running time.

Measuring the performance
The Node environment has a built-in function process.hrtime.bigint(), which gives you the current system time in nanosecond precision. Here's an example:

const N = 100; // The input to the function
const start = process.hrtime.bigint(); // Note the start time

const answer = sumIntegers(N); // Call the function

const end = process.hrtime.bigint(); // Note the end time

console.log(`Summing ${N} numbers took ${end - start} nanoseconds`);
Do this
Measure the running time of the function
Create a new JavaScript file and copy the code above into it. Execute the file and observe the output. Run the same code several times. Notice that every time that you run the code, the result is slightly different. For example, after running the code three times, this was the output:

Summing 100 numbers took 26507 nanoseconds
Summing 100 numbers took 22287 nanoseconds
Summing 100 numbers took 22816 nanoseconds
Of course, the output on your machine will be different than the above output, because your machine may be faster or slower than the machine used to run the code for this example.

The important takeaway is that the actual time that it takes to run the program varies. This is because of several factors in the environment, such as what other processes may be running on the computer, how fast the CPU actually is, and how much memory may be available.

Getting an average time
You can try running the code several times and finding an average. As shown below, update the code to run the function 10 times and find the average time.

const NUMBER_OF_REPETITIONS = 10; // Number of times to repeat the test
const N = 100;

let sumOfRunningTime = 0n;

for (let k = 1; k <= NUMBER_OF_REPETITIONS; k++) {
  const start = process.hrtime.bigint();

  const answer = sumIntegers(N);

  const end = process.hrtime.bigint();

  sumOfRunningTime += end - start;
}

const averageTime = sumOfRunningTime / BigInt(NUMBER_OF_REPETITIONS);

console.log(
  `Summing ${N} numbers took an average of  ${averageTime} nanoseconds`
);
This way, you can feel more confident about the value.

As the input grows
The test above gives you a time for summing precisely 100 numbers. What if you had to sum more than that? How long would it take? It may be worthwhile to try the above program with some different numbers just to see what happens.

Do this
Repeat the experiment with larger numbers
In the above code, change the value for N and run the code again. Here's an example:

const N = 1000;
Do this several times, with N set to 100, 500, 1000, 2000, 5000, and 10000. Note the time that each takes.

What can you say about the way that the length of time that it takes to run the function changes as the size of the input changes?

Linear growth
You may have noticed that as the size of the input increases, the running time of the function increases correspondingly. Given this observation, you could extrapolate and guess the running time for even larger input sizes.

This is an important concept. Although it is useful to know the running time for a specific input size, it is actually more useful to have a formula that tells you how that running time changes as the input size changes.

If you plot the numbers on a graph, you may get something like this:

Growth rate of sum integer function
The blue line shows the linear function, and the red line shows how the running time of the sumInteger() function changes as n changes. Notice that it is roughly the same rate of growth.

Given that, you can say that the function that was written has a linear growth rate. That is, the length of the running time changes proportionally to the size of the input.

This finding should be easy to see. In the function, there is a loop that goes from 1 to n. As n increases, the function has correspondingly more work to do.

A second solution
The video below describes the process of solving an algorithm using a more optimal approach.


Is it possible to develop an algorithm that performs better than this first solution? And what exactly is meant by better here? In this case, better would mean a growth rate that is slower than the linear function. If there were another solution that had a running time that grew slower than the linear function as n increases, then you could say that you have a more efficient algorithm. That is, you can calculate larger values of n in less time.

Take a few moments to think about how you might approach this problem.

One way that it might be done was devised by the famous mathematician Carl Friedrich Gauss when he was seven years old. Don't worry if you didn't think of this solution; Gauss is considered one of the greatest mathematicians of the age, and he basically invented algebra as it is known today.

Gauss came up with the formula n(n+1)/2. It is easy to verify that this is correct. For example, when n=100, the expression is evaluated as follows:

100 * (100 + 1) / 2
=> 100 * 101 / 2
=> 10100 / 2
=> 5050
This means that you can write a function to implement this formula like this:

function sumIntegers2(n) {
  return (n * (n + 1)) / 2;
}
Do this
Measure this function
Using the same technique as before, run this new function several times with different input sizes. Note the running times as the input size increases.

What do you notice about the running time for this function as compared to the previous program?

Running time of the second solution
You should have noticed that the running time remains roughly the same, no matter how large n is. That is, the running time remains constant as n increases. If you plot this on a graph, it may look like this:

Graph of running time in nanoseconds vs size of n. The constant function always has a running time of 250 ns, while the growth function's running time varies slightly but stays near 250 ns.
This time, the blue line shows the constant function. That is, the value does not change as the size of n changes. The red line is the growth rate of the function. Notice that even though there are slight variations, the function closely mirrors the constant function line.

Again, it is easy to explain why this is so for this second algorithm. No matter the value of n, you simply perform one multiplication operation, one addition operation, and one division operation to calculate the result. The same amount of work is done regardless of the size of n.

When the running time of a function doesn't change with changes to the input size, you can say that it has a constant growth rate.

Comparing the growth rates
Now that it is known that the first algorithm has a linear growth rate and the second has a constant growth rate, which would you say is the more efficient algorithm? Plotting a constant function and a linear function on the same graph depicts the difference:

Graph of running time in nanoseconds vs size of n. The constant function always has a running time of 250 ns, while the linear function's running time increases as n increases.
In this graph, you can see that the linear function increases and the distance between the two lines grows as n increases. Therefore, a constant growth rate is more efficient than a linear growth rate.

Problems with this approach
The exercise that you did in this lesson is useful to illustrate that the same problem can be solved in different ways, and some ways may be more efficient than other ways.

It also illustrated what is meant by running time. However, there are some problems with this approach.

First, you need a working program in order to run such an experiment. What if you had an idea for an algorithm and wanted to analyze the algorithm before you implemented it?

Second, the program depends on several factors, such as the programming language and even the skill of the programmer. These functions were written in JavaScript and executed in a Node environment. What if they were written in C or Python or Java? Would they run faster or slower? What if, in the first program, a for each loop was used instead of the for loop? Would that change the running time? Also, more experienced programmers may know techniques for writing more efficient code even if the algorithm itself has a poor growth rate. How can you account for that?

Third, the computer used for this experiment had its own configuration. The CPU, operating system, version of Node, amount of memory, and many other factors affect how fast programs run on a computer.

Fourth, this was a fairly simple algorithm. It took a few nanoseconds to run. It was easy to run it many times to determine the growth rate. What if the algorithm was more complex and took an hour to run? It wouldn't be practical to run the function ten times over in that case.

And fifth, how would you compare the running time of this algorithm to the running time of other algorithms? Suppose that it was published that this algorithm executed in 250 nanoseconds. If another programmer published that their algorithm ran in 200 nanoseconds, is it because their algorithm is better, or is it because of one of the factors mentioned above?

Is there a better way?
There is a better way. What is needed is some way to analyze the running time of the algorithm independently of the programming language that it is written in or the computer hardware that it runs on.

In the next lesson, you will explore exactly such a technique.
*** 41.5 - Asymptotic analysis
Asymptotic analysis
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to use big O notation to represent the order of growth of the running time of an algorithm.

Overview
Analyzing an algorithm means determining the resources that the algorithm will consume during execution. Sometimes, the resource in question is the memory of the computer or the network bandwidth. However, the most important resource to measure is the computational time. That is, how long does it take to execute the algorithm on a given set of inputs?

Key Terms
Rate of growth
Also called the order of growth, the rate at which the running time of an algorithm increases as a function of the input size
Big O notation
A notation commonly used to describe the order of growth of an algorithm
A model of computation
Today, computers come in all shapes and sizes, from small wearable devices, to laptop and desktop machines, to massive servers and supercomputers running many CPUs in parallel. Even with one class of devices, there are so many differences in CPU technology that it would be impossible to list them all. Some CPUs have a single core, while many CPUs today come with multiple cores, allowing software to take advantage of asynchronous execution models. Many computers include additional processing units like GPUs (graphics processing units) where some of the work can be offloaded, freeing up the main CPU. And this doesn't even touch on the different memory models, cache pipelines, bus speeds, and other variations and techniques used to provide all the computing power that you may need.

With all this variation, it is very difficult to isolate the efficiency of the algorithm itself.

Rather than depend on the computer's implementation details, it is common to adopt a simplified model of the computer for the purpose of analysis. What is really being measured is the amount of work that is required to execute the algorithm. The fact that a faster computer will do the work faster does not change the fact that the same amount of work is being done.

The computational model that you'll adopt here has the following properties:

It has a single processor and runs the algorithm in a sequential manner. That is, the instructions for the algorithm are executed in the given order, one at a time.

It takes exactly one time unit to execute a standard instruction. A standard instruction is an operation such as addition, subtraction, multiplication, division, comparisons, assignments, and conditional control. No complex multistep instructions (such as sorting) can be done in a single time unit.

It takes the same amount of space to store each value (such as an integer).

It has an infinitely large memory. This assumption frees you from worrying about the space requirements.

Tip
A time unit is a generic amount of time. Because of variations in the speed of processors, some can execute an instruction in a few nanoseconds, while others may take a few milliseconds to execute the same instruction. Here, focus on how many of the time units are used, rather than the absolute time.

Counting steps
Recall the problem that was solved in the previous lesson:

Given an integer n, find the sum of all integers from 1 to n inclusively. For example, if n=4, the solution involves the sum 1+2+3+4=10.

And recall the first solution that was presented:

function sumIntegers(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum = sum + i;
  }
  return sum;
}
How many steps would it take to execute this algorithm on the computer model described above? First, break up this program into its individual steps. A diagram might be helpful here:

Diagram of algorithm broken into steps.
In this flow chart, each statement to be executed is represented by a rectangle or diamond. A diamond shape represents a conditional statement.

Starting from the top, look at each statement in turn. Write down the number of times that statement will be executed when the algorithm runs.

For example, the first statement, sum=0, will only execute once. The value of n doesn't change this. The next statement, i=1 is the loop initialization step, and it is only executed once at the beginning of the loop.

The loop condition statement, i<=n, depends on the value of n. Consider a few small examples. Suppose that n is 1. This condition executes once when i is equal to 1 and one more time when i is equal to 2. When n is 1, this statement executes twice.

Suppose that n was 2. The loop condition executes once when i is equal to 1, once when i is equal to 2, and once when i is equal to 3. Therefore, when n is 2, this statement executes three times.

Generalizing that, you can say that this statement executed n+1 times. You should try a few more examples, say when n is equal to 4 and when n is equal to 5, to see if this conclusion holds up.

Diagram explaining what the statements do.
The next statement occurs in the body of the loop. Everything in the body of the loop depends on the number of times that the loop iterates, which in turn depends on n. Like the previous statement, you can use a few small examples to try to determine the pattern.

n
Number of executions
Explanation
1
Executes one time
When i is 1, i<=n is true. So the loop body executes, and i is then incremented to 2. That means that i<=n becomes false and the loop ends.
2
Executes two times
Similar to above, but when i is 2, i<=n is still true. So the loop body executes a second time. i is then incremented to 3 and i<=n becomes false.
You can do a few more of these to verify the pattern. Generally, it looks like the statement executes n times.

The next statement, the loop step, executes n times, by the same logic as the previous step. The final statement, return sum, executes just once.

Diagram showing number of times each statement executes.
To put it all together, sum the number of steps:

1 + 1 + n + 1 + n + n + 1 = 3n + 4
Therefore, you can say that the running time for this algorithm in terms of the input n is 3n+4.

Using this function, you can calculate the number of steps that this algorithm takes for any value of n. For example, if n is equal to 10, this algorithm will execute as follows:

3 * 10 + 4 = 34 steps
And if n is equal to 100, this algorithm will execute as follows:

3 * 100 + 4 = 304 steps
Order of growth
So far, some simplifying assumptions have been made to facilitate this analysis. For example, a simple computer model was assumed. Next, the actual time to execute an instruction was ignored. In reality, computers take slightly longer to execute multiplication than addition. Here, that difference is ignored.

The execution time derived above, 3n+4, contains more information than is needed, and further simplifications can be made.

It is the rate of growth that you are really interested in. The rate of growth, also called the order of growth, is the rate at which the running time of an algorithm increases as a function of the input size.

For this reason, it is only the highest-order term in the running time that matters. To illustrate this, consider the running time 3n+4. There are two terms in this expression: 3n and 4. As n grows, the 3n term dominates the value of the expression.

n
3n
4
3n+4
Contribution of 4 to the value
1
3
4
7
57.000%
10
30
4
34
11.760%
100
300
4
304
1.310%
1,000
3,000
4
3,004
0.013%
As you can see, as n increases to ever-larger values, the 4 in the expression has less effect on the final value. You could simply drop that from the expression, leaving only the 3n.

It is also possible to drop the leading term's constant coefficient, because constant factors are less significant than the growth rate. That just leaves n.

You can say that the algorithm has a growth rate of n. This is written as O(n), pronounced "big Oh of n."

Big O is a notation commonly used to describe the order of growth of an algorithm. Specifically, it describes the upper bound, or worst-case running time of the algorithm.

Big O
How can big O notation be interpreted? What exactly does O(n) mean?

O(f(n)) describes a set of functions that grow at most as fast as the function f(n). For example, O(n) refers to the function f(n)=n. You can plot that on a graph, as shown here:

f(n)=n plotted on a graph
The red line represents the function f(n)=n. It simply means that as n increases, the number of steps increases proportionally (at the same rate).

O(n) then means any function that grows slower than or at the same rate as the function f(n).

For example, in the following graph, the function g(n) grows as n increases. But it remains under the f(n) line.

The function g(n) growing as n increases
If g(n) were the running time of an algorithm, you could say that g(n) is O(n).

Notice also that O(f(n)) is true for sufficiently large values of n. It may be possible that for very small values, the running time is larger than the O(f(n)) function. As long as for large values of n, as n approaches infinity, it remains less than or equal to f(n), and it is still a valid definition. For this reason, you can call this an asymptotic analysis.

Because f(n)=n is a straight line, you can say that this is a linear function and O(n) is a linear growth rate.

Growth rate of the second solution
A second solution was provided for the sum of n numbers problem in the previous lesson. Review that solution below:

function sumIntegers2(n) {
  return (n * (n + 1)) / 2;
}
You can use a similar process as before to count the number of steps that it takes to complete this algorithm.

First, a flow chart of the function will help visualize the steps. Even though the entire function is written in a single expression, there are multiple operations happening. Remember that the model computer can execute only one operation at a time.

Flow chart of function and its steps.
For illustration purposes, only a temporary variable i was introduced to show the order of execution of the expression.

How many times does each of these statements execute? Does it depend on the value of n? It is clear that there are no loop structures in this program, so each statement executes exactly once—regardless of the value of n. That gives a running time of 4.

The order of growth of this solution is O(1), because 1 represents the constant function when all constants are factored out.

1 representing the constant function when all constants are factored out.
Once again, O(1) simply means that the actual running time of this algorithm grows at most as fast as the constant function.

This is called a constant growth rate.

The insert-into-a-sorted-array problem
The video below provides a brief introduction to solving an algorithm using an optimal approach.


Consider the following problem: You are given an array of n numbers. The first n-1 numbers in the array are sorted in ascending order, but the status of the last number is unknown. That is, the last number in the array may or may not be in the right position. Find the correct position for that last number and insert it into the array such that the array becomes fully sorted.

How might you solve such a problem?

Here is an instance of the problem:

Instance of problem.
In the first step, initialize a loop variable to n-2. This will keep track of the value that you are currently looking at in the array.

First step of solution.
Create a new variable named key to hold the value in the last position of the array.

Compare the current value to key. If the current value is greater than key, then copy the current value to position i+1.

Second and third steps of solution.
Repeat until the current value is not greater than key:

Fourth step of solution.
When you find a position that is less than key, copy key into the i+1 position of the array.

To take care of the situation where key is the smallest number in the array, if you get to the front of the array without inserting the key, simply copy the key into the first location of the array.

Those steps may be formalized into a function as follows:

function insertIntoSortedArray(sequence) {
  const key = sequence[sequence.length - 1];

  for (let i = sequence.length - 2; i >= 0; i--) {
    if (sequence[i] > key) {
      sequence[i + 1] = sequence[i];
    } else {
      sequence[i + 1] = key;
      return sequence;
    }
  }
  sequence[0] = key;
  return sequence;
}
Runtime of the insert-into-sorted-array solution

To count the number of steps that this algorithm takes, you'll follow a similar process as in the previous two examples. However, there is one significant difference.

The number of steps depends on both the size of the input array and the values in the array. For example, consider what happens if the input array is [3, 5, 7, 10, 12]. The loop will iterate only once before this algorithm ends. On the other hand, given the input [3, 5, 7, 10, 2], the loop will iterate at least n times.

So, how can you determine the running time of this algorithm?

There are three possible scenarios here. The first example above, where the loop iterates only once, is the best-case scenario. That is, the algorithm has little or no work to do. This case has a constant running time. Although this is a desirable situation, it isn't very interesting. It doesn't give you any information that is useful to the analysis.

The worst case is the scenario where the algorithm has to do the most amount of work. Like the second example above, if the key must be inserted at the beginning of the array, the only way to do that is to iterate the entire array. That gives you a running time of n.

The third possibility is the average case. If the algorithm is executed repeatedly with many different inputs, it will sometimes do a single iteration and sometimes do n iterations. It would be possible to say that on average, it will do n/2 iterations. Because constant coefficients are dropped in asymptotic analysis, this is the same as n.

Even though the average case can give you some meaningful data about the real-world complexity of the algorithm, it doesn't give you a growth rate that is different from the worst case. Think of it as a budgeting problem. To make an effective budget, you need to know the highest possible cost of everything that you need to purchase.

You can conclude that the growth rate of the running time of this algorithm is O(n).

Other running times
In the examples in this lesson, you saw two examples of growth rates: O(n) and O(1). It is possible to use any function in big O notation, but it is common practice to use a few well-defined functions. In the next lesson, some of these common functions will be explored in more detail.
*** 41.6 - Common functions
Common functions
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to define several well-known functions used in the analysis of algorithms.

Overview
You have already seen two functions, f(n)=1 and f(n)=n. The running time of an algorithm may be expressed with any valid mathematical function. However, it is common practice to use one of several well-known functions. The functions commonly used in the analysis of algorithms are presented in this lesson in order from "best" to "worst."

The constant function
The video below provides a brief introduction to constant functions.


The constant function is as follows:

f(n) = cf(n)=c
Here, c is some fixed constant. That is, for all values of n, the function f(n) remains equal to c. The most fundamental constant function is as follows:

f(n) = 1f(n)=1
This is typically the function used to denote an algorithm with a constant order of growth.

For example, any basic operation, like adding two numbers together or assigning a value to a variable, is done in a single step. Therefore, it is constant.

Recall the summation of integers from 1 to n from the previous lesson:

function sumIntegers2(n) {
  return (n * (n + 1)) / 2;
}
You saw that this algorithm had an order of growth of O(1). You also saw this growth rate depicted on a graph like this:

1 representing the constant function when all constants are factored out.
The meaning of O(1) is that the actual growth rate of this algorithm will be similar to the line f(n)=1 on the graph for all n.

The logarithmic function
The video below provides a brief introduction to logarithmic functions.


Your friend says to you, "Let's play a game. I am thinking of a number between 1 and 10. What number am I thinking of?" How can you guess the number with the fewest possible guesses? Suppose you guess 1, and your friend says, "No, higher." Then you guess 8, and your friend says, "No, lower," and so on.

Random guessing will, of course, have a worst case of 10 guesses. But because your friend is telling you higher or lower after each guess, you can take advantage of that and split the problem in half.

For example, imagine that you guess 5. Now, if your friend says "higher," you only have the numbers 6-10 to work with. And if your friend says "lower," you only have the numbers 1-4 to work with.

Given this approach, what is the maximum number of guesses needed? Here is a decision tree that shows all the possible guesses:

Decision tree showing all possible guesses.
With this approach, the worst possible case will take 4 guesses.

Now, your friend says, "I am thinking of a number between 1 and 20. What number am I thinking of?"

The problem is now twice as big. Once again, random guesses will result in a worst-case scenario of 20 guesses before getting the right answer. That is, it will take twice as long because the problem is twice as big.

But what is the worst case using the splitting technique? Is it twice as big as guessing from 10 numbers? Would it take you up to 8 guesses? Once again, you can use a decision tree to illustrate the guesses.

Decision tree showing all possible guesses using splitting technique.
The maximum number of guesses needed is only 5. The size of the problem was doubled, but the amount of work needed only increased by 1.

Similarly, if you double the problem to 40 numbers, the maximum number of guesses needed is only 6. And this goes on, no matter how big it gets. Try a few examples yourself to verify.

This growth rate, where the number of steps needed increases by 1 every time that the input size doubles, can be described by a logarithmic function. The logarithmic function is denoted as follows:

f(n) = \log nf(n)=logn
Graphically, it looks like this:

Graph of logarithmic function f(n)=log n.
The red constant line was left in the diagram for comparison.

As you can see, the logarithmic curve continues to increase, but the curve gets flatter and flatter without ever being totally flat.

Algorithms like the guessing game above, which tend to split the problem in half at each iteration, generally have a logarithmic growth rate. In later modules, you will encounter several practical algorithms that have logarithmic growth rates.

The linear function
The video below provides a brief introduction to linear functions.


The linear function is denoted as follows:

f(n) = nf(n)=n
This describes a growth rate that is proportional to the size of the input. That is, as the size of the data input to the problem increases, the number of steps correspondingly increases.

You have already encountered several algorithms with a growth rate of O(n). Generally, algorithms that involve a loop through each item in an array take linear time.

Graph showing that algorithms that involve a loop through each item take linear time.
The log-linear function
The log-linear function is denoted as follows:

f(n) = n \log nf(n)=nlogn
This describes a growth rate that grows slightly faster than linear.

Graph showing a growth rate that grows slightly faster than linear.
Later in the program, you will encounter sorting algorithms with a growth rate of O(n log n).

The quadratic function
The quadratic function is denoted as follows:

f(n) = n^2f(n)=n
2

This describes a growth rate that grows at the square of the size of the input. This is significantly faster than any of the other functions so far.

Graph showing a growth rate that grows at the square of the size of the input.
Typically, algorithms with a nested loop will yield a growth rate of O(n²).

Here is an example: Suppose that you are given the prices for a particular stock each day for a number of days. You are allowed to make one purchase on any of the given days and then sell the stock on any subsequent day. Find the best day to buy and the best day to sell to maximize your profit.

The prices are in an array like this:

const prices = [
  113,
  126,
  123,
  98,
  118,
  115,
  99,
  76,
  94,
  114,
  107,
  119,
  114,
  92,
  107,
  103,
  110,
];
One option is to use a brute-force approach and compare the price on every day to every other day, like this:

function maxSubArray(prices) {
  let bestBuy = -1;
  let bestSell = -1;
  let bestProfit = Number.NEGATIVE_INFINITY;
  for (let i = 0; i < prices.length - 1; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      const profit = prices[j] - prices[i];
      if (profit > bestProfit) {
        bestBuy = i;
        bestSell = j;
        bestProfit = profit;
      }
    }
  }
  return [bestBuy, bestSell];
}
To analyze the efficiency of this algorithm, you have to count the steps the same way as was done previously. The outer loop is straightforward to count.

Diagram showing how to analyze the efficiency of the algorithm.
The inner loop, depicted in blue on the diagram, isn't so clear. On each iteration of the outer loop, the inner loop runs a different number of times. How can you determine the actual running time of those steps?

In the first iteration of the outer loop, the inner loop runs from 1 to n. That is, it runs n times. In the second iteration, it runs from 2 to n, or n-1 times. In the third, it runs from 3 to n, or n-2 times. If the array was of length 5, for example, the inner loop would run 5+4+3+2+1 times.

Luckily, you already saw that the sum of all integers from 1 to n is given by the formula n(n+1)/2. Therefore, you can say that each statement in the inner loop runs n(n+1)/2 times.

You can rearrange this to remove those parentheses as follows:

Formula rearranged to remove parentheses.
Don't be alarmed if the math here looks a bit complicated. In this program, you won't be required to do such math yourself. Just try to follow why the conclusions are drawn.

For the purposes of this analysis, you can then take it that each instruction in the inner loop takes this number of steps to complete. That gives you the following:

1 + 1 + 1 + 1 + n + n-1 + n-1 + 1 + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n + \frac{1}{2}n^2 + \frac{1}{2}n1+1+1+1+n+n−1+n−1+1+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n+
2
1
​
 n
2
 +
2
1
​
 n
So bring all the like terms together:

\frac{1}{2}n^2 + \frac{1}{2}n^2 + \frac{1}{2}n^2 + \frac{1}{2}n^2 + \frac{1}{2}n^2 + \frac{1}{2}n^2 + \frac{1}{2}n^2 + n + n + n + \frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n + 1 + 1 + 1 + 1 + 1 - 1 - 1
2
1
​
 n
2
 +
2
1
​
 n
2
 +
2
1
​
 n
2
 +
2
1
​
 n
2
 +
2
1
​
 n
2
 +
2
1
​
 n
2
 +
2
1
​
 n
2
 +n+n+n+
2
1
​
 n+
2
1
​
 n+
2
1
​
 n+
2
1
​
 n+
2
1
​
 n+
2
1
​
 n+
2
1
​
 n+1+1+1+1+1−1−1
This can be simplified to the following:

\frac{7}{2}n^2 + \frac{10}{2}n + 3
2
7
​
 n
2
 +
2
10
​
 n+3
But, you already saw that only the highest-order term really counts in this analysis. That means that you can drop the n term and the constant term, giving the following:

\frac{7}{2}n^2
2
7
​
 n
2

And the constant coefficient doesn't matter, so you end up with this:

n^2n
2

Therefore, the order of growth of the running time of this algorithm is O(n²).

Even though the above analysis was done in painful detail, that isn't always necessary. This was done to illustrate that even though the inner loop was running a different number of times on each iteration of the outer loop, the running time of the algorithm was still O(n²).

For simple algorithms like this, you can look at the nested loop and assume that the running time is O(n²)—without going through all the steps.

Cubic and higher-order polynomials
If a nested loop results in a running time of O(n²), what is the running time of triple nested loops? This running time can be defined by the cubic function:

f(n) = n^3f(n)=n
3

On the graph, this function grows faster than anything that you have seen so far.

Graph showing the function grows faster than anything you have seen so far.
Consider the following problem:

A Pythagorean triplet is a set of three numbers {a, b, c} that satisfies the following equation:

a^2 + b^2 = c^2a
2
 +b
2
 =c
2

Find all Pythagorean triplets up to n.

To do this, you can once again use a brute-force technique that requires nested loops:

function triplets(n) {
  const result = [];

  for (let a = 1; a <= n - 2; a++) {
    for (let b = a + 1; b <= n - 1; b++) {
      for (let c = b + 1; c <= n; c++) {
        if (a * a + b * b === c * c) {
          result.push([a, b, c]);
        }
      }
    }
  }

  return result;
}
Without going through all the steps, it should be easy to spot that this algorithm has a growth rate of O(n³).

Polynomials
A polynomial is a fancy mathematical term for a class of functions that involve multiple terms joined by addition, subtraction, multiplication, and integer exponents.

You have already seen several polynomial functions in this lesson.

For example, because n⁰=1, f(n)=1 is a polynomial expression. Also, because n¹=n, f(n)=n is also a polynomial.

Similarly, f(n)=n² and f(n)=n³ are polynomials.

It is rare that you will see algorithms with a running time as bad as O(n³), O(n⁴), or higher—but they do exist. This program will lump them all into the category of higher-order polynomials and consider them so bad that algorithms with such running times aren't practical.

Exponential functions
Suppose you wish to write a program that will break a password by guessing every possible combination. For simplicity, suppose that you know that the password only consists of numbers. If the password is of length 2, how many combinations will you need to check?

00
01
02
03
...
10
11
12
13
...
96
97
98
99
That is 10², or 100 possible combinations. What if the password is of length 3? By similar logic, you can see that you need to try 10³, or 1,000 possible combinations.

In general, breaking a password of length n requires 10ⁿ tries. This gives the brute-force password-breaking algorithm a running time of O(10ⁿ).

Functions of the form shown below, where c is some constant, are called exponential functions.

f(n) = c^nf(n)=c
n

This running time is so bad that the exponential line looks almost parallel to the y-axis if it is plotted on a graph.

Other functions
There are many other functions that may be used in the analysis of algorithms, but the ones covered here are the most commonly seen. In this module, you can assume that the running time of any algorithm provided falls into one of these categories.

Summary
In summary, the functions discussed, in order of best to worst, are as follows:

Name
Function
Use with big O
Constant
f(n) = 1
O(1)
Logarithmic
f(n) = log n
O(log n)
Linear
f(n) = n
O(n)
Log linear
f(n) = n log n
O(n log n)
Quadratic
f(n) = n²
O(n²)
Cubic
f(n) = n³
O(n³)
Higher-order polynomials
f(n) = nᵏ, where k > 3
O(nᵏ)
Exponential
f(n) = cⁿ, where c > 1 is a constant
O(cⁿ)

*** 41.7 - Space complexity
Space complexity
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to determine the space complexity of a code sample.

Overview
So far, you have only learned about the time complexity of the algorithms. That is, you've learned about the worst-case (big O) amount of time that it takes for the algorithm to complete the task. However, it's also important to pay attention to the amount of space that the algorithm takes to complete the task. The space complexity of an algorithm relates to how much memory the algorithm uses.

Key Terms
Auxiliary space
The temporary or extra space used by the algorithm while it is being executed
Understanding space complexity
Space complexity is a measure of the amount of working storage that an algorithm needs. It answers the following question: in the worst case, how much memory is needed at any point in the algorithm?

Space complexity includes both auxiliary space and the space used by the input. Auxiliary space is the temporary or extra space used by the algorithm while it is being executed.

As with time complexity, you are mostly concerned with how the space needs grow, in big O terms, as the size of the input grows. Below are a few examples of expressing space complexity using big O notation, starting from slowest space growth (best) to fastest (worst):

O(1): Constant complexity means that the algorithm takes the same amount of space regardless of the input size.

O(log n): Logarithmic complexity means that the algorithm takes space proportional to the log of the input size.

O(n): Linear complexity means that the algorithm takes space directly proportional to the input size.

O(n log n) Log-linear or quasilinear complexity (also called linearithmic) means that the space complexity grows proportionally to the input size and a logarithmic factor.

O(n²): Quadratic complexity means that the space complexity grows proportionally to the square of the input size.

The space complexity analysis works similarly to time complexity.

Constant space (O(1))
To get warmed up, consider a simple function that sums two numbers:

function sum(left, right) {
  return left + right;
}
In this particular function, three variables are used and allocated in memory:

The first parameter, left

The second parameter, right

The return value

In JavaScript, a single number occupies eight bytes of memory. In the above function, there are three variables assumed to be numbers. Therefore, this algorithm always takes 24 bytes of memory to complete (3 * 8 bytes). As a result, the space complexity is constant, so it can be expressed in big O notation as O(1).

Logarithmic space (O(log n))
Logarithmic space complexity (O(log n)) is the next best thing after constant space. Although logarithmic space complexity algorithms do require more space with larger inputs, space usage increases slowly. For example, imagine that you have a function, quickSort(), which takes 128 bytes to process an input of size 10. When you increase the input by 10 times, to 100, the space required only grows to 256 bytes. When you increase the input size to 1,000, the space only grows to 384 bytes.

It is also characteristic of logarithmic algorithms that they cut the problem size in half each round through.

As you may have guessed, quicksort uses O(log n) space. You will learn more about quicksort in a later lesson.

Linear space (O(n))
Algorithms with linear space complexity (O(n)) use an amount of space directly proportional to the size of the input. Every time that you double the size of the input, the algorithms will require twice as much memory.

For example, look at the space complexity of a function that sums all of the elements in an array:

function sum(numbers) {
  let total = 0;
  for (const number of numbers) {
    total += number;
  }
  return total;
}
Again, list all variables present in the above code:

numbers: The space taken by the array is equal to 8n bytes, where n is the length of the array

number: An 8-byte number

total : An 8-byte number

The total space needed for this algorithm is 8n+8+8 bytes. The highest order of n in this equation is just n. Thus, the space complexity of the above is O(n).

Space-time complexity tradeoff
An algorithm's efficiency is a combination of its time and space complexity. So an efficient algorithm is one that is fast and that takes the least amount of memory possible.

Space and time complexity are often linked. Usually, increasing speed leads to greater memory consumption, and vice versa. However, this isn't always the case; sometimes, space and time complexity aren't correlated. For example, bubble sort is a slow algorithm that occupies minimal space. On the other hand, merge sort (which you will learn about later) is an extremely fast algorithm that requires a lot of memory.

There are also some balanced sorting algorithms. In these, the speed and space usage aren't the best, but they are acceptable in most cases.

*** 41.8 - Assessment: Intro to data structures and algorithms
** Module 42 - Searching and Sorting
*** 42.1 Overview: Searching and sorting

In this module, you will learn how to implement and use common searching and sorting algorithms for arrays.

Key Terms:
+ Searching algorithms: Algorithms that iterate through data to retrieve specific data
+ Sorting algorithms: Algorithms that bring order to data, making it easier to search, display, and understand the data

Searching and sorting are fundamental algorithms that are used by any application that deals with data. Searching refers to iterating through the data to retrieve specific data, and sorting refers to putting the data in order.

Searching algorithms are essential for a wide variety of tasks. For example, the IRS uses searching to look up your tax records. And more broadly, you use searching algorithms anytime that you use a search engine like Google. Likewise, sorting is important to bring order to data; this makes it easier to search, display, and understand the data. For example, search engine results are sorted such that the most relevant sites for a given search term are listed first. And the contacts on your phone are ordered alphabetically by name so that it is easier to find a specific person.

Searching algorithms and sorting algorithms are different for different data structures. In this module, you'll focus on searching and sorting for arrays.

*** 42.2 Linear search

Overview
Finding a specific element in an array of data is one of the most common
activities that you will do in programming.
In this lesson, you will learn about linear search, which is the most basic
algorithm for searching through an array of data.

Key Terms
- Linear search algorithm: Also known as the sequential search algorithm, an
algorithm that checks every element in an array, starting from the leftmost
element, and continues until the desired element is found
- Brute-force algorithm: Any algorithm that doesn't use any logic to try to do its
job quickly or somehow reduce the number of elements that it searches for a
matching value

Understanding linear search
The linear search algorithm, also known as the sequential search algorithm,
checks every element in an array until the desired element is found. The
algorithm starts at the leftmost element. Then it continues searching until it
either finds the desired element or goes through all of the elements in the
array. Once the first element with the correct value is found, the position (or
index) for that element is returned. If the desired element isn't in the array,
-1 is returned.

Consider the following example, where the linear search algorithm is searching
an array of numbers to find the value 37.

Example of linear search algorithm searching an array of numbers to find the value 37.
In the above example, 11—the index of 37—is returned.

Linear search in JavaScript
The classic example of a linear search algorithm is the indexOf() function,
which searches for a particular value within an array. Take a look at the
traditional implementation of indexOf():

function indexOf(value, elements) {
  for (let index = 0; index < elements.length; index++) {
    if (elements[index] === value) {
      return index;
    }
  }
  return -1;
}
The indexOf() function above accepts two parameters: the desired value and the
  array to which the linear search algorithm is applied.

The algorithm iterates through the array, checking each value until it finds an
element equal to the supplied value. At that point, the index—the first position
of the value in the array—is returned. If the algorithm reaches the end of the
array without finding the value, it returns -1, indicating that the value wasn't
found.

Consider the following code:

const index = indexOf(5, [1, 3, 5, 7, 9]);
console.log(index);
When you run this code, 2 will be printed because the value 5 is at array index 2.

But what happens if you have an array of objects like the following?

const people = [
  {
    id: 1,
    first_name: "Monah",
    last_name: "Yarnall",
    age: 17,
  },
  {
    id: 2,
    first_name: "Daphne",
    last_name: "McGaugey",
    age: 81,
  },
  {
    id: 3,
    first_name: "Walker",
    last_name: "Bucknell",
    age: 81,
  },
];
How do you use the above indexOf() function to find the first person whose age
is 81? As you can see, the problem with the traditional implementation is that
it must exactly match the value of an element in the array; there is no way to
match on a property of an object in the element. If you want to match in a
different way, you have to write an entirely new function.

A better solution is to separate the matching logic from the linear search
algorithm. To accomplish this, you can have the caller pass in a function that
implements the matching logic (returning true when a matching element is found).
Then the linear search algorithm can call that function to determine whether or
not the current element is a match.

The following video provides an overview of this topic. Watch the video, and then complete the practice task below.


Do this
Implement a linear search
Now you will implement a linear search algorithm as a higher-order function that takes the following two parameters:

isMatch() is a function that takes the current element, current index, and original array as parameters. It returns true when a matching element is found.

elements is the array to which the linear search algorithm is applied.

In a new directory, create a file named indexOf.js. In indexOf.js, add the following code:

function indexOf(isMatch, elements) {
  if (Array.isArray(elements)) {
    for (let index = 0, length = elements.length; index < length; index++) {
      if (isMatch(elements[index], index, elements)) {
        return index;
      }
    }
  }
  return -1;
}

module.exports = indexOf;
In this implementation, the algorithm goes through all of the elements in the array and calls isMatch(), passing in the element, index, and array. The variable index keeps track of where it is in the array. If isMatch() returns true, it will return the current value for index. But in cases where isMatch() always returns false, -1 is returned after the loop; this indicates that the function didn't find the desired element.

Now that you have an implementation of indexOf(), you will use it to search for matching elements.

Next, create a file named linearSearch.js. In linearSearch.js, add the following code:

const indexOf = require("./indexOf");

const people = [
  {
    id: 1,
    first_name: "Monah",
    last_name: "Yarnall",
    age: 17,
  },
  {
    id: 2,
    first_name: "Daphne",
    last_name: "McGaugey",
    age: 81,
  },
  {
    id: 3,
    first_name: "Walker",
    last_name: "Bucknell",
    age: 81,
  },
];

function personIs81(person) {
  return person.age === 81;
}

console.log(indexOf(personIs81, people));

function numberIs5(value) {
  return value === 5;
}

console.log(indexOf(numberIs5, [1, 3, 5, 7, 9]));
Then run the code, using the command node linearSearch.js.

As you can see, passing in the isMatch() function isolates the search algorithm from the matching criteria. Now the search algorithm doesn't need to change, no matter what the matching criteria happen to be.

The efficiency of linear search
Linear search is a classic example of a brute-force algorithm. In other words,
it doesn't use any logic to try to do its job quickly or somehow reduce the
number of elements that it searches for a matching value. As a rule, the larger
the array is, the longer that linear search will take to find a matching
element.

As shown in the table below, the worst-case time complexity of linear search is
O(n), where n is the number of elements in the array being searched. With linear
search (as well as most other search algorithms), the worst-case scenario occurs
when the element doesn't exist in the array. If the element isn't in the array,
the algorithm would still need to iterate through all n elements to determine
that the element isn't there.

The best-case time complexity of linear search is O(1). This happens when the
element that you are looking for is in the first slot of the array. The
algorithm wouldn't really iterate n times; it would find the element on the
first try.

Linear search is by far the simplest search algorithm; it's one that doesn't
focus on speed.

Description Notation Explanation
Worst case O(n) There is no matching element in the array.
Average case O(n) The matching element is in the middle of the array.
Best case O(1) The element is in the first slot of the array.

*** 42.3 Binary search

Overview
Searching a sorted collection is a common task. If the list to be searched
contains more than a few items, a binary search will require far fewer
comparisons than a linear search. However, binary searches impose the
requirement that the list be sorted.

Key Terms
Binary search algorithm - Also known as a half-interval search algorithm, an
algorithm to find a specific element located in a sorted array
Understanding binary search - The video below provides a brief introduction to
binary search. Start by watching the video, and then read through the rest of
the lesson and complete any practice tasks.


Binary search, also known as a half-interval search, is a search algorithm to
find a specific element located in a sorted array. It only works with sorted
arrays. Binary search is advantageous over linear search because it searches
more quickly and efficiently. It does this by halving the number of elements to
check with each iteration.

As you learned in the previous lesson, a linear search algorithm searches the
array starting at index 0, then 1, 2, 3, 4, and so on. In contrast, a binary
search divides the array in half each time that it looks for a target value.

In a binary search, you define an index to refer to the element in the middle of
the array. Then you test whether the target value is less than, greater than, or
equal to the value at the index. If the target value is less than or greater
than the index, the algorithm removes either the left or right half of the array
from the search, respectively. If the element is found, the position (or index)
of the element is returned. If the desired element isn't in the array, -1 is
returned.

This can be confusing, so take a look at the following visualization of this
process. In this example, the algorithm is searching an array of increasing
numbers to search for the value 37.

Example of algorithm searching an array of increasing numbers for the value 37.
Binary search algorithms work as follows:

You need to keep track of three things to perform a binary search: lowerIndex,
index, and upperIndex.

lowerIndex will always start at 0: let lowerIndex = 0;

upperIndex is calculated using array.length: let upperIndex = array.length—1;

index is calculated by summing lowerIndex and upperIndex, and then dividing
by 2. Math.floor() is used to round down in case of an odd number of elements:
const index = Math.floor((lowerIndex+upperIndex)/2).

The while loop will then repeat until it ends. In this case, the loop is as
follows: while(lowerIndex <= upperIndex).

The algorithm compares the number at index to the target number to determine if
it is greater than, less than, or equal to the target value.

If the value at index is equal to the target value, return index.

If the value at index is less than the target value, then the target value will
be somewhere to the right of the index. The algorithm will then assign the
lowerIndex to index+1, thus ignoring the left half of the array.

If the value at index is greater than the target value, then the target value
will be somewhere to the left of the index. The algorithm will then assign
upperIndex to index-1, thus ignoring the right half of the array.

If the target value isn't found, the value of index is recalculated to be in the
middle of the new values for lowerIndex and upperIndex (const index =
Math.floor((lowerIndex+upperIndex)/2)). Then the loop continues at the previous
step. The loop may iterate once, or it may iterate dozens of times, depending on
the array size and the target number.

Put this all together, and you have a binary search!

Binary search in JavaScript
Just as you did with linear search, you will separate the matching logic from
the search algorithm. To accomplish this, the caller will supply a compare
function. This function tells the binary search whether to search to the left,
search to the right, or return index because the current element is a match.

Watch the following videos for an overview of this topic. Then practice applying
your new binary search skills by completing the practice task below.



Do this
Implement a binary search
Now you will implement a binary search algorithm as a higher-order function that
takes the following two parameters:

compare: A function that takes the current element, current index, and original
array as parameters. It returns one of the following:

0 if the current element is equal to the desired value

A positive value if the current element is greater than desired value by the
ordering criterion

A negative value if the current element is less than desired value by the
ordering criterion

sortedElements: The sorted array to which the binary search algorithm is
applied.

Next, create a file named binaryIndexOf.js. In binaryIndexOf.js, add the
following code:

function binaryIndexOf(compare, sortedElements) {
  if (Array.isArray(sortedElements)) {
    let lowerIndex = 0;
    let upperIndex = sortedElements.length - 1;

    while (lowerIndex <= upperIndex) {
      const index = Math.floor((upperIndex + lowerIndex) / 2);

      const comparison = compare(sortedElements[index], index, sortedElements);

      if (comparison > 0) {
        lowerIndex = index + 1;
      }

      if (comparison === 0) {
        return index;
      }

      if (comparison < 0) {
        upperIndex = index - 1;
      }
    }
  }
  return -1;
}

module.exports = binaryIndexOf;
As you can see, lowerIndex always starts at zero (let lowerIndex = 0;), and
upperIndex starts at the largest index for the array (let upperIndex =
sortedElements.length-1;). If the array is empty, lowerIndex === 0 and upperIndex
=== -1, which means that the while loop never executes. If lowerIndex <=
upperIndex, then the while loop does execute.

In the while loop, the first step is to calculate the value of index. There may
be an odd number of elements, so you will use Math.floor() to round down to the
nearest integer. Now, index points to the middle of the array.

Next, call the compare() function, passing in sortedElements[index], index, and
sortedElements. The return value from compare will tell the algorithm what to do
next.

If compare() returns 0, the target value is found, so index is returned.

If compare() returns a value greater than 0, the target value is greater than
the value at index, so lowerIndex is moved to index+1. In other words, the
algorithm ignores the elements to the left of index.

If compare() returns a value less than 0, the target value is less than the
value at index, so upperIndex is moved to index-1. In other words, the algorithm
ignores the elements to the right of index.

This process then repeats, moving lowerIndex and upperIndex closer and closer
together. This continues until compare() returns 0, or until lowerIndex is
greater than upperIndex and -1 is returned.

Now that you have an implementation of binaryIndexOf(), you will use it to
search for matching elements. Create a new file named binarySearch.js. In
binarySearch.js, add the following code:

const search = require("./binaryIndexOf");

const elements = [1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136];

function forNumber(target) {
  return (element, index) => {
    console.log("compare", target, "to", element, "at index", index);

    if (element === target) {
      return 0;
    }
    if (element < target) {
      return 1;
    }
    if (element > target) {
      return -1;
    }
  };
}

console.log(search(forNumber(274), elements));
Then run the code, using the command node binarySearch.js. You will see the following:

compare 274 to 44 at index 6
compare 274 to 504 at index 10
compare 274 to 149 at index 8
compare 274 to 274 at index 9
9
In this case, binary search required only four steps to find the target value. A
linear search would have required nine steps.

As you can see, you can use the compare function passed into binaryIndexOf() to
observe exactly what the algorithm is doing—without changing the code in
binaryIndexOf.js. This can be very helpful when debugging the search algorithm.

The efficiency of binary search
Binary search is a classic example of dividing a problem into a number of
smaller problems. With each iteration of the search, the number of elements
being considered gets cut in half. As a rule, a linear search will be faster for
fewer than 10 elements. However, for larger arrays, a binary search will be more
efficient.

As you can see in the table below, the worst-case time complexity of binary
search is O(log n), where n is the number of elements in the array being
searched. As with linear search, the worst case for binary search occurs when
the element doesn't exist in the array. When the element isn't in the array, the
algorithm needs to go through log(n) elements to determine that the element
isn't there.

The best-case time complexity of binary search is O(1). This happens when the
matching element is in the middle of the array (first comparison).

The average-case complexity is O(log n). This happens when the matching element
is somewhere in the array but not in the middle.

Description Notation Explanation
Worst case O(log n) There is no matching element in the array.
Average case O(log n) The matching element is somewhere in the array but not in the middle.
Best case O(1) The matching element is in the middle of the array.

*** 42.4 Recursion


Overview
You know that a function can call any other function, but did you know that a
function can also call itself? A function that calls itself is called a
recursive function, and that's exactly what you'll learn about in this lesson.

Key Terms
Recursion - A problem-solving method that involves a function calling itself
Top-down recursive function - A function that calculates the solutions to each subproblem in the forward phase, passing the results of the calculation to the recursive call
Bottom-up recursive function - A function that breaks down the problem into increasingly smaller problems until the base case is encountered, and then combines the solutions in the backward phase
Stack overflow error - A runtime error where the call stack gets too big and runs out of space
Forward phase - Also called the recursive phase, the phase that happens when the function is calling itself and continues until the base case is satisfied
Backward phase - Also called the back-out phase, the phase that starts when a function call satisfies the base case, then returns a value to the function that called it, and continues until a value is returned to the initial function call

Recursion
In computer science, recursion is a problem-solving method that involves a function calling itself. In each call, it breaks down the problem into smaller and smaller subproblems until it reaches a problem small enough that it can be solved trivially.

Think of recursion as a process of defining the solution to a problem in terms of a simpler version of itself. Recursion may be applied to several data structures and algorithms to solve problems, but recursion itself isn't a data structure or an algorithm—it is a concept.

A recursive algorithm is broken down into two parts:

The base case (or base cases), which indicates when to stop

The recursive case (or recursive cases), which is where the function calls itself

Key Term
Base case: The solution to the "simplest" possible problem; this case provides a terminating condition for the recursive case

Note that the base case doesn't require calling itself. It ensures that you don't infinitely recurse: it provides a terminating condition for the recursive case.

Key Term
Recursive case: Where you call the same function to solve increasingly simple versions of the problem

A recursive algorithm may have more than one base case or recursive case. In other words, it may involve calling the same function with different arguments for each recursive case.

To better understand this concept, consider the following example. For simplicity, this example consists of a single base case and a single recursive case.

Factorial
The factorial for any positive integer n is written as n!. It is defined to be the product of all integers between 1 and n, inclusive:

n!= n * (n−1) * (n−2) * \ldots * 1n!=n∗(n−1)∗(n−2)∗…∗1
So if you were to calculate 4!, the result would be 24:

4! turns into 4*3*2*1=24.

And 5! is 120:

5! turns into 5*4*3*2*1=120, which is 5*4!.

As you can see, each factorial calculation for n! is n*(n-1)!. But what is the base case? Because n must be a positive integer, once n is less than or equal to 1, there is no simpler version of n!. Any n less than or equal to 1 is the base case for the factorial function. This means that the function should stop calling itself when n <= 1.

Do this
Implement a recursive factorial
Now, you will implement a recursive factorial function.

First, create a file named factorial.js. In factorial.js, add the following code:

function factorial(number) {
  console.log("Forward phase", number);

  // Base case
  if (number <= 1) {
    console.log("base case", number);
    return 1;
  }

  // Recursive case
  const numberMinusOneFactorial = factorial(number - 1);

  console.log("Backward phase", number, "*", numberMinusOneFactorial);

  return number * numberMinusOneFactorial;
}

console.log(factorial(5));
In the above function, note the following:

The console.log() statements record the phases of the recursive function. More on this later.

The if statement is the base case. It checks to see if the value of number is less than or equal to one. If so, the return value is always 1.

In the recursive case, the function calls itself to calculate factorial(number-1). It is breaking down the problem into a set of smaller problems like the formula above n! = n * (n-1)!.

After the recursive case, the function can calculate the return value for number!.

Now, run the code, using the command node factorial.js. You will see something like the following:

node factorial.js

Forward phase 5
Forward phase 4
Forward phase 3
Forward phase 2
Forward phase 1
base case 1
Backward phase 2 * 1
Backward phase 3 * 2
Backward phase 4 * 6
Backward phase 5 * 24
120
As you can see, there are two distinct phases in a recursive function: the forward phase and the backward phase.

The forward phase of recursion happens when the function is calling itself. The forward, or recursive phase, continues until the base case is satisfied. The backward phase (also called the back-out phase) starts when a function call satisfies the base case. The call then returns a value to the function that called it. This continues until a value is returned to the initial function call.

As you can see from the output above, the first call to factorial(5) doesn't return until all recursive calls have returned.

The animation below shows each of the recursive calls that are happening within the forward phase of the call to factorial(5):

Example showing each recursive call within the forward phase of the call to factorial(5).
Once the base case is encountered, the call to factorial(1) returns 1 to the caller, which in turn returns 2*1 to its caller. This pattern continues until control is returned to the caller of factorial(5). This is the backward phase.

In short, the forward phase is breaking down the problem into increasingly smaller problems until the base case is encountered. Then the recursive function switches to the backward phase, which combines the base case with the previous problem to ultimately provide a solution for the original problem. This is called a bottom-up recursion because there is no work done until the base case is encountered.

Bottom-up recursion
A bottom-up recursive function, like the example above, breaks down the problem into increasingly smaller problems until the base case is encountered. Then it combines the solutions in the backward phase. In other words, there are no solutions or calculations until the base case is reached. This is a very common approach in recursive functions.

As you might have guessed, there is also a top-down approach, which you will read about next.

Top-down recursion
A top-down recursive function calculates the solutions to each subproblem in the forward phase, passing the results of the calculation to the recursive call. In other words, the solution is incrementally calculated, and by the time the base case is reached, the full solution is calculated.

Next, you will write a top-down recursive factorial function.

Do this
Implement a top-down recursive factorial
Now, implement a top-down recursive factorial function.

First, create a file named topDownFactorial.js. In topDownFactorial.js, add the following code:

function factorial(number, total = 1) {
  console.log("Forward phase", number, "*", total);

  // Base case stays the same
  if (number <= 1) {
    console.log("base case", number);
    return total;
  }

  total = factorial(number - 1, total * number);

  console.log("Backward phase", number, total);
  return total;
}

console.log(factorial(5));
In the above function, note the following:

There is a new parameter, total, used to pass information to the recursive function call. The total parameter starts at 1 so that it can be multiplied by each number in the subproblems.

The if statement for the base case is still the same, but rather than return 1, it always returns the current total.

In the recursive case, the function calls itself, passing in total * number as the total parameter, thus calculating the total in the forward phase.

After the recursive case, no further calculation is required, so this function returns the value from the recursive call.

When you run the code using node topDownFactorial.js, you will see something like the following:

node topDownFactorial.js

Forward phase 5 * 1
Forward phase 4 * 5
Forward phase 3 * 20
Forward phase 2 * 60
Forward phase 1 * 120
base case 1
Backward phase 2 120
Backward phase 3 120
Backward phase 4 120
Backward phase 5 120
120
In looking at the output above for five factorial, the total is the result of the previous calculation. For example, the first line of output shows the number 5, times the total, 1. The second line of output uses the product of 5 and 1 to get the value 5. The third line of output uses the product of 4 and 5 to get the value 20, and so on. Each recursive call is passed the total derived from the previous calculation for use in its own calculation.

As you can see, there are still two distinct phases in this recursive function: the forward phase and the backward phase. However, the solution is calculated in the forward phase.

Top-down and bottom-up recursive functions can provide simple solutions to complicated problems, but you might run into an error if the number of subproblems gets too big.

Stack overflow errors
Recursion has a problem: it builds up a call stack of size n, where n is the number of subproblems. This makes it vulnerable to a stack overflow error, where the call stack gets too big and runs out of space. For example, if you call factorial(5000000), you will get a Maximum call stack size exceeded error during the forward phase.

To avoid the stack space limitation, you can rewrite the recursive function to use iteration instead. The following is an iterative factorial() function:

function factorial(number) {
  // Base case
  if (number <= 1) {
    return 1;
  }

  // Penultimate means second to the last in a series.
  let penultimate = 1;
  let total = 0;

  // Calculate the factorial from 1 to `number`
  for (let ultimate = 1; ultimate <= number; ultimate++) {
    console.log(ultimate, "*", penultimate);
    total = ultimate * penultimate;
    penultimate = total;
  }
  return total;
}
All recursive functions can be rewritten to be iterative functions. Sometimes, the recursive function is easier to understand than the iterative version. For example, many programmers would say that the recursive factorial() function is easier to understand than the iterative version.

Principles of recursive problem-solving
To think recursively, you ask the question, "What could I do if I had the solution to a smaller version of this same problem?"

For example, recall the sum of the first n integers problem that was introduced in a previous lesson. The problem is as follows: given an integer n, find the sum of all integers from 1-n, inclusive. For example, if n=4, the solution involves the sum 1+2+3+4=10.

How would you go about solving this recursively?

Step 1: The smaller subproblem
The first step is to think about the smaller problem. If you need to find the sum of all numbers from 1-5, you may ask, "Is there a smaller version of this same problem?" In this case, finding the sum of all integers from 1-4 is a smaller problem than finding the sum of all integers from 1-5.

You know that this smaller subproblem would help if you can take the solution to the smaller subproblem and use it to solve the original problem. For example, suppose that you know that the sum of all integers from 1-4 is 10. How can that help you find the sum of all integers from 1-5?

In this case, you take the solution to the subproblem and add 5, giving you 10+5=15.

Step 2: The recursion
The question now is, "How did you find the solution to the sum of all numbers from 1-4?" Can you apply the same steps that you applied above?

The problem is to find the sum of all integers from 1-4. The smaller problem is to find the sum of all integers from 1-3. Again, supposing that you did have the solution to that smaller problem, what would you do? Given that the sum of all numbers from 1-3 is 6, you would simply add 4 to that solution—giving 6+4=10.

Notice that solving the sum from 1-4 problem involved the same steps as solving the sum from 1-5 problem. You could even go another step; think about solving the sum from 1-3 problem and see if the same steps apply.

At this point, you know the following:

To solve for n, you need to get the solution for the n-1 subproblem.

If you have the solution for the n-1 subproblem, you just add n to get the final solution.

Step 3: The base case
If you keep reducing the size of the problem as you did in the step above, eventually the problem will get small enough that the answer is trivial. In this case, you are reducing the problem by 1 each time. Eventually, you will get to the sum of all integers from 1-1 problem.

At this point, there really is no calculation necessary. The sum of all integers from 1-1 is just 1. This is the base case.

You now have all the pieces to put together a complete solution.

Step 4: Putting it all together
It is now time to put the pieces together into a solution to the problem. You have the following pieces:

The base case: When n is 1, the answer is 1.

The recursive case: When n is greater than 1, find the solution to n-1.

The summation: The answer is to add n to the solution to n-1.

In pseudocode, this algorithm may be written as follows:

function sum(n):
  // Accepts n - find the sum from 1 to n
  // First, check the base case
  if n is equal to 1 then:
    return 1

  // Otherwise, find the solution to the subproblem
  // by making a recursive call
  subproblemSum = sum(n - 1)

  // Summation
  return n + subproblemSum;
Do this
Implement the sum to n function
Create a file named sumToN.js, and add the following implementation.

function sum(n) {
  // Check the base case
  if (n === 1) {
    return 1;
  }

  return n + sum(n - 1);
}
Test that this function provides the correct output.

String splitter
The two examples above involved numbers, but recursion may be applied to many types of problems. Consider splitting a string according to some given separator.

Given a string and a separator character, split the string by the separator and return an array of the substrings created. You may recognize this as JavaScript's built-in string split() function. You are going to use recursion to implement your own version of this function.

For example, given the string "Be generous in prosperity and thankful in adversity" and the separator " ", the algorithm should return the array ["Be", "generous", "in", "prosperity", "and", "thankful", "in", "adversity"].

The subproblem
What would a smaller version of this problem look like? What affects the complexity of the problem? In this case, it is the number of occurrences of the separator in the string.

Take as an example the string "4-8-2023" and the separator "-". A smaller version of this problem is a string with one less separator, say "8-2023". What if you already had the solution to that subproblem? You can see that the solution would be ["8", "2023"].

The final solution would be inserting the substring "4" into the array, giving ["4", "8", "2023"].

The recursion
In a similar manner, to find the solution to "8-2023", you can find the solution to the subproblem "2023" and simply insert the string "8" in the resulting array.

The base case
If you keep reducing the string by the number of separators found in the string, eventually you end up with a string with no separators. If the string contains no separators, what is the solution?

The solution is simply an array containing the given string. Given the string "2023" and the separator " ", the solution is the array ["2023"].

Putting it all together
You now have the necessary pieces of the solution.

The base case: For a string containing no separators, return an array containing the string.

The recursive case: Find the first separator, extract the substring from the first character to the first separator, and recursively solve the rest of the string from the first separator onward.

Final solution: Insert the substring into the array returned from the recursive step.

In pseudocode, this may be written as follows:

function split(text, separator):
  // Inputs: text - the string to be split
             separator - the character to be used to split the text

  search for the first occurrence of the separator in the text
  // Base case
  if no separator is found then:
     return [text]

  // Recursive case
  extract substring from character 0 to index of first occurrence of separator
  extract rest of string from first occurrence of separator + 1 to end of string
  recursively solve the rest of string
  insert the substring in the resulting array
  return the array
Do this
Implement the string split function
Create a file named split.js, and add the following implementation.

function split(text, separator) {
  // Find the index of the first occurrence of separator
  let index = text.indexOf(separator);

  // Base case
  if (index === -1) {
    return [text];
  }

  // Find the substrings
  let start = text.substring(0, index);
  let rest = text.substring(index + 1);

  // Recursive call
  let restSolution = split(rest, separator);

  // Insert the first substring
  restSolution.unshift(start);

  return restSolution;
}
Test the function to ensure that it works as expected.

The efficiency of recursive functions
In JavaScript, a loop is essentially always more efficient than a recursive function call. Allocating memory for the next function call takes time and memory that isn't required in a loop. However, recursion is almost never used for performance reasons; it's used to make the problem simpler and the code easier to understand.

*** 42.5 Bubble sort

Bubble sort
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to implement bubble sort and give the runtime.

Overview
Sorting items in an array is among the most common activities in programming. In this lesson, you'll learn about bubble sort, a simple sorting algorithm that compares two adjacent elements and swaps their positions if they are out of order.

Key Terms
Bubble sort algorithm
Also called sinking sort, a comparison sorting algorithm that repeatedly steps through the elements in an array, compares two adjacent elements, and swaps them if they are in the wrong order
Understanding bubble sort
The video below provides a brief introduction to bubble sort. Start by watching the video, and then read through the rest of the lesson and complete any practice tasks.


Bubble sort (or sinking sort) is a simple comparison sorting algorithm. It repeatedly steps through the elements in an array, compares two adjacent elements, and swaps them if they are in the wrong order. The pass through the array repeats until the array is sorted. The algorithm is named for the way that smaller or larger elements "bubble" to the top of the array.

The idea behind bubble sort is that, after each pass through the array, the elements furthest to the right are ordered correctly. To see how this works, consider how a bubble sort algorithm sorts the array [7, 5, 9, 3, 1]:

The first pass through the array will start by comparing the first pair of values, 7 and 5. 5 is smaller than 7, so the algorithm will swap the two values.

Then it will move on to compare the next pair of values, 7 and 9. 9 is greater than 5, so it moves on to the next pair, 9 and 3.

3 is smaller than 9, so the algorithm will swap the two values.

It then compares the next pair, 9 and 1. 1 is smaller than 9, so the algorithm will swap the two values.

After the first pass through the array, the elements are in the following order: [5, 7, 3, 1, 9]. 9 is in the correct position.

Now, the algorithm needs to iterate through the array again because it wasn't in order. The algorithm will continue to iterate through the entire array over and over, swapping elements until it can make one full pass through the array without swapping any elements. Only then is the array sorted.

Here's a visualization of this process:

Visualization of bubble sort process.
Bubble sort in JavaScript
Just like other algorithms, you will separate the comparison logic from the sorting algorithm. To accomplish this, the caller will supply a compare function that tells bubble sort whether or not two adjacent elements are in order.

Watch the following video for an overview of this topic. Then practice applying your new bubble sort skills by completing the practice task below.


Do this
Implement a bubble sort
Now you will implement a bubble sort algorithm as a higher-order function that takes the following two parameters:

compare: A function that compares two elements. It takes two parameters: left and right. It returns one of the following:

0 if the left element is equal to the right element

A positive value if the left element is greater than the right element by the ordering criterion

A negative value if the left element is less than the right element by the ordering criterion

elements: The array to which the bubble sort algorithm is applied.

Next, create a file named bubbleSort.js. In bubbleSort.js, add the following code:

function bubbleSort(compare, elements) {
  if (Array.isArray(elements)) {
    let inOrder;

    do {
      inOrder = true; // Assume that the array is in order

      for (
        let index = 0, length = elements.length - 1;
        index < length;
        index++
      ) {
        const leftElement = elements[index];
        const rightElement = elements[index + 1];

        if (compare(leftElement, rightElement) > 0) {
          elements[index] = rightElement;
          elements[index + 1] = leftElement;
          inOrder = false; // The array wasn't in order, so swap elements and then check it again.
        }
      }
    } while (inOrder === false);
  }
  return elements;
}

module.exports = bubbleSort;
Now that you have an implementation of bubbleSort(), you will use it to sort an array.

Next, create a new file named useBubbleSort.js. In useBubbleSort.js, add the following code:

const sort = require("./bubbleSort");

const elements = [4685, 471, 880, 808];

function compare(left, right) {
  console.log("compare", left, "to", right);
  return left - right;
}

console.log(sort(compare, elements));
Then run the code, using the node useBubbleSort.js command. You will see the following:

compare 4685 to 471
compare 4685 to 880
compare 4685 to 808
compare 471 to 880
compare 880 to 808
compare 880 to 4685
compare 471 to 808
compare 808 to 880
compare 880 to 4685
[ 471, 808, 880, 4685 ]
As you can see in the output above, you can use the compare function passed into bubbleSort() to observe exactly what the algorithm is doing—without changing the code in bubbleSort(). This can be very helpful when debugging the sort algorithm.

In this case, bubble sort had to do 9 comparisons to sort 4 numbers. It might take 20 comparisons to sort 5 numbers, and so on. In the worst case, the number of comparisons goes up polynomially to the number of elements in the array.

The efficiency of bubble sort
Bubble sort is the classic "terrible" sorting algorithm. This algorithm isn't suitable for large datasets because its average-case complexity is O(n²). This simple algorithm doesn't perform well in real-world use; it's used primarily as an educational tool to introduce the concept of sorting.

The best-case time complexity of bubble sort is O(n). This happens when the list is already sorted in ascending order. In this case, none of the elements are moved but the algorithm still makes n comparisons making the time complexity O(n).

Description Notation Explanation
Worst case O(n²) Every element is out of order.
Average case O(n²) Some elements are out of order.
Best case O(n) The list is already sorted.

*** 42.6 Merge sort

Merge sort
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to implement merge sort and give the runtime.

Overview
Merge sort takes a divide-and-conquer approach to sorting. As you'll see in this lesson, it breaks down the array into continually smaller chunks, then merges them back together in the correct order.

Key Terms
Merge sort algorithm
A divide-and-conquer algorithm that continuously splits arrays in half until every element is alone in its own array, then merges each subarray in order
Understanding merge sort
The video below provides a brief introduction to merge sort. Start by watching the video, and then read through the rest of the lesson and complete the practice exercises. This will give you a thorough understanding of this topic.


Similar to binary search, merge sort is a divide-and-conquer algorithm. The goal is to break down the problem into subproblems until you have a lot of simple problems that can be easily put back together.

Merge sort starts by taking the entire array and breaking it into many subarrays. To do this, it continuously splits every array in half, until every element is alone in its own array. Then, during the return phase, each subarray is merged in order. Merging two single-element arrays in order is rather easy: look at the first element of each array, select the smaller element, and then add the other element.

This merge technique works for sorted arrays of any length: look at the first element of each array, slice off the smaller of the two elements, and repeat as long as there are elements in both arrays. Then add on any left-over elements.

For example, take the following array: [5, 2, 8, 15, 3]. This array gets divided and merged as follows:

Diagram showing how array gets divided and merged.
Once merge sort breaks down part of the array into single elements, it starts merging them. Because both arrays are already sorted, it can easily compare which number in each is smaller and put both in the right place.

Thus, in the final merge of the [2, 5] and [3, 8, 15] arrays, the algorithm compares the first element of each array (2 versus 3), and slices off the smaller element, 2. It then compares the first element of the remaining arrays, which is 5 versus 3 now, and slices off 3. Then it compares 5 and 8, and slices off 8. It continues until each element is in the correct order in the new array.

Merge sort in JavaScript
Just like other algorithms, you will separate the comparison logic from the sorting algorithm. To accomplish this, the caller will supply a compare function that tells merge sort whether or not two adjacent elements are in order.

Do this
Implement merge sort
Now you will implement a merge sort algorithm as a higher-order function that takes the following two parameters:

compare: A function that compares two elements, so it takes two parameters: left and right. It returns one of the following:

0 if the left element is equal to the right element

A positive value if the left element is greater than the right element by the ordering criterion

A negative value if the left element is less than the right element by the ordering criterion

elements: The array to which the merge sort algorithm is applied.

Next, create a file named mergeSort.js. In mergeSort.js, add the following code:

function mergeSort(compare, elements) {
  if (Array.isArray(elements)) {
    if (elements.length <= 1) {
      return elements;
    }

    const middle = Math.floor(elements.length / 2);

    const leftElements = elements.slice(0, middle);
    const rightElements = elements.slice(middle);

    const leftElementsSorted = mergeSort(compare, leftElements);
    const rightElementsSorted = mergeSort(compare, rightElements);

    return merge(compare, leftElementsSorted, rightElementsSorted);
  }
  return elements;
}

/**
 * Merges two sorted arrays
 *
 * @param compare
 *  Function to compare elements of the array
 * @param left
 *  The left sorted array
 * @param right
 *  The right sorted array
 * @returns {*[]}
 *  The left and right sorted arrays merged in sorted order
 */

function merge(compare, left, right) {
  const sorted = [];
  let leftIndex = 0;
  let rightIndex = 0;

  while (leftIndex < left.length && rightIndex < right.length) {
    const comparison = compare(left[leftIndex], right[rightIndex]);

    if (comparison < 0) {
      sorted.push(left[leftIndex]);
      leftIndex++;
    } else {
      sorted.push(right[rightIndex]);
      rightIndex++;
    }
  }

  return sorted.concat(
    leftIndex < left.length ? left.slice(leftIndex) : right.slice(rightIndex)
  );
}

module.exports = mergeSort;
This is how the above mergeSort() function works:

The first step is to handle the recursive base case, which is when the array has one or fewer elements. In this case, just return the array.

Next, calculate the value of middle. There may be an odd number of elements, so use Math.floor() to round down to the nearest integer. Now, middle points to the middle of the array.

Next, create two new arrays from the original array, splitting the arrays at index middle.

Then, make two recursive calls to mergeSort(). Each recursive call is passed one of the new arrays.

Finally, when the recursive calls return, merge the two sorted arrays by calling the merge() function. Within the merge(), you initialize an empty array, sorted, to hold the final result. You also initialize two pointers, leftIndex and rightIndex, which point at the first element in the left and right arrays respectively. During each iteration of the loop, the elements at leftIndex and rightIndex are compared; the smaller of the two is pushed into the sorted array, and its corresponding pointer index is incremented by one. This loop continues until one of the pointers exceeds the length of the array. At the end, any remaining elements are concatenated with the sorted array.

Now that you have an implementation of mergeSort(), you will use it to sort an array.

Next, create a new file named usemergeSort.js. In usemergeSort.js, add the following code:

const sort = require("./mergeSort");

const elements = [260, 926, 954, 208, 669, 183];

function compare(left, right) {
  console.log("compare", left, "to", right);
  return left - right;
}

console.log(sort(compare, elements));
Then run the code, using the command node usemergeSort.js. You will see the following:

compare 926 to 954
compare 260 to 926
compare 669 to 183
compare 208 to 183
compare 208 to 669
compare 260 to 183
compare 260 to 208
compare 260 to 669
compare 926 to 669
[ 183, 208, 260, 669, 926, 954 ]
As you can see in the output above, you can use the compare function passed into mergeSort() to observe exactly what the algorithm is doing without changing the code in mergeSort; this can be very helpful when debugging the sort algorithm.

In this case, merge sort had to make 9 comparisons to sort 6 numbers. It would take 11 comparisons to sort 7 numbers, and so on. In the worst case, the number of comparisons goes up logarithmically to the number of elements in the array.

The efficiency of merge sort
Merge sort is the best sorting algorithm that you have learned so far, and it is significantly better than bubble sort's O(n²). Keep in mind that it also works better with larger amounts of data.

In merge sort, the time complexity of the divide step is O(log n) because the subarray split is done evenly. The merge step takes O(n) time per level, making merge sort's average-case and worst-case time complexity O(n log n).

Description Notation Explanation
Worst case O(n log n) Every element is out of order.
Average case O(n log n) Some elements are out of order.
Best case O(n log n) All the elements in the first array are either smaller or larger than all the elements in the second array.
Note: Some implementations of merge sort can have a best-case time complexity of O(n).

*** 42.7 Quicksort

Quicksort
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to implement quicksort and give the runtime.

Overview
Like merge sort, quicksort takes a divide-and-conquer approach to sorting. Quicksort can sort an array in place, so in many circumstances it's faster than other common sorting algorithms.

Key Terms
Quicksort algorithm
Also called a partition exchange sort, an algorithm that works by partitioning an array into two parts, then sorting the parts independently
Understanding quicksort
The video below provides a brief introduction to quicksort. Start by watching the video, and then read through the rest of the lesson and complete the practice exercises. This will give you a thorough understanding of this topic.


Quicksort works by partitioning an array into two parts, then sorting the parts independently. It is one of the most efficient sorting algorithms, and it's based on splitting (partitioning) an array into smaller ones and swapping (exchanging) based on the pivot element selected. Because of this, quicksort is also called a partition exchange sort.

Here's the idea behind quicksort: for each pass through the array, the algorithm selects a pivot value and places the pivot into the correct location in the array. Specifically, the elements on the left side of the pivot are smaller than the pivot, and the elements on the right side of the pivot are larger than the pivot. Then the two sides are partitioned again and again until all elements are in the correct order.

In the partition phase, the algorithm compares each element to the pivot. If the value is greater than the pivot, it doesn't make any changes to the array. If the value is less than the pivot, the algorithm swaps the current element with the previous element that was greater than the pivot.

The partition function will have the following signature:

function partition (compare, elements, lowerIndex, upperIndex) {
...
}
compare is a function that returns a value greater than 0 if the pivot is greater than the current element by the ordering criterion.

elements is the array of data being sorted.

lowerIndex is the first index being sorted.

upperIndex is the last index being sorted.

Quicksort walk-through
The partition process can be challenging to understand from just a verbal summary. So to better understand the approach, take a look below at a more detailed example.

Given the array [50, 23, 9, 18, 61, 32], you will use quicksort to sort the array.

Visualization of quicksort process.
The first step is to pick a pivot. The pivot can be any element of the array, and it doesn't have to be the middle of the array. In fact, some partition algorithms select a random pivot. To keep things simple, here you will always select the last element in the array (32, in this case) as the pivot.

Next, partition the array on the basis of the pivot value. Partitioning rearranges the array in such a way that the pivot (32) eventually comes to its correct position of the sorted array. This means that any elements to the left of the pivot are less than the pivot, and any elements to the right are greater than the pivot. During this process, there is a partitionIndex variable that starts at lowerIndex. This variable is used to keep track of the index that will eventually be swapped with the pivot.

For the array given above, this process goes through the following steps:

Start from the first element and compare it with the pivot. Because 50 is greater than 32, you don't make any changes. Move on to the next element.

Compare the next element with the pivot. Because 23 is less than 32, you swap 50 and 23. Then increment partitionIndex by 1. The array becomes [23, 50, 9, 18, 61, 32].

Compare the next element with the pivot. 9 is again less than 32, so you swap 50 and 9. Then increment partitionIndex by 1. The array becomes [23, 9, 50, 18, 61, 32].

Compare the next element with the pivot. 18 is less than 32, so you swap 50 and 18. Then increment partitionIndex by 1. The array becomes [23, 9, 18, 50, 61, 32].

Compare the next element with the pivot. 61 is greater than 32, so there are no changes.

Next, swap the pivot elements[5] with elements[partitionIndex] (partitionIndex === 3) so that 32 is in the correct position. The array becomes [23, 9, 18, 32, 61, 50]. At this point, 32 is in the correct position in the array because all elements to the left of the pivot are less than 32, and all of the elements to the right are greater than 32.

Return partitionIndex (3) so that it can be used in the recursive calls. Here, index (3) can be ignored in future calls because it is in the correct position in the array.

Next, recursively call quickSort() with indexes 0 and partitionIndex - 1 and then partitionIndex+1 through 5.

Partition 0 through partitionIndex-1 (2). The new pivot is 18 because it is the element at index 2 in [23, 9, 18, 32, 61, 50].

Compare 18 to 23: 23 is greater than 18, so no changes are made.

Compare 18 to 9: 9 is smaller than 18, so 9 and 23 are swapped. The array becomes [9, 23, 18, 32, 61, 50]. Then increment partitionIndex by 1.

Next, swap the pivot elements[2] with elements[partitionIndex] (partitionIndex === 1). The array becomes [9, 18, 23, 32, 61, 50]. Now both 18 and 32 are in the correct position in the array, as are 9 and 23.

Partition partitionIndex+1 (4) through 5. The new pivot is 50 because it is the element at index 5 in [9, 18, 23, 32, 61, 50].

Compare 61 to 50: Because 61 is greater than 50, no change is made.

Next, swap the pivot elements[5] with elements[partitionIndex] (partitionIndex === 4). The array becomes [9, 18, 23, 32, 50, 61].

Quicksort in JavaScript
As with other algorithms, you will separate the comparison logic from the sorting algorithm. To accomplish this, the caller will supply a compare function that tells quicksort whether or not the pivot is greater than, less than, or equal to a given element.

Watch the following video for an overview of this topic. Then practice applying your new quicksort skills by completing the practice task below.


Do this
Implement quicksort
Now you will implement a quicksort algorithm as a higher-order function that takes the following two parameters:

compare: A function that compares two elements, so it takes two parameters: left and right. It returns one of the following:

0 if the left element is equal to the right element

A positive value if the left element is greater than the right element by the ordering criterion

A negative value if the left element is less than the right element by the ordering criterion

elements: The array to which the quicksort algorithm is applied.

Next, create a file named quickSort.js. In quickSort.js, add the following:

function quickSort(
  compare,
  elements = [],
  lowerIndex = 0,
  upperIndex = elements.length - 1
) {
  if (lowerIndex < upperIndex) {
    const index = partition(compare, elements, lowerIndex, upperIndex);
    quickSort(compare, elements, lowerIndex, index - 1);
    quickSort(compare, elements, index + 1, upperIndex);
  }
  return elements;
}

function partition(compare, elements, lowerIndex, upperIndex) {
  const pivotValue = elements[upperIndex];
  let partitionIndex = lowerIndex;

  for (let index = lowerIndex; index < upperIndex; index++) {
    const comparison = compare(pivotValue, elements[index]);

    if (comparison > 0) {
      if (partitionIndex !== index) {
        [elements[index], elements[partitionIndex]] = [
          elements[partitionIndex],
          elements[index],
        ];
      }
      partitionIndex++;
    }
  }

  [elements[partitionIndex], elements[upperIndex]] = [
    elements[upperIndex],
    elements[partitionIndex],
  ];
  return partitionIndex;
}

module.exports = quickSort;
The above quickSort() function starts by handling the recursive base case, which is when lowerIndex >= upperIndex. In this case, it just returns the array. Next, it calls partition() to update the array so that the first pivot is in the correct location and it returns the index of the pivot. Then, it recursively calls quickSort() with the indexes above and below the previous pivot index. This recursion continues until the base case is reached. Note that no new arrays are created, and only four variables are needed for additional storage.

Now, create a new file named useQuickSort.js. In useQuickSort.js, add the following code:

const sort = require("./quickSort");

function compare(left, right) {
  console.log("compare", left, right);
  return left - right;
}

console.log(sort(compare, [50, 23, 9, 18, 61, 32]));
Then run the code, using the command node useQuickSort.js. You'll see the following:

compare 32 50
compare 32 23
compare 32 9
compare 32 18
compare 32 61
compare 18 23
compare 18 9
compare 50 61
[ 9, 18, 23, 32, 50, 61 ]
As you can see in the output above, you can use the compare function passed into quickSort() to observe exactly what the algorithm is doing, without changing the code in quickSort(). This can be very helpful when debugging the sort algorithm.

In this case, quickSort() had to do eight comparisons to sort six numbers. In the worst case, the number of comparisons goes up exponentially to the number of elements in the array.

The efficiency of quicksort
Quicksort is very efficient at sorting smaller sets of data. But keep in mind that with very large datasets that won't fit in your computer's memory, merge sort works better than quicksort.

Quicksort's average-case and best-case time complexity is O(n log n). This occurs when the array is rearranged into two same-length subarrays in every partition step (similar to merge sort).

Description Notation Explanation
Worst case O(n²) The pivot element lies in an extreme end of the sorted array. One subarray is always empty, and another subarray contains n-1 elements.
Average case O(n log n) The depth of the recursion is O(log n). At each level, the partitions do O(n) operations. O(log n) times O(n) is equal to O(n log n)
Best case O(n log n) The pivot happens to be in the middle.
Note: Some implementations of quicksort can have a best-case time complexity of O(n).
*** 42.8 Comparison of sorting algorithms
Comparison of sorting algorithms
1.5 hoursEstimated completion time
Learning Objective
By the end of this lesson, you will be able to compare different sorting algorithms based on runtime, space complexity, and stability.

Overview
As you've learned in this module, sorting algorithms play an important role in data management. Often, the best course of action is to use the built-in sort function. But for situations when the built-in sort function is insufficient, there are a variety of specialized sorting algorithms to choose from. Each algorithm has its own advantages and disadvantages, and you should choose the sorting algorithm that is best suited for your particular context.

Key Terms
Runtime complexity
The algorithmic efficiency as the size of the input grows larger
Space complexity
The storage space that the algorithm requires
Stability
Whether or not a sort preserves the order of elements with equal values
Criteria for comparing sorting algorithms
When you're choosing which sorting algorithm to use, consider three main criteria: runtime complexity, space complexity, and stability.

Runtime complexity refers to the algorithmic efficiency as the size of the input grows larger. This usually depends on the number of elements to sort. You've learned about three common sorting algorithms in this module, and they all have a runtime complexity of either O(n²) or O(n log n).

Note: In this module, you learned about comparison sorts. However, not every sorting algorithm is based on comparing the items being sorted. There are even a few special-case noncomparison sort algorithms that can sort some datasets faster than O(n log n).

Even algorithms that have the same runtime complexity don't necessarily have the same speed for a particular input. It's important to consider the average-case, best-case, and worst-case efficiency for each algorithm. Some algorithms, such as quicksort, perform exceptionally well for some inputs, but are very slow for others. And other algorithms, such as merge sort, have the same runtime regardless of the input data's order.

Space complexity involves the storage space that the algorithm requires. Can the array be sorted in place, without requiring additional memory for more than a few variables, or does it need additional storage space? As you'll see, some algorithms never require extra space, but other algorithms are easier to understand when they're implemented with extra space.

Stability refers to whether or not the sort preserves the order of elements with equal values. Stability isn't an issue if all values are different; to check for stability, focus on elements with equal values. If these elements appear in the same order both in the sorted output and in the input array to be sorted, then the algorithm is stable. Most simple sorts are stable, but some sorts are not.

If you have an unstable sorting algorithm, you can make it stable by changing the comparison operation so that it considers position as a factor for two equal values.

Comparison chart
The following chart compares several sorting algorithms on the criteria outlined above. You can use this chart as a rough guide to help you pick between sorts of the same efficiency. Note that this chart lists more sorting algorithms than were covered in this module, but it isn't an exhaustive list of all existing sorting algorithms.

Sort
Average time
Best time
Worst time
Space
Stability
Remarks
Bubble
O(n²)
O(n)
O(n²)
Constant
Stable
Stops after reaching a sorted array.
Selection
O(n²)
O(n²)
O(n²)
Constant
Stable
Even a perfectly sorted input requires scanning the entire array.
Insertion
O(n²)
O(n)
O(n²)
Constant
Stable
In the best case (already sorted), every insert requires constant time.
Heap
O(n log n)
O(n log n)
O(n log n)
Constant
Not stable
By using an input array as storage for the heap, it is possible to achieve constant space.
Merge
O(n log n)
O(n log n)
O(n log n)
Depends
Stable
On arrays, merge sort requires O(n) space. But on linked lists, merge sort requires constant space.
Quick
O(n log n)
O(n log n)
O(n²)
Constant
Not stable
To avoid worst-case scenarios, it can help to pick a pivot value at random or shuffle the array before running the quicksort algorithm.
The ideal sorting algorithm would have the following properties:

Stable, meaning that elements with equal values aren't reordered.

Operates in place, requiring O(1) extra space

O(n log n) comparisons in the worst case

O(n) swaps in the worst case

Adaptive, with speeds up to O(n) when data is nearly sorted or when there are few unique values.

No algorithm has all of the above properties, so the choice of sorting algorithm depends heavily on the details of the application and the algorithm implementation. For example, asymptotic complexity analysis (big O) lets you distinguish between O(n²) and O(n log n) algorithms, but it doesn't help you distinguish between algorithms with the same asymptotic complexity. Asymptotic analysis also doesn't say anything about which algorithm is best for sorting small lists. For answers to these questions, you must test and compare the different algorithms using real application data.

*** 42.9 Assessment: Searching and sorting
** Module 43 - Data Structures
** Module 44 - Trees
* unsorted


Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly

different type data type
loop over objects
destructing
rest
scope
array method
arrows function
git, github


html boilerplate
