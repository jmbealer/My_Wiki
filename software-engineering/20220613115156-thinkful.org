:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]

these are my notes on the thinkful program
this is a staging area for my notes need to summarize and move to a better place

[[id:63bc8d8d-4fc8-4b34-8881-43ace1415a53][JavaScript]]
[[id:6df2c337-4b01-470f-9028-d0745498f8a6][devWorkflow]]
[[id:dea16eb4-d34a-421b-b037-9f3e606ec001][git]]
[[id:43e93100-42e8-432e-99bb-ecdd6f6b7097][devCollab]]
[[id:a3333ce5-86aa-4729-af16-cd8dafd42149][Node.js]]
[[id:c1cbc82c-ad99-4ae6-80a8-a9d83d2e71b8][careerNetworking]]
[[id:0b027db0-6cea-4c7a-81fa-05115bd10590][problemSolving]]
[[id:bc9d12ba-1f84-4599-9fe3-bcba0d2f5cb4][reactjs]]
[[id:d3374c8f-56bd-4dee-ad16-e9f4a8492999][swe-dsa]]

* Frontend development - Modules 18-29
** module 18 frontend foundations
*** 18.2 developer tools

Developer tools

In this lesson, you'll focus on the Chrome developer tools (sometimes referred to as DevTools).
However, many browsers have similar developer tools.

The developer tools offer several useful features, including the following:
+ The Element inspector, which allows you to inspect a particular element on the page
+ The Styles tab, which allows you to see which styles have been applied to a particular element
+ The Device toolbar, which allows you to see what your website will look like on various devices

Learning more

For now, the inspector will be your most valuable tool for working with HTML and CSS.
If you want to learn more about the developer tools (and especially Chrome's version), you can visit Google's Chrome DevTools page.
[[https://developers.google.com/web/tools/chrome-devtools][Google's Chrome DevTools]]

*** 18.3 intro to flexbox

Key Terms

Flexible box module
    Flexbox, a CSS module that provides a robust set of tools for developers to solve common layout problems

Introduction to flexbox


The flexible box module (or flexbox) provides a robust set of tools for developers to solve common layout problems, including the problem of building for various screen sizes.




Do this
Adding flexbox

.group {
  display: flex;
  flex-direction: row; /* or column */
}

Within the .group container, the default setting for displaying this container is block.
But to apply the flexbox properties to it, you should set the display property to flex.
This will tell the browser that all the items within this container should display as either a single row or a single column.

When you change the display property to flex, the default value for flex-direction is row.
If you run your code, you'll see that all three items now display within a single row.

Keeping flex-direction set as row is perfect for larger monitors.
And setting flex-direction to column is perfect for displaying the content on mobile devices.


Do this
Set the flex property
To change it so that all three items display with the same width, you can change the flex setting to 1, as shown here:

.item {
  flex: 1;
  margin: 10px;
}

The flex: 1 declaration tells the .group container that each item should be the same width, regardless of its content, and it will fill the container appropriately.

At this point, you should have three items within a group, and the items should display as equal in size.

Do this
Add margins

Set margin: 10px, as shown below. This margin is useful because it creates a little visual barrier between the .item containers. You can add or decrease this value to see what happens to the .item containers in the web page.

.item {
  margin: 10px;
}

Modifying the flex value

The flex: 1 value is currently telling the .item containers to all display at the same width.
You can change the ratio of these containers by changing the flex value to different values.

For example, you could create an additional .item-double class and set that flex value to 2.
When this is applied in addition to the .item class, the new container will display at double the size of the others within that group.

Do this
Create an .item-double class

Add the following .item-double class to your CSS file:

.item {
  flex: 1;
  margin: 10px;
}

.item-double {
  flex: 2;
}

Within the HTML, you can also create columns with different widths, as shown below. To do this, keep the original item class for all the same width elements and the margin. Then use item-double as a modifier style to override item with flex: 2 rather than creating a completely separate style.

The containers that have the item-double class will now display at twice the width of their sibling containers.

*** 18.4 intro to media queries
Overview

Media queries are a CSS feature that allows content to adapt to different screen sizes, such as mobile and desktop screens.
With a simple media query, you can easily modify a website's appearance on different devices.

Media queries

With a simple media query, you can quickly provide a responsive layout to nearly any standard website.


Media queries are essentially an if statement for CSS.
A condition is set, and if that condition is met, then the CSS rules within it will be applied.
Typically, media queries are used for changing the CSS of a website based on screen size.

The basic syntax for a media query is as follows:
@media <media type> (<media features>) {
  <CSS Rules>
}

Media types can be set to all, print, screen, or speech.
The all type, which is the most common type and the default in HTML5, applies the media query to every media type.
But if you want the styles within the media query to apply only when the web page is printed, you can use print instead.

The complete list of media features is long, but these are the most common ones:
+ width
+ height
+ orientation

Do this
Use media queries to adjust your paragraph's font size

In the style.css file, add the following rules:

p {
  font-size: 14px;
}

@media all and (min-width: 800px) {
  p {
    font-size: 24px;
  }
}

The code above is saying that the paragraph should generally display at 14 pixels in size.
The paragraph should only be displayed at 24 pixels when the browser has a width of 800 pixels or greater.

*** 18.5 mobile-first development
Overview
As you'll explore in this lesson, a mobile-first approach involves designing the mobile version of a website first, and then adapting the display to larger screens like a desktop.
When you follow a mobile-first approach, you start by building your website with your mobile users' experience in mind.

Key Terms

Graceful degradation
    A desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen
Progressive enhancement
    A mobile-first approach that involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes
Viewport
    The area of a browser's window in which web content can be seen

Mobile-first development


There are two approaches to media queries.

The more traditional approach is known as graceful degradation.
Graceful degradation is a desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen.
It's considered the old way of creating responsive websites.

The code below represents this traditional desktop-first approach; this kind of approach is built for desktop screens and then adapted for smaller screens.
This code assigns the background of a website shown on a desktop to be green.
However, if a screen's width is smaller—specifically, if the width is between 0 and 600 pixels—the code will assign the background to be red.

body {
  background-color: green;
}

/* This applies from 0px to 600px */
@media all and (max-width: 600px) {
  body {
    background-color: red;
  }
}

The newer and preferred method is known as progressive enhancement.
Progressive enhancement involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes.

As it turns out, progressive enhancement ensures that there is a good enough user experience on all screens.
Designing your pages to work on smaller screens first is the generally accepted approach to making web pages today.

The code below is targeting mobile-first design.
It assigns the background of the website to be red.
However, if a screen width has 600 or more pixels, like on a desktop computer, the code will assign the background to be green.

body {
  background-color: red;
}

/* This applies from 600px and larger */
@media all and (min-width: 600px) {
  body {
    background-color: green;
  }
}

Do this
Implement a mobile-first responsive flexbox

Before you add any media queries to your projects in these lessons, you should first make your project adhere to mobile-first design.

Adjust your screen width to below 800 pixels, to display the smaller screen view.
Notice that the items are arranged horizontally on the same row.
Ideally, they'd be stacked vertically on a small screen.

To do this, you just have to alter how .group classes display; change the flex-direction from row to column, as in the code below:

.group {
  display: flex;
  flex-direction: column;
  margin-bottom: 100px;
}

Now, you can add a media query after the .group and .item classes, like this:

/* Groups and items (Desktop) */

@media all and (min-width: 800px) {
  section,
  h1 {
    padding: 0 10%;
  }

  .group {
    flex-direction: row;
  }
}

Here's a breakdown of the syntax above:

+ The media query @media all and (min-width: 800px) is saying to only apply these CSS rules when the web browser is 800 pixels or larger.

+ When this condition is met, it adds a bit of padding to each <section> and <h1> element.

+ Then, it changes the flex-direction of each group; on larger browsers, the flex-direction becomes row instead of column. This displays the columns appropriately, as you can see in the image below of this code displaying on a larger browser.



Viewport

<meta name="viewport" content="width=device-width">

The viewport is the area of a browser's window in which web content can be seen.
Mobile devices usually render the page as if it were to be displayed on a larger screen, then shrink it to fit within the visible area.
However, if your page is already optimized to work with the small screen, this may cause a suboptimal experience.
The viewport meta tag was introduced to help with this problem; this tag lets you control the way that your pages are scaled when rendered by the browser.

For this meta tag to display the website properly on all devices, you need to add initial-scale=1.
When the initial scale is set to 1, it keeps the same zoom scale.
This presents the text much better as web pages change between vertical and horizontal views.

For any responsive web page, this entire tag is required:

<meta name="viewport" content="width=device-width, initial-scale=1">

Responsive images

Working with images inside responsive layouts can get a little complicated; it would be really difficult to track the changing .item container sizes and then update the image sizes appropriately.
Luckily, there is a very easy solution here: you can set all the image widths to be 100% using CSS, and the images will match whatever container width that they are placed within.

Do this
Adding images to group items

The files for this part of the lesson are stored in the responsive-images folder. Start by opening the index.html file with VSCode Live Server.

Notice that the images displayed in the browser are very large. So now, make them responsive.

Add the following code to the style.css file. Set the width of images to 100%, as follows:

img {
  width: 100%;
}

This code sample targets all the images within the .group container to display at 100%.
If you don't want to force the 100% resizing of every image, you can be more selective in how you target your images.

This code below, for example, will target only the images within the main container to be 100% in width.
Try it out in style.css by replacing the previous CSS code snippet with the following:

main img {
  width: 100%;
}

Because the img and main img selectors target the same images on the page, you won't actually see a visual difference between using img versus main img in this example.

But the four items that are pictures of the ocean aren't.
This is an example of why it is important to understand image size ratios.
When the images aren't the same height and width (in other words, when they have different ratios), they won't display properly.
To get these images to align properly, you need to crop them so that they all have the same ratio.
Images of different sizes that aren't aligned properly.

Most designers use graphical programs like Adobe Photoshop to edit images.
Luckily, there are also alternative apps online that make this process easy.
Of course, third-party tools available for free could disappear anytime.
But hopefully the tool shown below, [[https://www.birme.net/][BIRME]], can help if you find that you need to resize images for your own projects.

*** 18.6 deeper with flexbox

Key Terms

Main axis
    The row or column orientation established by the flex-direction property
Cross axis
    The axis perpendicular to the main axis


Flexbox properties

Certain properties are applied to the group (or parent), and other properties are applied to the items nested within the group (or children).

The following is a list of parent properties:

+ flex-direction
+ flex-wrap
+ justify-content
+ align-items
+ align-content

And here is a list of children properties:

+ order
+ flex-grow
+ flex-shrink
+ flex-basis
+ align-self

Group (parent) properties
The flex-direction property

The flex-direction property establishes the main axis, telling the items to display as either a horizontal row or vertical column.
There are also two other values, row-reverse and column-reverse, which reverse the display order of the items.
The following table summarizes the possible values for the flex-direction property.

Value Effect:
+ row :: Left to right (the default)
+ row-reverse :: Right to left
+ column :: Top to bottom
+ column-reverse :: Bottom to top

The flex-wrap property

By default, the items within a flex group container will display on a single line.
This can be changed to allow items to wrap as needed with the flex-wrap property, as described in the table below.

Value Effect:
+ nowrap :: All flex items will be on one line. This is the default.
+ wrap :: Flex items will wrap onto multiple lines from top to bottom.
+ wrap-reverse :: Flex items will wrap onto multiple lines from bottom to top.

The justify-content property

This is a useful property when there is available space around the items of the group.
That space can be distributed in various ways, as described in the table below.

Value Effect:
+ flex-start :: Items are packed toward the start of the flex direction. This is the default.
+ flex-end :: Items are packed toward the end of the flex direction.
+ center :: Items are packed centered along the line.
+ space-between :: Items are evenly distributed along the line; the first item is on the start line and the last item is on the end line.
+ space-around :: Items are evenly distributed, but have a half-size space on either end.
+ space-evenly :: Items and spacing are both evenly distributed.

The align-items property

This property is similar to the justify-content property, but it aligns items on the cross axis, which is perpendicular to the main axis that is used in the justify-content property
The following table summarizes the possible values for the align-items property:

Value Effect:
+ stretch :: Items are stretched along the cross axis to fill the container, but any defined minimum and maximum item widths are still respected. This is the default.
+ flex-start :: Items are placed at the start of the cross axis.
+ flex-end :: Items are placed at the end of the cross axis.
+ center :: Items are centered on the cross axis.
+ baseline :: Items are aligned along their baseline.

The align-content property

This property will apply only when there is more than one line of flex items.
When there is extra space in the cross axis, it will align the flex group on that axis (similar to how justify-content aligns individual items on the main axis).
The following table summarizes the possible values for the align-content property:

Value Effect:
stretch :: Items stretch along the cross axis to take up the remaining space. This is the default.
flex-start :: Items are packed to the start of the container's cross axis.
flex-end :: Items are packed to the end of the container's cross axis.
center :: Items are packed in the center of the container.
space-between :: Items are evenly distributed with the first line at the start and the last one at the end of the container.
space-around :: Items are evenly distributed with equal space around each line.
space-evenly :: Items are evenly distributed with equal space around them.

Item (child) properties
The order property
By default, flex items will display in the order they are added to the HTML page.
But with the order property, the items in the flex container can be adjusted.
This can be useful if you want the items ordered one way for mobile and another way for desktop.

The flex property
The flex property for items is actually shorthand for three properties:

+ flex-grow
+ flex-shrink
+ flex-basis

These properties are all tied to items, and it is recommended to use this shorthand property instead of setting the individual properties.
The default is 0 1 auto, which assigns flex-grow to 0, flex-shrink to 1, and flex-basis to auto.
But if you set the flex property with a single number value, like 1, the shorthand will use the single value to define the flex-grow property and will then set the other values appropriately.

The flex-grow property

The flex-grow property is quite useful.
By default, the value is set to 0.
If an item is set to 1, it will size all the items equally, so that they are all the same size.
If an item is set to 2, it will set the size of that item as twice as large as the other items.

The align-self property
This property lets the default alignment (or the one specified by align-items) be overridden for individual flex items.

Flexbox layouts

There are many great online resources that demonstrate different layout patterns using flexbox.
If you'd like to see some example flexbox layouts with CSS, visit [[https://tobiasahlin.com/blog/common-flexbox-patterns/][Common CSS Flexbox Layout Patterns with Example Code]].

Helpful games and resources

For practice using flexbox, you can play around with flexbox properties using the games and apps listed below.

    Flexbox Defense teaches flexbox via a casual strategic defense game.
http://www.flexboxdefense.com/
    Flexbox Froggy is a game that lets you practice writing CSS code.
http://flexboxfroggy.com/
    Flexy Boxes shows code samples and allows you to change parameters to help visualize how flexbox works.
https://the-echoplex.net/flexyboxes/
    Flexbox Patterns features many flexbox examples.
https://www.flexboxpatterns.com/
*** 18.7 navigation

Responsive navigation

**** Mobile-first approach


Now, you will learn how to build this CSS code piece by piece. You'll look at the CSS selectors that you need to target the various HTML elements, and you'll learn how to write declaration blocks that style each selected element to match the navigation shown in the image above.

For each selector, the HTML element that the CSS selector targets will be marked by a red border (border: 1px solid red;). This will help you visually connect the code with the element and the space that it occupies in each of the images below.
**** Do this

Make sure to keep the style.css file open in VS Code, as you will be adding CSS code to that file for the remainder of this lesson.
Style the header
Navigation with a styled header.

The header selector is the primary container to hold both the name of your page and its navigation.

Add the following CSS to style the header:

header {

  /* Sets background color to black. */

  background-color: #000;

  /* Adds 40 pixels of space under the header

     so that the main content isn't so close

     to the navigation. */

  margin-bottom: 40px;

}

**** Do this
Style the title of your document
Navigation with a styled title.

The header h1 selector targets the title of your document. Adding a unique font will give this text more style, too.

Add the following CSS to style the title of your document:

header h1 {

  /* Sets text color to white. */

  color: #fff;

  /* Centers the text. */

  text-align: center;

  /* Removes the default margin and spacing around the `h1` element. */

  margin: 0;

  /* Pushes the text down 20 pixels from the top of the page. */

  padding-top: 20px;

}

**** Do this
Style the container for the navigation
Navigation in a styled container.

The header nav selector targets the container for the navigation. Targeting only the nav container that's within the header allows for other navigation containers to be styled differently in the footer or elsewhere on the page.

Add the following CSS to style the container for the navigation:

header nav {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /* Centers an element defined as `display: flex`. */

  justify-content: center;

}

**** Do this
Style the unordered list
Navigation in a styled unordered list.

This header nav ul selector targets the unordered list that is within the header's nav container.

Add the following CSS to style the unordered list:

header nav ul {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /*

    You want the navigation to display in a single row. This is

    the default value for `display: flex`, so you don't need

    to define its `flex-direction` in this case.

  */


  /*

    Removes the default padding to the left of the

    unordered list.

  */

  padding-left: 0;


  /*

    Removes the bullet points from the list items within the

    unordered list.

  */

  list-style: none;

}

**** Do this
Style the anchor tags of the list items
Styled anchor tags of the list items.

The header nav ul li a selector targets the anchor tag (link) of the list items within the unordered list that is within the header's nav container.

Add the following CSS to style the anchor tags:

header nav ul li a {

  /* The link color is white. */

  color: #fff;

  /* Removes the underline from the link. */

  text-decoration: none;

  /* Applies 20 pixels of margin to the right of each link

     creating a visual gap between the navigation links. */

  margin: 0 20px 0 0;

}

**** Do this
Style the last list item's anchor
Last list item of the navigation is styled.

The header nav ul li:last-child a selector targets the last list item's contained anchor (link).

Add the following CSS to style the last list item's anchor tag:

header nav ul li:last-child a {

  /* Removes the margin to the right of the last anchor tag

     so that the nav appears centered. */

  margin-right: 0;

}

Great job on making it this far in the lesson! So far, you've created a navigation bar for the mobile view using flexbox. Next, you will add a media query for the desktop view.
**** Media query for desktop

As mentioned earlier, the code that you've worked through so far was designed to be viewed on mobile devices. To tell the browser how to change the header, title, and navigation when viewed on a desktop, you need to add a media query for desktop.
**** Do this
Add a media query

Add the following media query for desktop:

/* When a web browser is larger than 600 pixels,

   apply these rules. */

@media all and (min-width: 600px) {

  header {

    /* Changes the default setting from `block` to `flex`. */

    display: flex;

    /* Pushes the items (the title and nav) to the far sides of the

       browser with space between them. */

    justify-content: space-between;

    /* Adds 0 pixels padding top and bottom, and 30 pixels padding

       left and right. */

    padding: 0 30px;

  }


  header h1 {

    /* Sets 14 pixels of margin above and below the `h1` and sets

        0 pixels of margin to the left and right. */

    margin: 14px 0;

    /* Removes or sets 0 pixels of padding above the `h1`. */

    padding-top: 0;

  }


  header nav {

    /*

      Pushes the navigation container down by 8 pixels to make it

      present a little better visually within the space.

    */

    margin-top: 8px;

  }

  /* Users cannot hover on mobile devices, so that is why you

     implement this behavior only for larger screens. */

  header nav ul li a:hover {

    /* Targets the change when a user holds the pointer over the anchor tag

       (link) within the list items within the unordered list that

       is within the navigation that is within the header. */

    color: #bdbdbd;

  }

}

At this point, your navigation bar will be fully responsive. Try it out in the browser.
**** Linking navigation

There are different navigation rules depending on if you are creating a single-page website or a multipage website.
**** Single-page navigation

When you create a single-page website, you'll add anchor IDs to the sections or other primary containers in your page. Don't forget to add the hash symbol # in the link; this will tell the link to look for the anchor ID somewhere on the page and jump to it when clicked. The navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="#home">Home</a></li>

      <li><a href="#about">About</a></li>

      <li><a href="#portfolio">Portfolio</a></li>

      <li><a href="#contact">Contact</a></li>

    </ul>

  </nav>

</header>

<main>

  <section id="home">

    <!-- All the Home section can be placed here. -->

  </section>

  <section id="about">

    <!-- All the About section can be placed here. -->

  </section>

  <section id="portfolio">

    <!-- All the Portfolio section can be placed here. -->

  </section>

  <section id="contact">

    <!-- All the Contact section can be placed here. -->

  </section>

</main>

**** Multi-page navigation

When you're linking to other pages that are all within the same directory, the navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="/">Home</a></li>

      <li><a href="about.html">About</a></li>

      <li><a href="portfolio.html">Portfolio</a></li>

      <li><a href="contact.html">Contact</a></li>

    </ul>

  </nav>

</header>

Tip

Websites usually set the home page link to the public root ("/"). This is because index.html is the default file in that directory, so it hides the /index.html filename from displaying in the browser address.
*** 18.8 html forms

**** Introduction to forms
HTML forms are very useful for web users. Below are just a few examples of what they can be used for:

Sending an email through a web page

Submitting purchase order information

Completing survey questions

Collecting user registration

Here are three examples of websites that make very good use of HTML forms:

First example of a website that makes good use of HTML forms.
Image source: HotJar's registration page

HotJar uses the HTML form to collect the user's full name and email address so that they can create a free basic account.

Second example of a website that makes good use of HTML forms.
Image source: Omada's contact page

Omada uses the HTML form in three different ways: asking if the customer has a Sales Inquiry, needs User Support, or wants Something Else. This way, Omada can tailor the input fields for the HTML form to collect the data that is most useful for their team.

Third example of a website that makes good use of HTML forms.
Image source: YummyGum's contact page

YummyGum uses HTML forms in a method that's similar to Omada's usage of forms. This page filters the user through four radio buttons, and then delivers tailored input fields for each topic.

**** HTML form basics
To create an HTML form, you can begin in one of these two ways:

<form action="process-form.js" method="post">
  <!-- Add the HTML input elements here -->
</form>

<form action="baseball-stats.js" method="get">
  <!-- Add the HTML input elements here -->
</form>
The <form> element does not have any visual design by default—but of course, you can still apply a background color or a border using CSS.

Within each <form> element are two attributes: an action and a method.

action: This attribute holds the URL to the server-side file where the data will be sent.

method: This attribute specifies the HTTP method—post or get—that will be used with the action.

post: This method can involve anything from storing or updating data, ordering a product, or sending an email.

get: Put simply, this method is used to retrieve data to display in the form.

There are various kinds of form fields that you can add to a form, including, but not limited to:

Text fields

Text areas

Radio buttons

Checkboxes

Drop-down list

Submit and reset

Fieldset and legend

Password field

You'll explore these commonly used form fields next.

**** Text fields
First name text field.
<form>
  <label for="name">First name:</label>
  <input id="name" type="text" name="name" />
</form>
The example above has two HTML elements: a label and an input.

The label tells users what information needs to go in a text field. It's connected to the input element with the for attribute as it links to the input's id.

The label is also important for accessibility. Assistive technologies such as screen readers use the label to tell the user what text should go in the text field. The label also makes it easier for users to interact with the text field by providing a larger hit area to click or touch.

The input has three attributes:

id: The id attribute gives the element a unique name so that the label knows how to connect with it.

type: The type attribute determines what type of control to render (for example, whether the user clicks a radio button, checks a checkbox, or enters text). For a text field, the type is set to text, which creates a single line of input text.

name: The name attribute is used to identify the input field when the entire form is submitted to a server.

**** Text field options
There are three additional attributes that can be used to style the text field.

autofocus: on: The autofocus attribute will set the first input to autofocus to help draw the user's attention to it. You only want this once on your page.

required: The required attribute will tell the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters added to the text field.

Here's an example of these attributes in use:

Attributes for text field styling
<form>
  <label for="location">Zipcode:</label>
  <input
    id="location"
    type="text"
    name="zipcode"
    autofocus="on"
    maxlength="5"
    required
  />
</form>
**** Do this
Add text fields to your form
In index.html, add the following code to create text fields to collect the user's name and zipcode:

<form>
  <div>
    <label for="name">Full Name:</label>
    <input id="name" type="text" name="name" />
  </div>
  <div>
    <label for="location">Zipcode:</label>
    <input
      id="location"
      type="text"
      name="zipcode"
      autofocus="on"
      maxlength="5"
      required
    />
  </div>
</form>
**** Text areas
Text area fields present the user with a multi-line input field so that they can enter an unlimited number of characters. These are best used for collecting a longer message. Here's what these fields look like:

Text area field example
As you can see in the code below, this HTML element has its own label.

<form>
  <label for="form-message">Your message:</label>
  <textarea id="form-message" name="message"></textarea>
</form>
These are the attributes that can change the way that the text area looks and works:

cols: Sets the visible width of a text area in character spaces. But it's better to use the width attribute in CSS.

rows: Sets the visible number of lines in a text area in character spaces. But it's better to use the height attribute in CSS.

autofocus: on: The autofocus attribute sets the first input to autofocus to help draw the user's attention to it. Remember, you only want this once on your page.

required: The required attribute tells the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters that can be added to the text field.

**** Do this
Add text areas to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
    ></textarea>
  </div>
</form>
This form states that it is a multi-line text field that will store the data within the name message. The autofocus is set to on, the field is required, and only 200 characters can be entered.

**** Fieldset and legend
The <fieldset> element is used to group together related inputs and labels. This will help web crawlers and screen readers, even if there is no visual representation here. The <legend> element is like a title for the <fieldset>.

Here's what these elements look like:

Related elements grouped by fieldset.
**** Do this
Add a fieldset and legend to your form
In the index.html file, group your name and location input fields within a set of fieldset tags, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input id="name" type="text" name="name" />
    </div>
    <div>
      <label for="location">Zipcode:</label>
      <input
        id="location"
        type="text"
        name="zipcode"
        autofocus="on"
        maxlength="5"
        required
      />
    </div>
  </fieldset>
  ...
</form>
Notice how the <fieldset> element is used to group the shipping information (i.e., name and location) together.

**** Placeholder text
The text field and text area field can both use the placeholder attribute to briefly describe the information that is expected in the field. This should just hint at what should be inputted rather than providing a full explanation; it's best to use a simple word or short phrase that demonstrates the expected type of data. The placeholder text cannot include carriage returns or line feeds.

Keep in mind that for accessibility and usability reasons, labels shouldn't be replaced by placeholders. Placeholder text disappears when the user types in the field, so if the user forgets what the form field is expecting as an input, the user would have to delete what they wrote to reveal the placeholder text again. Moreover, some screen readers may not even read placeholder text aloud.

Also, make sure that the placeholders you use have the appropriate CSS styling so that it is easy to read for your users.

Placeholder text examples.
**** Do this
Add placeholder text to the name and message fields
Add the placeholder attribute to your name and form-message fields, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input
        id="name"
        type="text"
        name="name"
        placeholder="Enter your full name"
      />
    </div>
    ...
  </fieldset>
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
      placeholder="How can I help you?"
    ></textarea>
  </div>
  ...
</form>
**** Password field
As you build more complicated forms, there may be times when you want to mask sensitive input fields by using the password field.

Password field.
Review the code below to get an idea of how the HTML works.

<div>
  <label for="password">Password:</label>
  <input id="password" type="password" name="password" minlength="8" />
</div>
The attribute minlength can be used to force the entry to be at least eight characters in length.

**** Do this
Add a password field to your form
In the index.html file, add the following password field to your form:

<form>
  ...
  <div>
    <label for="password">Password:</label>
    <input id="password" type="password" name="password" minlength="8" />
  </div>
</form>
Type into the password field and observe how the characters you type are hidden.

**** Radio buttons
Radio buttons allow the web user to select only one of the limited number of choices available. They look like this:

Radio buttons for colors.
To create a radio button, you'd have to set the type attribute of an input tag to "radio", as follows:

<input id="red" name="color" type="radio" value="red" />
The new attribute here is the value. The value is important because that is the data for the one selected item that will be submitted with the form data.

**** Do this
Add radio buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Favorite Color:</h2>
    <div>
      <input id="red" name="color" type="radio" value="red" />
      <label for="red">Red</label>
    </div>
    <div>
      <input id="blue" name="color" type="radio" value="blue" />
      <label for="blue">Blue</label>
    </div>
    <div>
      <input id="white" name="color" type="radio" value="white" />
      <label for="white">White</label>
    </div>
  </div>
</form>
There is no necessary order for the radio button's parameters, so you can place the input, name, and value in any order that you wish. When you click on the text of the radio button, the color is selected. That's because of the for attribute and how it matches up with the ID of the <input> element.

**** Checkboxes
Checkboxes allow the user to select one or more options from the number of choices available. They look something like this:

Check boxes for monster features.
To create a checkbox, you'd have to set the type attribute of an input tag to "checkbox", as follows:

<input name="scales" type="checkbox" id="scales" />
**** Do this
Add checkboxes to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Choose your monster's features:</h2>
    <div>
      <input name="scales" type="checkbox" id="scales" />
      <label for="scales">Scales</label>
    </div>
    <div>
      <input name="horns" type="checkbox" id="horns" />
      <label for="horns">Horns</label>
    </div>
    <div>
      <input name="wings" type="checkbox" id="wings" />
      <label for="wings">Wings</label>
    </div>
  </div>
</form>
**** Drop-down list
A drop-down list, also called a select menu list, is a toggleable menu that allows the user to choose one value from a predefined list. It tends to be more user friendly than a list of radio buttons when there is a long list of items. Drop-down lists look something like this:

Drop-down list for fonts.
To create a drop-down list, you'd have to use the <select> tag in conjunction with <option> tags. The <select> tag accepts the following attributes:

size: This sets the display of the drop-down menu to show a specified number of items. For example, if you wanted to show a list with 4 items out of 10, you'd set the size to 4 (size="4").

multiple: This option allows for the user to choose multiple sections in the drop-down menu.

**** Do this
Add a drop-down list to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="fonts">Choose a font:</label>
    <select name="fonts" id="fonts" size="1">
      <option value="arial">Arial</option>
      <option value="times">Times New Roman</option>
      <option value="comicsans">Comic Sans</option>
      <option value="papyrus">Papyrus</option>
    </select>
  </div>
</form>
In the above code, size="1" sets the display of the drop-down menu to show a single item, with the first of the list by default. Unlike all of the other inputs, it isn't recommended to try to update the style of an HTML drop-down menu using CSS. As you learn more about JS, you'll be able to create a clickable drop-down menu without using this input at all.

**** Submit and reset
Buttons are similar to links, but they are really important to have in forms. Whereas a link is used to navigate the user to a new page or resource, a button toggles something in the interface—which makes buttons perfect for submitting or resetting the data in a form. Buttons look something like this:

Submit and Reset buttons.
There are three types of buttons:

submit: Submit buttons send the data in the form to the backend program that collects the data.

reset: Reset buttons clear all of the data that has been changed in the existing form elements.

button: Buttons with type="button" have no default behavior. They are often used to trigger client-side functions or scripts that listen to the element's events.

**** Do this
Add Submit and Reset buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <button type="submit">Submit</button>
  <button type="reset">Reset</button>
</form>
Notice that the default presentation of a button looks very different compared to a link. A link may display as blue text with an underline, whereas a button is a rounded rectangle around the text.

Buttons have many uses beyond forms once you start working with JavaScript, but when you're only working with HTML and CSS, their use is usually limited to simple form controls.

**** Patterns
The pattern attribute is used to supply patterns that the user's input must match in order to be valid. A complete list of useful patterns can be found at HTML5Pattern.

For example, the pattern "\d{3}[\-]\d{3}[\-]\d{4}" will warn the user if they are not providing a correct 10-digit phone number in the xxx-xxx-xxxx format. The visual error that appears is a default with the browser.

**** Do this
Validate the phone number
Add the following phone input field, right above the Submit and Reset buttons:

<form>
  ...
  <div>
    <label for="phone">Phone #:</label>
    <input
      id="phone"
      type="text"
      name="phone"
      pattern="\d{3}[\-]\d{3}[\-]\d{4}"
      placeholder="xxx-xxx-xxxx"
    />
  </div>
  ...
</form>
An error message "Please match the requested format" will display if the phone number format is wrong when you press the Submit button.

**** More input types
There are many more input types that you can use in a form. You can find additional ones at MDN: Input Types.

** module 19 css frameworks
*** 19.1 overview: css frameworks

Key Terms
CSS framework
A library of various web design components that can be applied to multiple projects

To help with this complexity, some designers have created CSS frameworks.
A CSS framework provides various components that you can plug in to your website and thoroughly customize.
CSS frameworks can increase your productivity and help you design a clean-looking website, even if you're not a great designer yourself.

*** 19.2 using a framework

Key Terms
Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly
Spaghetti code
A pejorative term used for program code written without a coherent structure

**** What is a framework?
You'll often hear about CSS frameworks, but the concept of a framework actually appears across the technology stack. A framework, when applied to any language, typically refers to reusable code that provides an opinionated solution to common problems. For example, a CSS framework typically provides prestyled elements and requires that you use certain elements or classes to design your website. In short, a CSS framework is CSS that someone else wrote to help you make incredible websites.

In exchange for following a preset pattern, you gain a number of benefits from the imported code. CSS frameworks vary immensely, but almost all of them allow you to achieve some things much more quickly and easily than would be possible if you were to write all of your own CSS.

These are some time-saving functionalities that are common across most CSS frameworks:

Organizing the layout of your page

Building responsive websites

Maintaining consistency across your pages

In exchange for these benefits, you often have to do the following tasks when using CSS frameworks:

Use certain elements or class names

Organize and nest your elements in a particular way

Include external stylesheets and potentially external JavaScript

**** Examples
The most popular CSS framework by far is Twitter Bootstrap. With robust documentation and plenty of support from one of the largest tech companies, Twitter Bootstrap has come to define CSS frameworks.

In large part, this is because Bootstrap looks both simple and clean.

Screenshot of the Bootstrap home page, reading "Build fast, responsive sites with Bootstrap."
There are also other popular CSS frameworks, a few of which are listed below. Note that although each of these frameworks can differ, they have more similarities than differences.

Pure.css

Materialize CSS

Bulma

**** Customization
CSS frameworks typically provide a few CSS files to include as part of your project. But this doesn't mean that you can't write your own CSS to go on top of it!

In fact, many websites start with a CSS framework as a base, and then design on top of it. For example, all of the websites showcased on Bootstrap Expo make use of Bootstrap—and yet each one looks very different. If you're interested, take a moment to scroll through Bootstrap Expo and get an idea of what's possible with Bootstrap.

With that said, just adding CSS on top of existing CSS can lead to confusing code. It's important to be thoughtful when adding to or modifying existing CSS—and this is particularly crucial if you're working on a large project.

**** Problems
CSS frameworks can be powerful tools, but they don't come without their own problems and detractors. Here are some of the biggest complaints about CSS frameworks:

CSS frameworks can lead to what is known as spaghetti code. This occurs when developers don't understand how the CSS code they are adding to works but continue to add more and more CSS elements, making the code even more difficult to understand.

CSS frameworks often rely on <div> elements and other non-semantic elements, making pages less accessible to certain types of users.

CSS frameworks can lead to websites looking too similar to each other. When you get familiar with Bootstrap, you'll start to notice lots of websites that use Bootstrap.

As with any tool, using a CSS framework should be a conscious and active choice that you're making. You'll make use of CSS frameworks in this module, but keep in mind that a CSS framework won't always be the best decision.

**** How to add a CSS framework
Installing and getting started with using a CSS framework is quite simple; many frameworks make it as easy as possible to begin using them.

There are a few ways to include a CSS framework, depending on your setup. However, the most common method is to include a link to a file hosted on a content delivery network (CDN). A CDN is a distributed group of servers used to host files for the web. CDNs make it efficient for many people to access the same file at the same time.

To link to a CDN, you essentially add a stylesheet that has an external URL as its href value. You can usually find a framework's CDN link early on in its documentation.

**** Do this
View your index.html file
Before you add Bootstrap, use your browser to open your existing index.html file. Take notice of the style and formatting, even though there's only an <h1> element.

**** Use Bootstrap on your page
Your page will look something like the image shown below:

Your index.html page before adding bootstrap
To add Bootstrap to your page, visit Bootstrap's website and scroll down to the jsDelivr section shown in the image below.

A screenshot of the jsDelivr section on the installation page
Copy the <link> element that's referenced in that section, and add it to the <head> of your index.html page. For now, ignore any requirements to include <script> tags.

Tip
You don't need to run npm install or anything from your command line. Make sure that you look for the CDN instructions.

When you refresh your page, you will notice that the style is slightly different. You're now using Bootstrap on your page!

The index.html page after using Bootstrap

*** 19.3 grids



Key Terms
Grid
A structural system of horizontal and vertical gridlines that helps ensure that your website is well-aligned and quickly scalable
Responsive
The property of allowing a layout to change dynamically based on the size of the screen
Mobile-first
A layout where the default configuration is for narrow screen and mobile devices
CSS container
The most basic conceptual element in most frameworks, used to encapsulate and pad the rest of the page

**** The grid system
Many websites are organized in very similar ways. The existence of headers, footers, and sidebars showcases that when it comes to the design of many web pages, developers and designers rely on certain elements to convey their sites' messages.

One way that CSS frameworks make this easier is by providing a grid. A grid allows you to easily organize your website so that it is well aligned and quickly scalable. Modern CSS frameworks also include classes that make it easier to build responsive grids, making the transition from mobile to desktop seamless.

A grid in most CSS frameworks is separated into columns and rows. It's standard for most CSS grid frameworks to have 12 columns and any number of rows.

An example of a grid in CSS
In the above example, you can see 12 columns marked in dark gray. Each colored section generally represents a horizontal row.

In terms of the grid system, the following statements are true of the above image:

The header is the first row on the page. It spans all 12 columns.

The nav spans three columns, in contrast to the container that is wrapping both the content and the footer. The nav also goes across two different rows.

Both the content and the footer are included together in their own container. They span nine columns. The content and footer are each in their own separate row.

Most websites fit into this kind of structure that prioritizes containers, rows, and columns. In the following sections, you'll learn more about these concepts and how they apply to Bootstrap.

**** Do this
Grid your view
Take a look at the page on which you're currently reading this lesson. Can you visualize it as a grid? Take a moment to think about how many columns each part of the page might be, as well as how many distinct rows you see on the page.

**** Containers
A CSS container is the most basic conceptual element in most frameworks. CSS containers are used to encapsulate and pad the rest of your page. CSS containers aren't usually nested inside of each other.

If you use the grid system from Bootstrap, you will need at least one container on your page.

To make an element into a container, you simply need to add a class of .container to it. Any element can be a container, but it's most typical for the .container class to be added to a <main> or <section> element.

<main class="container">
  <!-- ... -->
</main>
**** Do this
Use a container
The best way to see what a container does is to use one. Replace your <body> code with the following code:

<body class="container">
  <h1>Hello, there!</h1>
</body>
Refresh your page to see the difference. Do you see how there's now padding to the left of the heading? This padding is provided by the container.

**** Rows and columns
Rows wrap around any elements that are grouped horizontally on the page. Rows must be inside of a container element.

As you might expect, rows use the .row class, and columns generally use the .col class.

Each row contains a number of columns. Bootstrap allows for a lot of variety in how columns are used, but columns must be inside of a <div> with a .row class element.

Take a look at the Replit below, which shows a single row with a single column in a single container.


In general, there isn't much that is remarkable about this code. But you should notice that several wrapping <div> elements are needed to make use of rows and columns.

Now, take a look at the Replit below. It makes use of two columns, and each column is outlined in a different color. If the screen is too small, try opening this Replit in its own tab.


As you might have noticed, the above Replit has two columns of equal width taking up the page. You can continue to add more columns next to each other, and each one will take up a similar width. That's because rows and columns make use of flexbox.

**** Do this
Include rows and columns
Replace your <body> element with the following code:

<body class="container">
  <div class="row"></div>
</body>
Then, add three columns inside of the .row. Add a paragraph with some text to each, so that you can see the separation.

Below, you can see a potential solution to this challenge.

<body class="container">
  <div class="row">
    <div class="col">
      <p>
        Bears are mammals that belong to the family Ursidae. They can be as
        small as four feet long and about 60 pounds (the sun bear) to as big as
        eight feet long and more than a thousand pounds (the polar bear).
      </p>
    </div>
    <div class="col">
      <p>
        They're found throughout North America, South America, Europe, and Asia.
      </p>
    </div>
    <div class="col">
      <p>
        They have nonretractable claws, short tails, and excellent sense of
        smell. They're typically solitary, except for mothers with cubs.
      </p>
    </div>
  </div>
</body>
**** Varied column sizes
In the documentation, you might have noticed .col classes with additional text next to them. When a number follows a column, as in .col-4, it defines the size of the column. Recall that the grid system is typically based on 12 columns. The .col-4 class means that the selected element will take up 4 out of the 12 columns. Any columns with a .col class will equally share the rest of the space.

In the following Replit, the first column is set to .col-9.


As you can see, this first column takes up more space than the remaining column.

**** Responsiveness
Similarly, it's possible to make your columns and rows responsive. Bootstrap is developed to be mobile-first, which means that it's assumed that users will be viewing your site on mobile.

Bootstrap has a feature that you can use to make the column sizes adapt to different screen sizes. There are four different sizing terms that you can add to your columns:

sm: For small devices and landscape phones

md: For tablets and smaller computers

lg: For desktop computers

xl: For large monitors

More information about the exact breakpoints can be found at Bootstrap's documentation on responsive breakpoints.

Here's an example:

<body class="container">
  <div class="row">
    <div class="col col-lg-8">
      <p>col col-lg-8</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
  </div>
</body>
In the example above, on large screens, the left column (.col-lg-8), will take up most of the space. As the screen size decreases, all of the columns will eventually end up being the same size.

**** Do this
Add responsive classes
Add responsive classes to your current work. Use a mix of lg and md classes and test out the difference.

**** Using the documentation
This lesson won't cover every single aspect of the grid system. Instead, you can explore the Bootstrap documentation. The bootstrap documentation is excellent and gives many examples.

For example, Grid: Setting one column width, which is part of Bootstrap's grid documentation, lays out information on varied column widths.

And Grid: Responsive classes describes how rows and columns can be set to be responsive.

You don't need to memorize everything on the Bootstrap website. Instead, rely on it as a tool for learning and solving problems.

*** 19.4 common components and utilities

**** What else can Bootstrap do?
CSS frameworks gained popularity through the grid system, but many of these frameworks now also include common components and utility classes that you can add to your website. This makes it easy to quickly add common styling. In the following sections, you'll learn about some of the most common components and classes. Wherever possible, links to the appropriate documentation will be included.

**** Common components
There are too many components to cover here, and many of them have already been described on the Bootstrap website. For demonstrations of available components, visit Bootstrap's page on components.

Below is a list of some of the most common components:

Alerts

Buttons

Card

Forms

Jumbotron

Navs

You can use these components in Bootstrap and other frameworks.

Some components require supporting JavaScript files to use. Although you can use these components, it's suggested that you actually avoid them until you've learned more about using JavaScript with HTML and CSS.

The components described above require the use of certain classes and structures to make them work. Note that the majority of these are intended to be used inside of a container, row, or column.

**** Do this
Include common components
Add a styled button to your page. To keep things organized, make sure that it appears inside of a .col class. Try changing the color and size using the various classes described.

Next, add a card to your page. Try placing it inside a column and adding or removing elements.

**** Borders and colors
There are a few classes in Bootstrap that allow you to add borders and colors to your containing elements. These are easy to use and can be useful for quickly adding a bit of style to your code.

You can explore the documentation using the links below:

Bootstrap: Borders
Bootstrap: Colors
**** Do this
Use borders and colors
Use the .border border-primary class, the .text-danger class, and the .bg-dark class on your page.

**** Text
Bootstrap allows utility classes that you can use to modify text in a variety of ways.

You can explore the documentation here:

Bootstrap: Text
Perhaps the most useful text-modification classes are those that allow you to align your text quickly, like .text-center.

**** Do this
Align your text
Use the .text-center class on your index.html page. Notice from the documentation that this class also allows for responsive text!

**** Spacing
Bootstrap also provides a few utility classes that make it easy to add margins or padding to elements. These rely on a lot of abbreviations, so you'll need to read the documentation carefully.

You can explore the documentation here:

Bootstrap: Spacing
**** Do this
Add margin and padding
Try using the .py-2 class and .mb-4 class. What does each abbreviation represent?

**** Flex
It's important to know that Bootstrap can't solve every layout problem with rows and columns. Some layout problems require a more nuanced solution.

Bootstrap provides some utility classes that allow you to apply CSS rules to individual elements. For example, there are a few classes that just apply flexbox rules to elements.

You can explore the documentation here:

Bootstrap: Flex
Note that using these classes can conflict with rows and columns. That doesn't mean that you can't use them together; just be wary of overlapping styles!

** module 20 javascript and the DOM
*** 20.2

Key Terms
Document Object Model
DOM, the data representation of the HTML elements that make up the structure of a web page, serving as a way for JavaScript to understand the structure of an HTML page in order to make it dynamic
Child element
An element that's nested inside another element
Parent element
An element that has one or more elements nested inside it

**** Why use JavaScript?
JavaScript was originally designed to work with HTML on a web page. When applied to a web page, JavaScript is used to add some interactivity or to make the page more dynamic. You may have seen websites that use JavaScript to do the following:

Create animations

Respond to actions that the user performs

Validate user input on forms

Load data dynamically

**** The <script> tag
To include some JavaScript on a page, add an HTML <script> tag to the bottom of the <body> element. The <script> tag takes an attribute named src; this attribute specifies the JavaScript file to be included. Here's an example:

<script src="/path/to/your/script.js"></script>
If your browser happens across a <script> tag when it's rendering a requested web page, it will request the file and execute it immediately.

**** Do this
Create two files
On your machine, create a new folder for a new project. In that folder, create two files named index.html and index.js. The index.html file is a simple HTML page with a <script> tag referencing index.js. Copy the following code into the respective files.

Here's the code for the index.html file:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <h1>Welcome to my website</h1>
    <script src="index.js"></script>
  </body>
</html>
And here's the code for the index.js file:

console.log("Hello!");
Once you've added the code to both files, open the HTML page in your browser and observe the console in the developer tools. Notice that the JavaScript code is executed as the page loads.

**** Embedding JavaScript
In addition to linking to an external file, you can include JavaScript directly on the HTML page within the <script> tags. Here's an example:

<script>
  console.log("This is embedded JavaScript");
</script>
But generally, it's best to avoid embedding JavaScript in an HTML page like this; it isn't a very scalable solution.

**** Do this
Add some <script> tags
Add a few <script> tags to the HTML page from above, and open it in the browser. Each set of tags may simply log some text. Notice that each <script> tag is executed in turn as the page loads.

Tip
The <script> tags should be added to the bottom of the <body> element.

**** The <noscript> tag
What happens if one of your users cannot run your script? You still want that user to have a good experience on your website. Some users deliberately turn off scripts or may be unable to run scripts for a number of reasons. At the very least, you should show these users a message indicating that the website depends on scripts. To do so, use the <noscript> tag, like this:

<noscript>This site requires JavaScript.</noscript>
To see this in action, you will need to temporarily disable JavaScript in your browser.

**** Do this
Add <noscript> to page
Add the <noscript> tags (as shown above) to the HTML page. Then reload the page in the browser.

**** Disable JavaScript
Open the Chrome DevTools console by pressing Control+Shift+J (or Command+Option+J on a Mac). Then press Control+Shift+P (or Command+Shift+P on a Mac) to open the command palette.

The Chrome DevTools console
Type javascript to filter the commands to show only those that relate to JavaScript.

Type javascript to filter the commands
Click the Disable JavaScript option, and JavaScript will be disabled in your browser. Try reloading the page, and observe that the <noscript> tag kicks in now that JavaScript isn't available.

**** Document Object Model
When your web page is loaded by the browser, it is parsed, and the browser constructs an internal representation of the HTML. This facilitates the browser's interaction with the HTML. You can also use JavaScript to interact with the HTML via this internal representation. This representation, which is called the Document Object Model (DOM), is the data representation of the HTML elements that make up the structure of a web page. The DOM is how the browser sees your HTML.

Consider the following simple HTML file:

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <header>
      <h1>List of Parks</h1>
    </header>
    <main>
      <ul>
        <li>Biscayne</li>
        <li>Grand Canyon</li>
        <li>Gateway Arch</li>
        <li>Indiana Dunes</li>
      </ul>
    </main>
  </body>
</html>
Notice that the entire document is enclosed in the <html> element. The <html> element is called the root of the DOM.

Observing carefully, you can see that there are two elements directly inside the <html> element: the <head> and the <body>. These are called the children of the <html> element, and the <html> element is the parent of these two elements. The following diagram illustrates this relationship:

Parent and children elements
A parent element nests other elements. An element that is nested inside another element is called a child element.

As you examine the HTML document further, you can see that the <body> element itself also nests some elements. That is, <header> and <main> are children of <body>. Additionally, the <h1> inside the <header> is a child of the <header>. And <main> contains a <ul>, which in turn contains four <li> elements. You can also see that the <head> element has three children.

All of these relationships can be added to the diagram. The result, shown below, is a complete diagram of the DOM the way that the browser represents it.

Diagram of the DOM the way that the browser represents it
You may have noticed that the structure of the DOM resembles a family tree, except that each child has a single parent. The family tree terminology is used when talking about the relationships between the elements of the DOM. You may refer to the parent of an element, the grandparent of an element, the siblings of an element, and so on.

**** Summary
As you learned in this lesson, adding JavaScript to an HTML page is as simple as adding a <script> tag to the page. Although it is possible to write JavaScript directly on the page, it is preferred to link to external JavaScript files.

The DOM is a treelike structure used by the browser to represent and interact with the HTML document.

*** 20.3


Key Terms
Node
An element in a tree structure
NodeList
A list of elements that match a given selector

**** Exploring the HTML
Before you start writing code to work with this HTML, examine the HTML a bit and see if you can think of it in terms of the DOM. Look at the index.html file and try to think about what the DOM structure may be.

You can see that in the <body>, there is a <main> containing four <section> tags. Each of these contains the details of one park. Look carefully at the structure of the HTML in those <section> tags.

**** Do this
Sketch the DOM
Use a piece of paper (or any online drawing tool) to quickly sketch the DOM structure diagram for one of these sections. Do not spend more than five minutes on this exercise. When you are done, compare your sketch to the illustration below.

The following diagram shows one possible solution; note that it shows only part of the DOM. For convenience, siblings are colored the same, and the class names have been included.

DOM structure diagram
**** Accessing the DOM
The browser makes all of the page's HTML accessible via a global variable named document. This variable is available to your JavaScript and contains a reference to the entire HTML document. You can see this by logging the document variable and observing it in the console.

**** Do this
Log the document variable
Add the following code to the index.js file and reload the page in the browser.

console.log(document);
Then open Chrome DevTools and take a look at the console.

Chrome DevTools console with document
Notice that the entire HTML document is logged to the console. You can use the expander arrows to drill down into the document and verify that all of the elements of the HTML are present.

**** Finding an element with querySelector()
Now that you have access to the entire HTML document, you can try to select some elements in the DOM. You can use the built-in querySelector() method to search the DOM. The querySelector() method accepts a string representing a CSS selector. Then it returns the first element in the DOM that matches that selector.

For example, to find an <h1> element on the page, you can use the following syntax:

const heading = document.querySelector("h1");
console.log(heading);
Place the above code in the index.js file and reload the page in the browser. The querySelector() method will traverse the DOM, starting from the root, and find the first <h1> element. In the case of the example web page, the first <h1> element is <h1>National Parks</h1>.

**** Selectors
In the querySelector() example above, the string "h1" was used as a selector. What are some of the other ways that you can specify selectors?

Well, there is a very simple rule: a selector is any valid CSS selector.

You have already seen several types of CSS selectors. Here are just a few of them:

Selector
Description
Examples
Type selector
Targets any HTML element name
h1, p, section
Class selector
Targets elements based on the value of the class attribute
.location, .stats
Id selector
Targets elements based on the value of the id attribute
#rating, #area
Note that in the selector string, a period . prefix is used to indicate a class, and a hash symbol # prefix is used to indicate an ID.

All the CSS selectors are fully documented on MDN's CSS selectors page. You may use any of those selectors as an argument for querySelector().

**** Do this
Select elements
For each of the elements described below, write a statement in the index.js file to find the element. To check that you found the right element, you may log the element that you find to the console.

Find an element with the class value.

Find a <button> element.

Find an element with the class area.

Find a <div> that is a descendant of an element with the class stat. (Hint: Look up descendant selectors in the documentation).

Find an element with the class hello. Take careful note of what is returned there.

**** Collections of elements with querySelectorAll()
You may have noticed that querySelector() returns the first matched element in each example above. But what if you wanted to get all the matched elements? For that, you can use querySelectorAll(). The querySelectorAll() method accepts a string representing a CSS selector. It then returns a list of elements that match the selector.

The selector used for querySelectorAll() follows the same format as with querySelector(). The main difference is that querySelectorAll() returns a list of all matched elements.

**** Do this
Find all <button> elements on the page
Add the following code to the index.js file and reload the web page in the browser.

// Find all the buttons on the page
const buttons = document.querySelectorAll("button");
console.log(buttons);
Then look at the console to see what was logged. You'll see something like this:

Buttons logged to the DevTools console
You may use the expander arrows to drill down into the elements if you wish.

**** Working with NodeList
When you logged the value returned by the querySelectorAll() method, it stated that it was a NodeList. But what exactly is a NodeList?

Node is a term used to describe an element in a tree structure. Sometimes, the elements in the DOM are referred to as nodes, because the DOM is a tree structure. A NodeList, then, is a list of elements that match the selector.

Typically, you'll want to iterate over the list of elements found and process them in some way. The NodeList isn't an array, but it provides several properties and methods that allow it to be processed like an array.

You can iterate over the NodeList using the values() method, as shown below:

// Get a list of all `<h3>` elements
const heading3List = document.querySelectorAll("h3");

// Iterate over the list and print each one
for (let element of heading3List.values()) {
  console.log(element);
}
Or you can use a simple for loop to iterate over the NodeList, like this:

for (let i = 0; i < heading3List.length; i++) {
  const element = heading3List[i];
  console.log(element);
}
Notice that in this second example, the length property of the NodeList and the square bracket [] notation are used to access individual items in the NodeList.

**** Do this
Use querySelectorAll()
First, run the two examples above to verify that they behave the way that you expect. Then try the following:

Get a list of all the <div> elements containing ratings on the page. Log them to the console using the values() method.

Get a list of all the <div> elements containing areas on the page. Log them to the console using a simple for loop.

**** Supporting older browsers
Very old browsers (and Internet Explorer in particular) don't fully support the NodeList interface. As such, the code above may not work as intended. If you need to support Internet Explorer, you can use the Array.prototype.forEach() method, like this:

// Get a list of descriptions
const list = document.querySelectorAll(".description-display");

// Log them to the console
Array.prototype.forEach.call(list, function (element) {
  console.log(element);
});
Note: Recall that in JavaScript, arrays are list-like objects. The Array class is used to construct new arrays. The prototype constructor is commonly used to add new properties and methods to the Array object. You can find a list of available instance methods for Array.prototype in Mozilla's JavaScript Reference.

*** 20.4

**** Modifying an element
Once an element has been selected using querySelector() or querySelectorAll(), you have access to many of its properties and can change some of them. In this section, you'll learn how to implement three common changes that may be made to an element. You'll learn how to change the text contained in an element, change the value of an attribute, and change the CSS style of an element.

**** Changing the content
When you look at the National Parks example web page, you can see that the descriptions of the various parks are all of different lengths. Suppose that you wanted to limit the length of these descriptions to 250 characters and add an ellipsis ... to those that were truncated.

First, you will have to select all the descriptions on the page. You can use a class selector, because all the descriptions are in <div> elements with the class description. Here's an example:

const descriptions = document.querySelectorAll(".description-display");
Next, you will iterate through the list of descriptions and get the text for each one. Each item returned by querySelectorAll() is of type HTMLElement. HTMLElement is a built-in interface that exposes properties and methods common to all elements that are found in an HTML document. HTMLElement is fully documented on MDN's HTMLElement page.

**** The innerText property
One of the properties exposed by the HTMLElement interface is the innerText property. The innerText property contains any text that is contained between the opening and closing tags of the element.

For example, you can iterate through the descriptions and log the innerText value of each description, like this:

for (let desc of descriptions.values()) {
  let content = desc.innerText;
  console.log(content);
}
**** Do this
Log each description
Write the code above in the index.js file and reload the page in the browser. Notice that the description text of each park is logged to the console.

Truncate the text
You can now use string methods to truncate these strings to 250 characters and add ellipses if they are longer than that. You can use the slice() method.

Now, try updating the text using the slice() method to allow for only 250 characters.

If you get stuck, you can consult this solution:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  console.log(content);
}
Once you've accomplished this, observe that each description is truncated and ellipses are attached to the ends. The only exception is the description for Gateway Arch park; that description was already shorter than 250 characters.

Update the HTMLElement
You can now update the HTMLElement, using the innerText property and the truncated text.

Update your code to include the following assignment to desc.innerText.

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  desc.innerText = content;
}
Now, once the page loads, you'll see that the description of each park is less than or equal to 250 characters, plus the ellipses.

**** The innerHTML property
What if you wanted the ellipses that you added above to be clickable? You can wrap an ellipsis in <a> tags to make it into a link. Now, update the code above to use a link instead of a plain string, as follows:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerText = content;
}
Now, when you look at the resulting page, you can see that the browser didn't interpret the additional content as HTML at all. Rather, it displayed the string that was added literally, exactly as you wrote it. You can also see this in the image below:

Biscayne National Park
That literal interpretation isn't a good experience for the users. If you want the browser to interpret the string that you provide as HTML, use the innerHTML property. The innerHTML property represents the HTML markup contained inside of an element.

You can modify line 9 in the code above to use the innerHTML property instead of the innerText property, like so:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerHTML = content;
}
**** Changing the style
To change the CSS style of an element, you can use the element's style property. This property is used to get and set the inline styles of an element. This style property is an object representing all of the CSS styles associated with an element. You can use this object to set any style that you wish.

Suppose that you wanted to bold any rating value that is greater than 4.7. You would have to select all rating values, check if they match the condition, and add a style to those that do. You can start by selecting all rating values, as follows:

const ratings = document.querySelectorAll(".rating-display .value");
Next, iterate through the list and get each actual rating value using the innerText property. This returns a string value, but you want to work with the rating as a number. So, use the parseFloat() method to convert a string into a floating point number, as shown below:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);
  console.log(ratingValue);
}
Next, check the condition. If ratingValue > 4.7, then set the fontWeight style to bold, like this:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
  }
}
The name of the JavaScript property relates to the name of the CSS property. In CSS, a hyphen - is used in property names such as font-weight or background-color. But in JavaScript, the hyphen is dropped, and camelCase is used to create the property name. In other words, property names in JavaScript look like fontWeight or backgroundColor.

Here's another example of a modified style property. The following code sets the color of the rating text to a lighter green if the rating is greater than 4.7.

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
    rating.style.color = "#3ba17c";
  }
}
A complete list of the CSS style properties and the corresponding JavaScript names for those styles may be found in MDN's CSS Properties Reference.

**** The classList property
Alternatively, if you want to make many changes to the style of an element, you could create a CSS class for that style. You could then add or remove that class from the element using the classList property.

The classList property is a list of the classes that are applied to an element. It provides methods to add() and remove() classes.

**** Do this
Dynamically add classes
Add the following CSS class rule to the style.css file.

.high-rating {
  color: #3ba17c;
  font-size: 1.5rem;
  font-weight: bold;
  text-shadow: 1px 1px rgba(0, 0, 0, 0.2);
  text-align: center;
}
When the rating is greater than 4.7, you want to replace the value class with the high-rating class. Modify the JavaScript code to do this, as follows:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.classList.add("high-rating");
    rating.classList.remove("value");
  }
}
**** Creating DOM elements
In the examples above, you saw that you can add to the DOM using the innerHTML property of an element. Below is another example of creating new elements, using the createElement() method. The createElement() method creates a new element with the given tag name.

After creating an element, you will want to add the element to the page using the appendChild() method. This method adds a given element to the end of the list of children of a parent element.

**** Do this
Create a new element with text
Suppose that you wanted to dynamically add a statement to the page's heading, stating the number of parks on display. To do this, you would start by selecting all the parks on the page and getting the number of parks from that list. Then you would construct an element with this information and insert it on the DOM at the right place. Work through this process step by step below.

First, select the parks on the page using the park class as a selector:

const parks = document.querySelectorAll(".park-display");
Then, get the number of parks using the length property of the list:

const numberParks = parks.length;
Next, create a new element. In this case, you should use a <div>:

const newElement = document.createElement("div");
This creates an empty element. But, you have access to all the properties and methods that were used above to modify an element. You can set the text of this element with the innerText property, like this:

newElement.innerText = `${numberParks} exciting parks to visit`;
Add style and classes
You can also style this new element with either the style property or the classList property. Create a new CSS rule for the class header-statement in the style.css file, as shown below. Feel free to add any style that you wish.

.header-statement {
  color: #ffffff;
  font-size: 1.2rem;
}
Then add this class to the new element, as follows:

newElement.classList.add("header-statement");
Add the element to the page
Finally, to add the new element to the DOM, select the <header> element and use the appendChild() method to add the new element to the <header>, as shown below.

const header = document.querySelector("header");
header.appendChild(newElement);
**** Removing DOM elements
You can remove elements from the DOM via the removeChild() method, which removes the provided node from the DOM.

For example, you can select the first park on the page and remove it, as demonstrated here:

// Get the parent element of all parks
const main = document.querySelector("main");

// Select a single park
const park = main.querySelector(".park-display");

// Remove that park
main.removeChild(park);

*** 20.5

**** Event
When a web page is loaded in your browser, it basically sits there doing nothing, waiting for you to read it. As you start to read, you may attempt to scroll to view more of the page, or you may see links and buttons that invite you to click. As you move your mouse pointer around, the page starts to respond. You may see menus open, or animations start, or annoying ads pop up.

These actions, which are called events, all occur in response to some action that you are taking. An event is an action or occurrence that happens in the browser. The system fires an event when certain actions occur.

Key Term
Event: An action or occurrence that happens in the browser

There are many different types of events that occur in the browser. Here are some examples:

Mouse movement, clicks, or dragging

Typing on the keyboard

Touching and swiping on a touch screen device

Resizing the browser window

Closing the browser window or tab

Submitting a form

The web page finishing loading

To learn more about the many types of events that occur in the browser, check out MDN's Events page.

You can respond to these events by writing a function that will run when the event fires. These functions are called event handlers.

Key Term
Event handler: A function that is executed in response to an event occurring

**** Event listeners
When you create an event handler, you need to associate it with an element in the DOM. For example, the user may click a button. You then register an event handler on the button to run when the button's click event fires. The mechanism that detects the event is called an event listener. An event listener contains an event name and an event handler. When the event fires, the event handler is executed.

Key Term
Event listener: A mechanism that detects an event and contains an event name and an event handler

To create event listeners, use the addEventListener() method. This method takes two arguments: the name of the event and an event handler.

Using the National Parks repository, you can add some event listeners to the page.

**** Do this
Add event listener to a button
First, select a button on the page. Write the following code in the index.js file.

const firstBtn = document.querySelector("button");
Then call the addEventListener() method on this button. For now, you will write a very simple function for the event handler:

firstBtn.addEventListener("click", (event) => {
  console.log("You clicked the button", event);
});
Reload the page in the browser, and try clicking the first button on the page. The event handler accepts a single parameter representing an event object. This event object encapsulates some details about the event that occurred. Observe the output in the console.

**** Details about the event
The event object that is passed to the event handler contains some information that you can use while handling the event. The event object is automatically passed to event handlers when they are invoked. They contain information relevant to the event itself.

For example, you can get the specific element that fired the event with the target property of the event object, as shown here:

firstBtn.addEventListener("click", (event) => {
  console.log(event.target);
});
This is especially useful when you attach the same handler to multiple elements. For example, you may want to highlight a park when the button associated with that park is clicked. You could attach the same event handler to each of these buttons. Take a look:

// Select all the buttons for all the parks
const allBtns = document.querySelectorAll(".rate-button");

// Iterate through the list of buttons and add an event handler to each
allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target);
  });
});
Notice that when you click any of the buttons, you get the same result. So how would you know which park belongs to the button that was clicked?

The <section> element that represents a park is the parent of the button. Because event.target refers to the button that was clicked, then using the parentNode property of that button will get you the <section> element that was clicked. Here's what that looks like:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target.parentNode);
  });
});
Notice that each time you click the button, the <section> element in which that button resides is logged to the console. You can then manipulate this element in any way that you wish. For example, the following code changes the background color:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  });
});
**** A complete example
Suppose that you wanted to give the user the ability to sort the list of parks displayed on the page; you want them to be able to sort by either name or rating. You can add two links and allow the user to click whichever one they wish. You would then get the list of parks from the DOM, perform a sort on the list, and insert the parks back into the DOM in the new order.

Start by adding the following HTML to index.html. Insert this between the <header> and the <main>.

<div class="sorter">
  Sort by:
  <a href="" class="sort-link" id="name-sorter">Name</a> |
  <a href="" class="sort-link" id="rating-sorter">Rating</a>
</div>
Then, optionally, you could add some CSS to the style.css file.

.sorter {
  width: 90%;
  margin: 0 auto;
  padding: 6px;
}
Next, add an event listener to the link. You will build this in steps so that it is clear what each step does. The following code all goes in the index.js file.

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  console.log("You clicked the name sorter");
});
Notice that you are selecting the link by the ID. However, when you click the link, the log in the console blinks for a moment and then disappears. Why is that?

The default behavior of a link is to follow the link that was clicked. In this case, the browser is simply reloading the page. That clearly isn't what you want. You can stop this from happening using the preventDefault() method of the event object:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();
  console.log("You clicked the name sorter");
});
This time, when you click the link, the page doesn't reload. Here is the logic that you will implement in this event handler:

Get the <main> element that contains all the parks.

Get a NodeList of all the parks.

Empty the <main> element.

Convert the NodeList to an array for convenience of sorting.

Sort the array using techniques that you learned previously.

Iterate through the sorted array and append each park to <main>.

Remember, you'll build the event handler step by step. Start by reviewing the code for the first three steps:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";
});
If you run the above code, you will notice that the parks disappear from the page when the link is clicked. That is because you removed them from the DOM. However, they still exist and can be referenced from the parksList variable.

To create an array from the NodeList, use the Array.from() method, as shown below. This takes an array-like structure and constructs an array.

// 4. Create an array
const parksArray = Array.from(parksList);
You can now use the sort() method of the array to sort this array. However, you need to write the function that defines how to sort the parks. Given two park elements, you need to find the name of each park and then compare the names. The park names are the innerText of the <h2> element.

// 5. Sort the array
parksArray.sort((parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
});
The final step is to iterate over this sorted array and append each park element to the <main> element.

So, the full code may look like this:

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1. Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort((parkA, parkB) => {
    const parkAName = parkA.querySelector("h2").innerText;
    const parkBName = parkB.querySelector("h2").innerText;
    if (parkAName < parkBName) {
      return -1;
    } else if (parkAName > parkBName) {
      return 1;
    } else {
      return 0;
    }
  });

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
});
As you can see, the event handler code has gotten quite long. To help make the code more manageable, you can refactor this code by creating an external function for the event handler, and another for the sorting. The following code is equivalent to the above.

// Function for sorting by name
const sortByName = (parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};

// Function for handling the `nameSorter` click
const nameSorterClickHandler = (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort(sortByName);

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
};

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", nameSorterClickHandler);
**** Do this
Sort parks by rating
Implement an event handler for the ratingSorter link. Use the above example as a template.

**** The DOMContentLoaded event
So far, you have been writing the JavaScript code to interact with the DOM without regard to whether the DOM has been fully loaded by the browser. In this fairly small web page that you are using as an example, this hardly matters. But what happens when the web page becomes much larger, and the browser has a lot more work to do to render the page? Is it guaranteed that the JavaScript code will run only after the HTML is fully parsed and loaded by the browser? The short answer is no.

Therefore, you need some way of knowing that the DOM is ready for you to interact with it. Luckily, there is a built-in event that you can hook into. Once the HTML is fully parsed and loaded, the browser fires an event called DOMContentLoaded. The DOMContentLoaded event fires when the HTML is fully parsed and loaded, whether or not the stylesheets and images are done loading.

To make sure that your HTML has been loaded into the DOM before your JavaScript code tries to interact with the DOM, you can run your JavaScript code when the DOMContentLoaded event fires. This event is attached to the window object, which you can think of as the browser itself.

**** Do this
Add a DOMContentLoaded event handler
Add the following code to the JavaScript file, reload the page in the browser, and observe the console.

console.log("Before!");

window.addEventListener("DOMContentLoaded", (event) => {
  console.log("Loaded!");
});

console.log("After!");
You will see output similar to this:

Before!
After!
Loaded!
The code in the JavaScript file executes immediately as the file is parsed. However, the code inside the DOMContentLoaded event handler doesn't run until the HTML is fully parsed and loaded into the DOM.

**** Refactor the DOM manipulation code
It is common practice to move code that manipulates the DOM into a single DOMContentLoaded event-handler function. You can name that function anything that you want. For example, you might name it init, ready, or main, as in the example below. Notice how main is declared, then passed to window.addEventListener() as the event handler:

// Declare handler and support functions here

// Function for sorting by name
const sortByName = ...

// Function for sorting by rating
const sortByRating = ...

// Function for handling the `nameSorter` click
const nameSorterClickHandler = ...

// Function to handle the `ratingSorter` click
const ratingSorterClickHandler = ...


// The code that runs once the DOM is loaded
const main = () => {
  // Select the `nameSorter` link
  const nameSorter = document.querySelector("#name-sorter");

  // Add an event listener
  nameSorter.addEventListener("click", nameSorterClickHandler);

  // Select the `ratingSorter` link
  const ratingSorter = document.querySelector("#rating-sorter");

  // Add an event listener
  ratingSorter.addEventListener("click", ratingSorterClickHandler);
}

// Add event listener for `DOMContentLoaded`
window.addEventListener("DOMContentLoaded", main);

*** 20.6

Websites often capture data entered by users. The user enters data on the form and then submits it. At this point, some validation is typically performed. So, you need to write some code to handle the event of the form being submitted.

The submit event fires when the user submits a form. This event fires on the <form> element itself, not on any button on the form.

As you did with other events, you can simply provide a handler function for the submit event.

Starter code
You will use the same code repository that you used in the previous lessons. The starter code for this lesson is in the branch Form_Starter.

If you need to clone the repository, run the following command in the terminal.

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
Once the repository is cloned to your local machine (or if you had it already), navigate to the project folder and check out the branch.

git checkout Form_Starter
Examine the index.html file. There is a <form> for adding a new park, with inputs for the various park values.

Handling the submit event
To handle the form submission, you need an event handler function. You then create the event listener on the form. As you did in the previous lesson, you will perform this when the DOM is fully loaded.

Do this
Create a submit handler
In the index.js file, create a function named submitHandler(). This function will be used for handling the form submission.

const submitHandler = (event) => {
  console.log("The form was submitted");
};
Then add a main() function that creates the event listener for the form submission.

const main = () => {
  // Get the form element
  const form = document.querySelector("#park-form");

  // Attach the submit handler
  form.addEventListener("submit", submitHandler);
};
And finally, add an event listener for DOMContentLoaded that invokes the main() function.

window.addEventListener("DOMContentLoaded", main);
You will notice that when you try to submit the form, the page is reloaded immediately. That is the default behavior of forms in a browser. You can stop this default behavior using the preventDefault() method of the event. Modify the submitHandler() function with this statement:

const submitHandler = (event) => {
  event.preventDefault();
  console.log("The form was submitted");
};
You will notice that upon submitting the form, the page no longer refreshes.

The FormData object
Now that you have a handler that is invoked on a form submit, you need to get the data that the user entered on the form. There are a number of ways that you could do this.

You could directly select one of the <input> elements and use the value property to get data. To do this, you would add the following to the submitHandler() function:

// Get the name input
const parkName = document.querySelector("#name-input").value;

console.log(parkName);
Now, when you enter a name and submit the form, you'll see that value.

However, remember that there's more than one way to get the data. In fact, there is a built-in object that can automatically read the data from the form and present it in an easy-to-use interface. The FormData object can be populated with a form's data as a set of key-value pairs. To use the FormData object, simply instantiate one with the <form> element, as shown below.

const submitHandler = (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
};
The FormData object has several methods for working with the form. You can use the get() method to get a specific value. The keys in the FormData correspond to the names of the form's <input> elements.

For example, to get the park name value, you could use the following code:

const name = formData.get("name");
console.log(name);
Required validation
Before using the data entered by the user, you can do some validation on it. For now, you'll go through some basic required validation, just so that you can see that it is possible. You will notice that on the HTML form, there are some error messages that are currently hidden by the CSS.

You can validate that the user entered some text for each form input. And if they did not, you can display the corresponding error message. Since you will be using the same code to check each input encapsulating that logic in a function would make that easier.

Do this
Add validate function for required fields
Add the following function to the JavaScript file. It accepts a single string value and returns true if the value isn't null and the string contains at least one non-space character.

function validateExists(value) {
  return value && value.trim();
}
The main validation function
Placing all the code to perform the validation in its own function would be useful and make the code more readable. This function will take each input field, perform required validation on it, and generate a collection of error messages which may then be displayed for the user.

Here's an example of such a function. It performs the required validation on each of the fields on the form.

function validateForm(formData) {
  const errors = {};

  // Check if name was entered
  if (!validateExists(formData.get("name"))) {
    errors.name = "Please enter a name";
  }

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  }

  // Check if description was entered
  if (!validateExists(formData.get("description"))) {
    errors.description = "Please enter short description";
  }

  // Check if established date was entered
  if (!validateExists(formData.get("established"))) {
    errors.established = "Please enter date";
  }

  // Check if area was entered
  if (!validateExists(formData.get("area"))) {
    errors.area = "Please enter the area of the park";
  }

  // Check if location date was entered
  if (!validateExists(formData.get("location"))) {
    errors.location = "Please enter the location of the park";
  }

  return errors;
}
This function accepts a FormData object containing the data from the form and checks each one to ensure that some value was entered. Now, this function must be called from the submitHandler() function.

Do this
Validate the form
Add the validateForm() function to the JavaScript file then modify the submitHandler() function as follows.

const submitHandler = (event) => {
  event.preventDefault();

  const form = event.target;
  const formData = new FormData(form);

  const errors = validateForm(formData);

  // Clear all previous errors
  const errorElements = document.querySelectorAll(".error");
  for (let element of errorElements) {
    element.style.display = "none";
  }

  // Display any new errors
  Object.keys(errors).forEach((key) => {
    // Find the specific error element
    const errorElement = document.querySelector(`#${key}-form .error`);
    errorElement.innerHTML = errors[key];
    errorElement.style.display = "block";
  });
};
Of course, this is just a basic validation that is used for illustration. This could have been accomplished in a number of other ways.

For example, the ratings field is supposed to be a number in the range 1-5, inclusive. You can create validation functions to validate that a given value is actually a number and another that validates the number in a specific range.

function validateNumber(value) {
  return !isNaN(value);
}

function validateRange(value, min, max) {
  return value >= min && value <= max;
}
Then the validateForm() function may be modified to add these validations to the ratings.

  ...

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  } else {
    // Check if the rating is a number
    if (!validateNumber(formData.get("rating"))) {
      errors.rating = "Rating must be a number";
    } else {
      // Because it is a number, convert it
      const rating = Number.parseFloat(formData.get("rating"));
      // Check that the rating is between 1 and 5, inclusive
      if (!validateRange(rating, 1, 5)) {
        errors.rating = "Rating must be between 1 and 5 inclusive";
      }
    }
  }

  ...
Similarly, other validation for any constraints on the data may be implemented in this function.

Add a park
Finally, if all the validation passes, you could update the DOM with the new park information. This would involve creating a new element for the form, making sure that it is formatted the same way as all the other parks on the page, and appending it to the parent element of all the parks.

By observing the HTML, you can see that a park is constructed like this:

<section class="park-display">
  <h2>The park name here</h2>
  <div class="location-display">the park location here</div>
  <div class="description-display">The park description here</div>
  <button class="rate-button" title="Add to Favourites">&#9734;</button>
  <div class="stats">
    <div class="established-display stat">
      <h3>Established</h3>
      <div class="value">The date of establishment here</div>
    </div>
    <div class="area-display stat">
      <h3>Area</h3>
      <div class="value">The area of the park here</div>
    </div>
    <div class="rating-display stat">
      <h3>Rating</h3>
      <div class="value">The rating of the park here</div>
    </div>
  </div>
</section>
Most of this is just template data—that is, it's mostly parts that don't change, interspersed with some data to be filled in.

You can create a new <section> element and set the rest of the HTML as the innerHTML property of the new element. You can use template literals to construct the correct HTML.

Do this
Add a park to the DOM
Add the following code to the end of the submitHandler() function.

// If there are no errors
if (!Object.keys(errors).length) {
  // Create a new element
  const parkSection = document.createElement("section");

  // Add the park class
  parkSection.classList.add("park-display");

  // Construct the HTML for this element
  const content = `
    <h2>${formData.get("name")}</h2>
    <div class="location-display">${formData.get("location")}</div>
    <div class="description-display">${formData.get("description")}</div>
    <button class="rate-button" title="Add to Favourites">&#9734;</button>
    <div class="stats">
      <div class="established-display stat">
        <h3>Established</h3>
        <div class="value">${moment(formData.get("established")).format(
          "MMMM D, YYYY"
        )}</div>
      </div>
      <div class="area-display stat">
        <h3>Area</h3>
        <div class="value">${formData.get("area")}</div>
      </div>
      <div class="rating-display stat">
        <h3>Rating</h3>
        <div class="value">${formData.get("rating")}</div>
      </div>
    </div>
    `;

  // Set the innerHTML
  parkSection.innerHTML = content;

  // Append to the main element
  document.querySelector("main").appendChild(parkSection);
}
The Moment library, which is included in the index.html file, can help you format dates before displaying them in the DOM.

In the content HTML above, calling moment(formData.get("established")).format("MMMM D, YYYY") will format any valid date entered into the established field using the MMMM D, YYYY format (which looks like January 1, 1999).

For example, if you enter a valid date such as 12-06-1987 or 12/06/1987 into the established field and submit the form, the date will show up as December 6, 1987 in the DOM. Using the moment library to format dates in your website can therefore help you display dates in a consistent manner in the DOM, regardless of the user input (as long as it's a valid date).

Check out the Moment.js docs for other arguments that you can pass to the moment().format() method to control how dates are displayed in the DOM. Also check out how you can use the Moment library to verify a date's validity.

The full solution code for this lesson can be found in the Form_Solution branch on the starter repository.

*** 20.7

Key Terms
Event delegation
The process of handling events at a higher point in the DOM than where the event originated
Starter code
For this lesson, you will be using the same repository as in the previous lessons in this module.

If you haven't already done so, clone the repository to your local machine as follows:

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
The starter code is in the branch Render_Starter. Check out that branch using the command below, and load the index.html file in the browser.

git checkout Render_Starter
Data and the DOM
In the code that you have written so far, the data associated with the parks has all been contained in the HTML file. As a result, the structure of the HTML has become tightly coupled to the processing of the data.

For example, look at the way that the parks are sorted by rating. Here is the sortByRating() function used to perform the sort.

const sortByRating = (parkA, parkB) => {
  const parkARating = parseFloat(
    parkA.querySelector(".rating-display > .value").innerText
  );
  const parkBRating = parseFloat(
    parkB.querySelector(".rating-display > .value").innerText
  );
  return parkBRating - parkARating;
};
In particular, pay attention to the way that you got the rating value from the DOM. You selected an element with the class rating and looked for a direct descendant with the class value. This can be problematic for a number of reasons.

If the HTML structure is updated for any reason—such as to improve the layout or to add further data to the park—the JavaScript sorting code will break.

And if the style is updated and the class names are changed, that will also break the JavaScript code. For that reason, you can say that the HTML structure is tightly coupled to the JavaScript code. This coupling can make it very difficult to maintain code in the long run.

So how can you make the HTML and JavaScript files less dependent on each other? One way is to identify the data that you are concerned with and store that data separately. You can then generate the DOM based on the data.

The data
In the starter code, there is a file named data.js. This file contains a single array declaration, and the array contains several objects representing parks.

const parks = [
  {
    name: "Biscayne National Park",
    location: "Florida, United States",
    description:
      "Biscayne National Park encompasses coral reefs, islands and shoreline mangrove forest in the northern Florida Keys. Its reefs and islands are accessible only by boat. Dolphins, turtles and pelicans live in Biscayne Bay Lagoon. The underwater Maritime Heritage Trail links dive sites, most of them shipwrecks. On Boca Chita Key, Boca Chita Lighthouse has coastal views. A museum at Convoy Point explains local ecosystems.",
    established: "June 28, 1980",
    area: "172,971 acres (699.99 km^2)",
    rating: 4.7,
  },
  // ...
];
You can now write a function whose job it is to construct a DOM element for each park and insert it into the DOM at an appropriate place. If you update this data at any time, say in response to the user adding a new park, you can simply run the function again to update the DOM.

Similarly, if you want to sort the data, you can perform the sort on this array of data, and then execute the same function again to update the DOM with the sorted data.

When you generate the DOM in response to data in this way, you are rendering the user interface. For that reason, it makes sense to name this function render().

The render() function
To render the parks on the page, you will have to do the following:

Remove any existing content from the parent element.

Create the HTML for each park in the array.

Set the innerHTML of the parent element.

Do this
Create a renderOnePark() function
You can create a function named renderOnePark() that accepts a park and returns the HTML code for that park. To do so, add the following code to the index.js file.

const renderOnePark = (park) => {
  // Get the individual properties of the park
  const { name, location, description, established, area, rating } = park;

  const content = `
      <section class="park-display">
        <h2>${name}</h2>
        <div class="location-display">${location}</div>
        <div class="description-display">${description}</div>
        <button class="rate-button" title="Add to Favourites">&#9734;</button>
        <div class="stats">
          <div class="established-display stat">
            <h3>Established</h3>
            <div class="value">${established}</div>
          </div>
          <div class="area-display stat">
            <h3>Area</h3>
            <div class="value">${area}</div>
          </div>
          <div class="rating-display stat">
            <h3>Rating</h3>
            <div class="value">${rating}</div>
          </div>
        </div>
      </section>
  `;
  return content;
};
Create a render() function
The render() function will make use of the renderOnePark() function. Add the following code to the index.js file.

const render = () => {
  // Get the parent element
  const main = document.querySelector("main");

  // Empty the parent element
  main.innerHTML = "";

  // Get the parks HTML
  const content = parks.map(renderOnePark).join("");

  // Set the `innerHTML` of parent element
  main.innerHTML = content;
};
Call render() in the main() function
To call the render() function, add the following statement to the main() function.

const main = () => {
  // All the existing code

  render();
};
Refactor the sort
The two sort functions are still getting the data from the DOM. You can refactor these to directly sort the parks array itself and simply call render() when it is time to update the DOM.

The sortByName() function may be refactored to accept two park objects rather than two DOM elements.

const sortByName = (parkA, parkB) => {
  const parkAName = parkA.name;
  const parkBName = parkB.name;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};
Notice that you aren't querying the DOM anymore. You have direct access to the data. Correspondingly, the nameSorterClickHandler() function is now simpler. You can remove all the DOM access and manipulation. You just need to do two things:

Sort the array.

Render the page.

You can implement this as follows:

const nameSorterClickHandler = (event) => {
  event.preventDefault();

  parks.sort(sortByName);

  render();
};
Do this
Refactor the sort-by-rating functions
Using the above as a guide, refactor the sort-by-rating functions to use the render() function.

Adding new park
In the previous lesson, you added a new park by constructing the DOM element for the new park and appending it to the DOM. Now that you have separated the data from the DOM, you should instead insert a new park object into the parks array, and then render the page again.

You can modify the submitHandler() function to do this. Change the function as follows:

const submitHandler = (event) => {
  event.preventDefault();

  const form = document.querySelector("#park-form");
  const formData = new FormData(form);

  // Keep track of if any errors are found
  let hasErrors = false;

  // Validation code skipped for brevity
  // ...

  // If there are no errors
  if (!hasErrors) {
    // Create an empty object
    const park = {
      name: formData.get("name"),
      location: formData.get("location"),
      description: formData.get("description"),
      established: formData.get("established"),
      area: formData.get("area"),
      rating: formData.get("rating"),
    };

    parks.push(park);

    render();
  }
};
The favorite buttons
You may have noticed that now that you have refactored the code, the favorite buttons no longer work. This is because you are losing the event listeners associated with the button. Remember that the main function runs as soon as the DOM is loaded for the first time.

In the main function, all the buttons on the page are selected, and an event listener is attached to each one. However, you consequently remove that content from the DOM any time that you call the render() function. When you remove an element from the DOM, all associated event listeners are also removed.

But what if you instead attached the event listener to an element that remains on the page all the time? For example, what if you attached it to the <main> element? Because that element is never removed, if you attach an event listener, then it stays for the lifetime of the page.

Consider the following diagram:

The way a click event propagates up the DOM
This diagram shows how a button is positioned on top of the section, which is positioned on top of the main, which in turn is positioned on top of the body. Even though the mouse pointer is over the button, it is also over each of these elements in turn.

When you click the button, the click event propagates up the DOM from the button, to the section, to the main, and to the body.

You can modify the main() function by removing the event-handling code for the buttons and replacing it with this:

// Select all the buttons for all the parks
const main = document.querySelector("main");

// Add event handler to the main
main.addEventListener("click", favoriteButtonClickHandler);
Then you need to modify the favoriteButtonClickHandler() function. Because you attached the event listener to the <main> element, it triggers whenever a click happens anywhere on the <main>. You want to restrict the event handling to only the buttons.

You can do a conditional check to ensure that the element that triggered the event was the button.

Modify the favoriteButtonClickHandler() function as follows:

const favoriteButtonClickHandler = (event) => {
  if (event.target && event.target.nodeName == "BUTTON") {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  }
};
Here, you are checking that the target of the event—the actual element that was clicked—is a button. If so, you perform the action.

This way of handling events is called event delegation. Event delegation is the process of handling events at a higher point in the DOM than where the event originated. It's said that the event propagates up the DOM.

If you want, you can continue working on this application to improve it even further. But now, you're familiar with the essentials of interacting with the DOM, handling events, and separating the data processing from the DOM.

** module 21 rendering with react
*** 21.1 Overview: Rendering with React

Overview: Rendering with React
9 minutesEstimated completion time
Overview

As you've likely seen, DOM manipulation code can quickly become overwhelming. Managing multiple event listeners and the changing state of the page can be difficult to do in a way that doesn't result in extremely complex code. So in this module, you'll learn how to use React, a powerful tool that makes it easier to build complex web applications that rely on DOM manipulation.

Various frontend frameworks have begun to arise as a way to manage the complexity of DOM manipulation code; these frameworks make it easier to build complex pages that rely heavily on DOM manipulation. AngularJS, Ember.js, Vue, and React are just some of the tools that have become popular.

React is by far the most popular of these. React's component structure allows for quickly building a complex web application that relies on DOM manipulation. In this module, you will get your first taste of React. By the end of the module, you'll be able to use React components to recreate the basic structure of a web page.

In some ways, this may feel like taking a step back. You'll be redoing tasks that you could achieve with basic HTML, CSS, and DOM manipulation. But as you'll see later, although React takes a bit of work to set up, it's powerful once you begin to build more complex applications.

*** 21.2 Create React App

Create React App
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to create, modify, and run a basic React app on your computer using the create-react-app command.
Overview

To get a React app running on your computer, you need to create numerous files. Fortunately, a script called Create React App will generate all of these files for you. In this lesson, you'll learn how to use Create React App to set up a React app.
Creating a React app

Start by watching the video below, which provides a brief introduction to the process for setting up a React app using the Create React App script. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Use npx to run the create-react-app command. This command takes a folder name as an argument and will create the folder for you.

The full command will look something like this:

npx create-react-app <folder-name>

Do this
Create a React application

Navigate to a folder that isn't a Git repository. Then, run the following command:

npx create-react-app getting-started-with-react

If you inspect the directory, you'll see that a new folder, getting-started-with-react, has been created. From the command line, navigate into that folder.
Running the application

The package.json file inside of the newly created React application comes with a few useful scripts. One of these scripts is the following:

npm start

Once you run the command above, you'll see something like the following output in your terminal:

Compiled successfully!


You can now view getting-started-with-react in the browser.


  Local:            http://localhost:3000

  On Your Network:  http://XX.X.X.XX:3000


Note that the development build is not optimized.

To create a production build, use npm run build.

If your browser doesn't open automatically, open the browser to the following page:

http://localhost:3000

This is where your app is hosted on your machine. You will see a spinning blue React logo. This is the default app that Create React App starts with, but you will edit it to be your own.
What's happening on your command line?

You don't have access to the command-line prompt when the local server is running.

This is because when npm start is run, a package called webpack spins up a server to host your frontend code. This server will keep running so that you can witness changes made to your application while you're working on it, and it will provide feedback when any errors occur.

If you need your command line for something else, open a new tab in your terminal application.

If you need to stop the server, with the terminal window active, you can type Control+C (or Command+C on a Mac). You shouldn't stop a server by just closing the terminal tab where it's open; this won't always stop the server, and it will sometimes remain running in the background. Be intentional when running local servers, and close existing local servers before running new ones. If a local server is running and you try to run another one, you'll be offered the option of creating another port to run another local server, but that isn't recommended.

? Something is already running on port 3000. Probably:

  /usr/local/bin/node /Users/matthew/Desktop/www-2/reactx/node_modules/react-scripts/scripts/start.js (pid 8493)

  in /Users/matthew/Desktop/www-2/reactx


Would you like to run the app on another port instead? › (Y/n)

The video below provides an overview of this topic.
Do this
Stop and start the server

Practice stopping a running server by following the method outlined above. Then, restart the server by running npm start again. Once you get used to these commands, stopping and starting the server is quite easy.
Open up a new terminal tab

Open up a new terminal tab and navigate to the same getting-started-with-react directory. Continue any command-line work in this tab while the local server is running that application.
Standard files

The video below provides an overview of the standard Create React App files.

Create React App includes a few folders and several files:

    The files at the root level of this project typically include JavaScript configuration files like a package.json file and a README.md file. Make sure to update the README if this is a larger project!

    The public folder represents what is available to web browsers. This folder also contains the index.html file, which is the entry point to the application. During the build process, React inserts a script tag referencing the compiled code into the index.html file.

    The src folder is where most of your React components will be written. Only the files within this folder will be processed by React. This folder will commonly be used to also contain subdirectories for the files associated with each component, including images and CSS stylesheets.

You won't need all of these files to get started with React. At the start of any Create React App project, you can usually delete the following files:

    public/logo192.png: Smaller PNG of the React logo

    public/logo512.png: Larger PNG of the React logo

    src/logo.svg: SVG version of the React logo

    src/App.test.js: For tests that you aren't using

    src/reportWebVitals.js: For tests that you aren't using

    src/setupTests.js: For tests that you aren't using

Do this
Delete unneeded files

In your project, delete the unnecessary files listed above.

If you compile this code after deleting these files, you'll get an error in the terminal window running your local server.

Failed to compile.


Error: ENOENT: no such file or directory

Don't worry, as you update the existing JS files and remove the links to these recently deleted files, your projects will soon run error free.
How the files connect
The index.html file

The entry point to your application is index.html.

Within the <head> element, you can always update the <title>, which will display at the browser title. This is the only real change you may need to make to this page in getting started.

The <body> element will look similar to the code below:

<body>

  <noscript>You need to enable JavaScript to run this app.</noscript>

  <div id="root"></div>

  <!--

      This HTML file is a template.

      If you open it directly in the browser, you will see an empty page.


      You can add webfonts, meta tags, or analytics to this file.

      The build step will place the bundled scripts into the <body> tag.


      To begin the development, run `npm start` or `yarn start`.

      To create a production bundle, use `npm run build` or `yarn build`.

    -->

</body>

For now, just take note that the <div> element in the <body> is given the ID #root. As described in that code sample's comment, the build step will place the JavaScript that you write into this HTML container.

You don't need to make any additional changes to this HTML page, unless at some point you want to add HTML elements that are specific to this page and outside the React components that you plan to build.
The index.js file

The index.js file is your primary JavaScript file. The original demo code was the app with the spinning React logo that ran in your local server. For now, you'll be able to remove some of the original demo's unnecessary code to have a cleaner starting point for your own app.
Do this

Replace all of the default code within index.js with this code.

import React from "react";

import ReactDOM from "react-dom";

import "./index.css";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

In the index.js file, both React and ReactDOM are both imported. This use of import instead of require may be a little different than what you are used to. Importing React will make sure that your components are compiled properly, and ReactDOM will make sure that the DOM-related methods to display the components into the browser are also compiled properly.

Then, the CSS stylesheet index.css will be imported. This stylesheet should contain any global CSS styles that can be used within the web page and aren't specific to any component. The App.js file will then be imported. This file will contain your primary component that will be displayed in the web page.

React uses the render() function to display the component in the web page. The render() function takes two arguments: the React component to be rendered and the DOM container where it should be placed. The Create React App setup uses the root element as the DOM container, which is obtained with document.getElementById('root'). You can ignore the <React.StrictMode> tags for now because they enable more helpful warnings during development.

Note that when you save this file you'll still see errors because you still need to update the App.js file.
The App.js file

The App.js file is for your app component. It's the main component in React, and it acts as a container for all other components. You'll override the App component with your own code.

All of the code within the App component will be returned, exported, and then used within the index.js file as explained above.
Do this

Replace all of the default code within App.js with the following code.

import "./App.css";


function App() {

  return <h1>Hello World!</h1>;

}


export default App;

The first line in App.js will import the CSS stylesheet that should specifically be applied to the App component.

Then within your App component, create a simple component that has a heading with the following text: "Hello World!".

Notice that this code uses export default instead of module.exports to export the function. Although you don't need to use a named function, this can be useful for debugging purposes and for readability. These will be some of the little differences in the syntax when using React.

When you save this file, you will have fixed all the code that linked to your recently deleted files. In the browser that is displaying your local server, you will see a simple web page with a large text heading that displays "Hello World!".
Web page with a large text heading that displays "Hello World!"

If you closed the web browser, you can always reopen and view the local server using this URL:

http://localhost:3000

If your browser didn't reload with the latest changes, make sure that all of the changes that you have recently made to your pages have been saved. You can always try stopping and starting the local server, too.

*** 21.3 Thinking in React
Program overview

 Thinking in React
Lesson 3
Thinking in React
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to determine what React components should be created, given a web page design.
Overview

React apps are broken into pieces called components. As you'll see in this lesson, React allows you to define your own components, making it possible to split an application's code into easy-to-understand, reusable pieces.
Key Terms

Single-responsibility principle
    A principle that states that each module, function, or component in a program should have responsibility for one single part of the program

What is a component?

A component is a single part of the user interface and can be reused in multiple places. In general, components are made up of elements like <h1> or <img>, but with specific properties for your application. Although a component can be a single HTML element, it's typically a collection of elements.

Each component in the app has a single responsibility. For example, in a web page for a retail site, you may have these components:

    A menu bar

    The item listing, with a photo and description of the item

    A review, of which there may be multiple on the page

Note that you can customize each component for the app that you're working on.
Determining the components

Take a look at the following simple application, which keeps track of what the user needs to buy at the grocery store.
Shopping list app

There are a number of different pieces that make up this application:

    At the top, there is an input box for adding a new item to the list. This is its own component.

    The list is made up of any number of items and a title. The entire list is its own component.

    Each list item is also a component, nested inside of the overall list component. The checkbox and buttons are included in each list item component.

Here's a visual representation of this, with the three component types highlighted:
Shopping list app, annotated

At the top, highlighted in green, is the input box for adding an item. This is an AddItem component.

Below that, also highlighted in green, is the overall list. This is the GroceryList component. Inside of the GroceryList component are as many Item components as necessary to represent the list.

One of the Item components is highlighted in blue.
The single-responsibility principle

How should you decide what should be a component? The process is very similar to deciding what should be a function: you use the single-responsibility principle, which means that each component should have one thing that it does.

Consider what each of the components defined above do:

    The AddItem component is responsible for adding items to the list.

    The GroceryList component is responsible for showing a title and all of the items.

    Each Item component is responsible for showing information about the item, including whether it's been checked off or not.

Often, as an app grows and more functionality is added to the app, components are further broken down into more components.
Component composition

Components can be made up of other components. In this case, the entire application could be an App component that includes the following:

    One AddItem component

    One GroceryList component

    Any number of Item components, depending on the number of items in the list

There is a lot to learn about how to write components with React, but the first step to building any app is determining what components are needed.

*** 21.4 Import and export

Import and export
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use ES6 import and export statements.
Overview

When you work with React, you will be using special ES6 syntax for importing and exporting. As you'll see in this lesson, ES6 import and export statements work similarly to require() and module.exports, but they have a new and cleaner syntax.
Named exports

You will be using the keyword export to export objects from a file. To create and export a constant, you can use this syntax:

const website = "https://www.thinkful.com/";

export website;

You can also do this on one line, like so:

export const website = "https://www.thinkful.com/";

And you can have multiple named exports, as shown here:

export const website = "https://www.thinkful.com/";

export const username = "Bob";

Named imports

If you have a file constants.js, with website and username defined and exported, as they are above, you can use the import statement shown below. Note that you use an object with the variable names that are exported in constants.js.

import {website, username} from "./constants";

After running the import statement shown above, you'll have access to the website and username variables.
Default exports

When a file has a single export, or when one of the things exported will be used more often than others, you can set a default export instead of a named export.

The syntax for this is very similar to export statements, except that you add the keyword default.

const website = "https://www.thinkful.com/";

export default website;

Or, equivalently, you can write this in one line:

export default "https://www.thinkful.com/";

Now, you can import with the following statement:

import website from "./constants";

When using defaults, you don't need to give the exported variable the same name as the imported variable. You could also run the following import statement:

import url from "./constants";

For more information, check out the full MDN documentation on import and export.
Combining named and default exports

You can have one default export and any number of named exports. For example, the following file has a default and a named export.

export default const website = "https://www.thinkful.com/";

export const username = "Bob";

You can use the following import statement to import both website (a default export) and username (a named export).

import {website, username} from "./constants";

*** 21.5 Introduction to JSX

Introduction to JSX
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use React and JSX to make a basic web page.
Overview

In this lesson, you will learn the basics of JSX. JSX is an HTML-like syntax for defining user interface elements right inside your React code.
Starter code

Reuse the existing React App or create a new app following the steps in the Create React App lesson earlier in this module. Make sure that you remove the unnecessary files and update the existing files with the appropriate code.
Introduction to JSX in React

Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

You've already seen JSX if you've used Create React App to generate a new React project.
Hello world in React

What you may have thought was HTML in your App.js file was actually JSX. That JSX element was written like this:

<h1>Hello World!</h1>

This JSX is written inside your JavaScript instead of in a separate HTML or template file. The complete code that you should be starting with in your App.js file should be as follows:

import "./App.css";


function App() {

  return <h1>Hello World!</h1>;

}


export default App;

Embedding JavaScript expressions in JSX

JSX is an expression, so you can save it to a variable and then return the value of that element, as shown here:

const element = <h1>Hello World!</h1>;

return element;

You can also embed JavaScript code into JSX by using curly braces {}, like this:

const name = "Alice";

const element = <h1>Hello {name}!</h1>;

return element;

Now, element will render as Hello Alice!.

You can put any JavaScript expression inside the curly braces. Here is an example using individual variables as well as the expression count * price. Notice that you can use parentheses () to enable all of these elements to take up multiple lines within this element.

const item = "apple";

const price = 2;

const count = 10;

const element = (

  <div>

    <h1>Total Purchased:</h1>

    <p>

      Purchased {count} {item}s for ${price} each. The total is ${count * price}

      .

    </p>

  </div>

);

return element;

Do this
Update your App.js file

Update your App.js file with the following code:

import "./App.css";


function App() {

  const element = <p>Hello, there!</p>;

  return element;

}


export default App;

As long as your local server is running, when you save this file, you should see your changes updated in the browser. Remember, when you export your code from App.js, it will be imported by index.js and then compiled within the index.html page. So, using separate files for each component simply makes this easier to keep organized as your code becomes more complex.
Use variables

Create a new variable called name, and feel free to assign it your own name. Then use it inside of your element variable. The end result of your code will look something like this:

import "./App.css";


function App() {

  const name = "Alice";

  const element = <p>Hello, {name}!</p>;


  return element;

}


export default App;

Save your file, and you'll see your new message within the browser.
Attributes

You can add attributes to JSX elements much like you can in HTML. For example, here's how you might create a link to the Thinkful home page using the attribute href:

<a href="https://www.thinkful.com/">Thinkful</a>

You can use variables in attributes as well. The code below, for example, stores the URL in one variable, the link text in another, and then creates a link tag.

function App() {

  const url = "https://www.thinkful.com/";

  const linkText = "Visit Thinkful";

  const element = <a href={url}>{linkText}</a>;


  return element;

}

Notice that you're using curly brackets {} around the url and linkText variables to insert them into the JSX expression.
Do this
Use a link

Now, create your own text links using the JSX element. Here's an example of how that might look:

const name = "Alice";

const url = "https://www.thinkful.com/";

const linkText = "Thinkful";

const element = (

  <p>

    {" "}

    Hey, {name}! Please visit <a href={url}>{linkText}</a>.

  </p>

);


return element;

Top-level JSX elements

The videos below provide overviews of parent elements and self-closing elements in React.

Note that a React component won't allow you to return more than one top-level JSX element. In other words, if you tried to return two top-level elements, as in the code below, you'd get an error when the file was saved and compiled.

const element = (

  <h1>Hello World!</h1>

  <h2>Have a good day.</h2>

);

return element;

The error when the code above is run would look similar to this:

Failed to compile.


SyntaxError: App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?

A simple solution is to create a single top-level JSX element that nests a number of elements, just as you would with HTML. Placing the two heading elements within a single <div> container follows the rules of JSX and allows you to add multiple JSX elements.

const element = (

  <div>

    <h1>Hello World!</h1>

    <h2>Have a good day.</h2>

  </div>

);

Or, if you want to avoid adding an unnecessary <div> container to the DOM, you can substitute the simple <div> container or a React fragment.

A React fragment is commonly written with short syntax, like this: <>...</>. It appears as empty tags (you may have noticed the suggestion in the error about using a JSX fragment <>...</>). Its sole purpose is to group elements that are next to each other. Using this is encouraged when you need to return multiple elements but you don't need a parent container, like a generic <div> container, to hold all the elements.

const element = (

  <>

    <h1>Hello World!</h1>

    <h2>Have a good day.</h2>

  </>

);

Do this
Create a React fragment

Create a JSX element that has multiple JSX elements of your choosing and is wrapped within a React fragment. It can be helpful to see what happens when it works, and it can also help to see the error message that displays when you have an error.

*** 21.6 Components and props
Components and props
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to define and render a functional component with props.
Overview

React components allow you to split your application into reusable pieces. You can create your own elements that are specific to your app. This enables you to factor the code into easy-to-understand pieces.
Key Terms

Functional component
    A JavaScript function that returns JSX
Prop
    An input passed into a React component as an object

Starter code

Reuse the existing React App or create a new app following the steps in the Create React App lesson earlier in this module. Make sure that you remove the unnecessary files and update the existing files with the appropriate code.
Defining components

The following video provides an overview of how to organize multiple React components. Start by watching the video, and then read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Although React allows you to define components with classes or functions, you have been using functional components in this module. A functional component is a function that returns JSX.

Here is an App component that displays a generic message in a <p> element:

function App() {

  return <p>Welcome back, valued customer!</p>;

}

You can render this component much like you would render any other element, as you already are doing in the index.js file when you are rendering this component:

<App />

As your App component gets more complex, you will find it helpful to break it up into smaller components. Rather than printing the welcome message within the App component, you could remove it and place that message into a new WelcomeBack component. And then within the App component, you can make use of the WelcomeBack component by calling it using <WelcomeBack />. This code provides the same outcome as before—it is just broken up into more than one functional component.

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return <WelcomeBack />;

}

By wrapping your returned element in a React fragment and using parentheses () to contain the multiple lines of code, you can make use of the WelcomeBack component as often as you want within the App component.

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return (

    <>

      <WelcomeBack />

      <WelcomeBack />

    </>

  );

}

Tip

Unlike vanilla JavaScript functions, React functional components begin with a capital letter (in the format WelcomeBack).
Do this
Create a new component

In your App.js file, include a WelcomeBack component with a message. Make use of it within the App component more than once.

import './App.css';


function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return (

    <WelcomeBack />

    <WelcomeBack />

  );

}


export default App;

You can return additional components from App as follows:

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function EncouragingWords() {

  return <p>Believe you can and you’re halfway there.</p>;

}


function DailyTip() {

  return <p>Highlight a whole paragraph by triple-clicking on it.</p>;

}


function App() {

  return (

    <>

      <WelcomeBack />

      <WelcomeBack />

      <EncouragingWords />

      <DailyTip />

    </>

  );

}

Then, start the React application. You will see your WelcomeBack, EncouragingWords, and DailyTip components appear on the screen.

For the remainder of this lesson, you won't need the EncouragingWords and DailyTip components, so feel free to remove them from the App component and just keep the WelcomeBack components inside of App.

Then, with the React application running on your local server, you will see your WelcomeBack components appear on the screen. If you don't, make sure that you have your files saved, refresh your browser, and restart the application if necessary.

import React from "react";

import ReactDOM from "react-dom";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

Defining a component with props

The video below provides an introduction to using React components with props.

Generally, calling the same component multiple times doesn't provide much value, unless you make your components customizable. Components can take arguments, called props, which you can use to customize the element. Props are inputs passed into a React component as an object. They allow for data to flow from one component down to its children components.

Below, the WelcomeBack component is redefined so that it makes use of the props parameter. Take a look:

function WelcomeBack(props) {

  return <p>Welcome back, {props.name}!</p>;

}

When rendering the component, you can specify the value of the name prop as follows:

<WelcomeBack name="Joe" />

This will result in the following being rendered to the page:

<p>Welcome back, Joe!</p>

You can also use argument destructuring to further simplify the function, like so:

function WelcomeBack({ name }) {

  return <p>Welcome back, {name}!</p>;

}

Below, the WelcomeBack component is rendered twice, with a different value for name each time:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

    </>

  );

}

This will result in the following being rendered to the page:

<p>Welcome back, Joe!</p>

<p>Welcome back, Anna!</p>

If no name property is passed in, then the component may look a bit odd, as shown below:

<WelcomeBack />

The above component will result in this:

<p>Welcome back, !</p>

So, in this case, you may want to set a default value for the property, like so:

function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}

Now, consider if you were to render this App component:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

      <WelcomeBack />

    </>

  );

}

The above component would display in the browser like this:

Welcome back, Joe! Welcome back, Anna! Welcome back, valued customer!

As your code gets more complex, you can assign multiple props separated by a comma ,. If you wish, you can also assign default values to each of the props, like this:

function WelcomeBack({ name = "valued customer", adjective = "nice" }) {

  return (

    <p>

      Welcome back, {adjective} {name}!

    </p>

  );

}


function App() {

  return (

    <>

      <WelcomeBack name="Joe" adjective="funny" />

      <WelcomeBack name="Anna" adjective="clever" />

      <WelcomeBack />

    </>

  );

}

Do this
Customize the component

Update your WelcomeBack component to use props, as detailed above. Then, add the name property as well as any other properties that you want to add to your WelcomeBack component used in the App component.
Component composition

Components are often made up of other components. This is called component composition.

Take a look at the following App component, which renders the WelcomeBack component twice:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

    </>

  );

}

In the code above, the App component returns an element (created within the <> fragments) with two components within it. Just like this App component, many of your components will have other components inside of them, too.
Component file structure

The video below provides an overview of how and why to separate React components into files.

As your components get more involved, it becomes important to break your code into multiple components. This makes your code more readable and easier to modify. It's standard to put each component in its own file; this makes it easier to navigate the code.

For the above example, where you have an App component that is composed of two WelcomeBack components, you could break the file up into two component files: App.js and WelcomeBack.js. And each JS file could have a corresponding CSS stylesheet that specifically styles the elements of that component. Typically, the CSS file will share the same name of the component to make it clearer which component the CSS file is supposed to be styling. You could even add Header and Footer components to this project.

Here is the full content of the four files:

// Header.js

import "./Header.css";


function Header() {

  return <h1>Header to the page.</h1>;

}


export default Header;

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}


export default WelcomeBack;

// Footer.js

import "./Footer.css";


function Footer() {

  return <h2>Footer to the page.</h2>;

}


export default Footer;

// App.js

import "./App.css";

import Header from "./Header";

import WelcomeBack from "./WelcomeBack";

import Footer from "./Footer";


function App() {

  return (

    <>

      <Header />

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

      <WelcomeBack />

      <Footer />

    </>

  );

}


export default App;

Note: You can also end your files with the .jsx extension instead of .js, and you may see both file extensions in this program. There is no difference between the two file extensions, although you should stick with one or the other in your own work.
Do this
Create a new file

Separate the WelcomeBack component into its own file, WelcomeBack.js. Follow the instructions above to connect the multiple files so that your work continues to show up. Feel free to add additional components, like Header and Footer, in their own files if you wish.

*** 21.7 Conditional rendering

Conditional rendering
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use if() and switch() statements to control the display of a component.
Overview

When you are working with direct DOM manipulation, you can set a message to only show if some condition is true. To accomplish that, you would need to check for that condition, and then hide or show elements based on the result. React is very similar. You can set your components to either display or not display, based on a value in JavaScript. In this lesson, you'll learn how to conditionally show certain elements to your users.
Starter code

Use the Create React App command-line program to create a new React application or reuse an existing React application. Give it a memorable name, like conditional-rendering. Then, follow the instructions in the Create React App lesson to remove unnecessary files.
The if() and switch() statements

Take a look at the Greeting component below, which takes language as a prop. It will display different text depending on the language.

// Greeting.js

function Greeting({ language }) {

  if (language === "es") {

    return <h1>Hola!</h1>;

  }

  return <h1>Hello!</h1>;

}

To see this difference in the app, you can use a Greeting component with the language as es (Spanish) and another Greeting component with no language specified (which defaults to English). Here's an example:

// App.js

function App() {

  return (

    <div>

      <Greeting language="es" />

      <Greeting />

    </div>

  );

}

You might prefer an inline if() statement in simple cases. Take a look:

// Greeting.js

function Greeting({ language }) {

  return <h1>{language === "es" ? "Hola" : "Hello"}!</h1>;

}

If you have more than two options, you can use a switch() statement, like this:

// Greeting.js

function Greeting({ language }) {

  switch (language) {

    case "es":

      return <h1>Hola!</h1>;

    case "fr":

      return <h1>Bonjour!</h1>;

    case "en":

    default:

      return <h1>Hello!</h1>;

  }

}

Do this
Create the Greeting component

Create a new Greeting component in its own file, Greeting.js. Include that component in the App.js file, and try setting up some conditionals so that you can see the difference.
Prevent rendering

Imagine that you are building an application that makes use of a number of notifications. If the user has notifications, you want to notify the user with a message. Otherwise, you want to display nothing.

With React, you can display nothing by returning null from a component, as shown here:

function Notifications({ notifications }) {

  if (notifications.length > 0) {

    return <p>You have {notifications.length} notifications today!</p>;

  }

  return null;

}


function App() {

  const notifications = ["You received a package", "The weather is sunny"];

  return <Notifications notifications={notifications} />;

}

Note that when the condition is relatively short, it can be useful to use the && operator instead of an if statement, as shown below. If the first value is true, the && operator will return the second value. If the first value is false, it will return the first value (false). When a component returns false, it renders nothing, just like it does if it returns null.

function Notifications({ notifications }) {

  return (

    notifications.length > 0 && (

      <p>You have {notifications.length} notifications today!</p>

    )

  );

}

*** 21.8 Lists and tables
Lists and tables
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will know how to use the map() method to display an array in a list or table.
Overview

Rendering lists and tables works slightly differently in React if those lists and tables are dependent on data. These differences aren't difficult to manage, but they're important to know about. This lesson will show you how to use lists and tables to create repeated elements in React.
Starter code

Use the Create React App command-line program to create a new React application or reuse an existing React application. Give it a memorable name, like lists-and-tables. Then, follow the instructions in the Create React App lesson to remove unnecessary files.
Lists

Imagine that you are creating an application that creates a grocery list for you. You may want to show your items in a list, like this:

<ul>

  <li>Bananas</li>

  <li>Apples</li>

  <li>Oranges</li>

</ul>

You may want to create this list based on an array, as shown below. This array may update or change based on the actions that you take in the application.

const groceryItems = ["Bananas", "Apples", "Oranges"];

You can use the map() method to create a <li> item for each item in groceryItems. Then, wrap it all with a <ul> tag. Take a look:

// GroceryList.js

function GroceryList({ items }) {

  return (

    <ul>

      {items.map((item) => (

        <li>{item}</li>

      ))}

    </ul>

  );

}

You can then use this component by passing groceryItems into it, like this:

<GroceryList items={groceryItems} />

This will lead to the same list that was originally shown—except now, you can easily change the list by updating the groceryItems array.
Rewriting lists

The code above is a bit complicated to read. Remember that JSX code can be assigned to a variable, like other JavaScript expressions. That means that the code below will work as well.

// GroceryList.js

function GroceryList({ items }) {

  const list = items.map((item) => <li>{item}</li>);

  return <ul>{list}</ul>;

}

There is no performance benefit to writing your code like this, but you may find it a bit easier to read.
Adding keys

If you look at the console for the above example, you will notice that you get a warning:

Warning: Each child in a list should have a unique 'key' prop.

React uses keys to help it update a list when the groceryList array changes. When you're creating a list, always give each list item a unique key. You can use item as the key if you know that it will be unique, but it is generally safer to use the list index or a unique ID.

So you can modify the code above as follows:

// GroceryList.js

function GroceryList({ items }) {

  const list = items.map((item, index) => <li key={index}>{item}</li>);

  return <ul>{list}</ul>;

}

Now, you can see that the warning message is gone.
Do this
Add a list

In your App.js file, create a todo array and include different to-do items inside of it. Then, render those items to a list in your App component.

An example solution is below. Try creating this on your own before looking at the solution!

import React from "react";


const todos = [

  "Finish the Lists & Tables checkpoint",

  "Clean my desk",

  "Make lunch",

];


function App() {

  const listItems = todos.map((todo, index) => <li key={index}>{todo}</li>);

  return <ul>{listItems}</ul>;

}


export default App;

Tables

Tables are useful for more complex information. For example, the grocery list created earlier could be built with more details, like this:

<table>

  <tr>

    <th>Quantity</th>

    <th>Item</th>

  </tr>

  <tr>

    <td>6</td>

    <td>Bananas</td>

  </tr>

  <tr>

    <td>3</td>

    <td>Apples</td>

  </tr>

  <tr>

    <td>10</td>

    <td>Oranges</td>

  </tr>

</table>

Instead of hardcoding the grocery list contents, you could have them stored like the array below:

const groceryList = [

  { quantity: 6, item: "Bananas" },

  { quantity: 3, item: "Apples" },

  { quantity: 10, item: "Oranges" },

];

When creating the table, you first add the header row, because that will be unchanged by the contents of groceryList. Then, you can use the map() method with groceryList to create a <tr> element for each row in the table. Like with lists, each row should have a unique key. Here's an example:

function GroceryList({ items }) {

  const rows = groceryList.map(({ quantity, item }, index) => (

    <tr key={index}>

      <td>{quantity}</td>

      <td>{item}</td>

    </tr>

  ));


  return (

    <table>

      <thead>

        <tr>

          <th>Quantity</th>

          <th>Item</th>

        </tr>

      </thead>

      <tbody>{rows}</tbody>

    </table>

  );

}

Do this
Update your to-do list

Update your todo array to be an array of objects with a description key and a completed key, like the example below:

const todos = [

  { completed: false, description: "Finish the Lists & Tables checkpoint" },

  { completed: false, description: "Clean my desk" },

  { completed: false, description: "Make lunch" },

];

Then, update your App.js to reflect the new data structure using a table. Try it out on your own at first, and then compare your work to the solution below.

import React from "react";


const todos = [

  { completed: false, description: "Finish the Lists & Tables checkpoint" },

  { completed: false, description: "Clean my desk" },

  { completed: false, description: "Make lunch" },

];


function App() {

  const rows = todos.map(({ completed, description }, index) => (

    <tr key={index}>

      <td>{description}</td>

      <td>{completed ? "Yes" : "No"}</td>

    </tr>

  ));


  return (

    <table>

      <thead>

        <tr>

          <th>Description</th>

          <th>Completed?</th>

        </tr>

      </thead>

      <tbody>{rows}</tbody>

    </table>

  );

}


export default App;

*** 21.9 Styling

Styling
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to style JSX with both external and inline CSS styles. You'll also be able to harness Bootstrap to improve your React presentations.
Overview

Working with CSS in React is very similar to working with CSS elsewhere. However, there are some particularities that are important to be aware of so that you can make the best use of your styles. So in this lesson, you'll explore the ins and outs of working with CSS in React.
Starter code

Reuse your existing React App. Or, if you wish, create a new app that follows all the steps listed in the Components and props lesson earlier in this module, following the instructions carefully in order to remove all unnecessary files and update the existing files with the code that you'll build on in this lesson.
Clearing your default CSS files

The existing CSS stylesheets that were originally created using the Create React App supplied various CSS rules in both the index.css and App.css files. Rather than explaining and updating all the prewritten styles, it's easier to simply delete all of the existing code in those two files.
Do this

Delete all the existing CSS styles from both the index.css and App.css files.
CSS Files with React

As explained in the Components and props lesson, as your application grows in size, it can help to break up each component. And when necessary, you may want to assign each component a corresponding CSS stylesheet with the same name to help identify the files that you'll also need to create.

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}


export default WelcomeBack;

// App.js

import "./App.css";

import WelcomeBack from "./WelcomeBack";


function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

    </>

  );

}


export default App;

// index.js

import React from "react";

import ReactDOM from "react-dom";

import "./index.css";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

In the above example, there are three JS files: index.js, App.js, and WelcomeBack.js. They each have a corresponding CSS stylesheet: index.css, App.css, and WelcomeBack.css, respectively. When the Create React App script created all of these files, the index.css and App.css were included. Because you manually created the WelcomeBack.js file, you also need to create the WelcomeBack.css file. And for each component file, consider adding the corresponding CSS file, too. This may seem like overkill at the moment because you don't have much content in the files, but this process can help reinforce your understanding of the relationships between all of these files.

Keep in mind that index.css is best used to contain all the global styles that affect the entire application. This includes all styles for general typography, including rules for the headings and paragraphs. The individual CSS files that have matching names to the components are necessary only when unique styles are needed for those particular components. If you aren't using unique styles for specific components, then you don't need to create and then link to empty CSS stylesheets for every component.
Adding CSS to external stylesheets

CSS works with JSX the same way that it does with HTML. When using CSS to target an element (like a p paragraph) or a class (like .username), you'll write the CSS within an external stylesheet exactly the same way that you would with HTML. Here are some examples:

/* WelcomeBack.css */

p {

  color: black;

  font-family: sans-serif;

}


.username {

  color: #fff;

  padding: 2px 4px;

  margin-right: 2px;

  background-color: #000;

  border-radius: 4px;

}

The first big difference in applying this CSS is that you cannot use a class attribute in JSX; you need to refer to that attribute as className. This is because class is a unique keyword in JavaScript. And because JSX is an extension of JS, using a class attribute can cause problems to occur when you compile your React app. Also, keep in mind that JSX always uses camelCase. So in JSX, the attribute is called className.

So, within the WelcomeBack.css file, the p style will be assigned to all paragraphs. When you want to apply the class .username, you can do so by applying it as className. And the <span> used in this example is just a simple JSX element; it's similar to a <div>, but it's an inline element—which means that it doesn't force the content onto a new line like a <div> container. That makes it perfect for styling a word or phrase within a paragraph slightly differently than the rest of the paragraph.

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return (

    <p>

      Welcome back, <span className="username">{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Inline styling

When you want to add specific styles to a particular element within a component and you don't feel that adding it to an external stylesheet is needed to help you keep your code organized, then you can add the CSS styles directly to the element within the component using inline styling.

To demonstrate an inline style added to the internal styles, the paragraph in the example below was wrapped within a <div> container. The <div> was then given specific styles that, in this case, probably wouldn't be applied anywhere else.

Note that there are also several small differences in how inline styles are written in JSX. The style attribute needs to be set to an object that contains the CSS properties that you want to set on the element. Within this object, two-word CSS properties need to be written in camelCase, like textAlign. And the values to the properties need to be passed as strings, so they need to be wrapped in quotation marks. Here's an example:

  return (

     <div style={{ border: "1px solid #000", textAlign: "center", borderRadius: "4px" }}>

       <p>Welcome back, {name}!</p>

     </div>

  )

}

If you have a few CSS rules, like in the WelcomeBack.css stylesheet that was imported into the WelcomeBack.js file earlier in this lesson, those rules can be applied to the JSX by storing the styles within variables and assigning the values of those variables to the inline styles. This is a great way to keep your inline styles more readable and organized.

Here is the WelcomeBack.js file updated with only inline styles:

// WelcomeBack.js

function WelcomeBack({ name = "valued customer" }) {

  const pStyle = {

    color: "black",

    fontFamily: "sans-serif",

  };

  const userName = {

    padding: "2px 4px",

    marginRight: "2px",

    backgroundColor: "#000",

    color: "#fff",

    borderRadius: "4px",

  };


  return (

    <p style={pStyle}>

      Welcome back, <span style={userName}>{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Because the code in the WelcomeBack.js file isn't linked to the WelcomeBack.css stylesheet, the import link to that CSS stylesheet can be removed.

The variable names pStyle and userName can be any variable name that you want.

Again, when you add this code and save the file, you will see the same styles applied to your content as before. Only now, they'll be applied as inline styles.
Adding Bootstrap

Previously, if you wanted to include an external stylesheet, you would place a link to it in the <head> element of the HTML. You can do the same thing in React.

For example, if you wanted to add the Bootstrap CDN to your React application, you would go into the public directory and add the Bootstrap stylesheet <link> to the <head> element of the index.html file. Bootstrap would then be included for your entire project.

Remember that you must use className instead of the class attribute. That means that if you copy a component over from Bootstrap, you will need to change all occurrences of class to be className.

For example, you can use the .card and .card-body classes to render the card component like this:

<div className="card">

  <div className="card-body">This is some text within a card body.</div>

</div>

Do this

First, add the Bootstrap stylesheet <link> to the <head> element of the index.html file.

Next, create a new React component that primarily uses Bootstrap for styling. Here, you will use a Bootstrap card. Specifically, you should use the Quote option under the Header and footer section.

In the src folder, create a new file called Quote.js. Add the following code:

function Quote({ quote: { text, author } }) {

  return (

    <div className="card">

      <div className="card-header">Quote of the Day</div>

      <div className="card-body">

        <blockquote className="blockquote">

          <p>{text}</p>

          <footer className="blockquote-footer">{author}</footer>

        </blockquote>

      </div>

    </div>

  );

}


export default Quote;

The Quote component accepts a prop called quote, which is an object containing text and author properties. Here, their values are extracted into the text and author variables using destructuring. The component simply returns JSX.

Remember that you must use className instead of the class attribute when adding a class to a React component.

Next, in App.js, import the Quote component and use it within the App component, like this:

import "./App.css";

import WelcomeBack from "./WelcomeBack";

import Quote from "./Quote";


const quote = {

  text:

    "I am great believer in luck, and I find the harder I work, the more I have of it.",

  author: "Thomas Jefferson",

};


function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <Quote quote={quote} />

    </>

  );

}


export default App;

The Quote component, which is styled with Bootstrap, is now displayed on the screen as follows:
Styled quote of the day

Note: If you need a refresher on other interesting features of Bootstrap, you can refer to the CSS frameworks module.
Adding Google Fonts

Google Fonts is a library of free and interesting font families that you can include in your project. There are several ways to incorporate Google Fonts into your project. One way is to include the <link> tag inside an HTML file, just like how you would include a regular stylesheet.
Do this
Add the Zen Dots font

Go ahead and add a font family called Zen Dots to the project. First, go to the Google Fonts website and look up Zen Dots using the search bar at the top-left corner of the page:
Zen Dots page on the Google Fonts web page

Click the Zen Dots card. Then, on the next page, click the + Select this style button:
Zen Dots page

A menu will slide out from the right. Under the Use on the web section, copy both of the provided <link> tags:
Use on the web options

The preconnect link tag speeds up the downloading of the font files, so it's important to include it.

In the index.html file within the public folder, paste the copied lines anywhere inside the <head> section.

Next, use the Zen Dots font family to style the paragraph tag inside the WelcomeBack component, like this:

function WelcomeBack({ name = "valued customer" }) {

  const pStyle = {

    color: "black",

-    fontFamily: "sans-serif",

+    fontFamily: "Zen Dots, cursive",

  };

  const userName = {

    padding: "2px 4px",

    marginRight: "2px",

    backgroundColor: "#000",

    color: "#fff",

    borderRadius: "4px",

  };


  return (

    <p style={pStyle}>

      Welcome back, <span style={userName}>{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Note that you're using cursive as a fallback font typeface here. If, for some reason, the Zen Dots doesn't load properly in your project, then React will use the default cursive typeface that's available on your computer's operating system.

Your WelcomeBack component should now look like this:
WelcomeBack component

*** 21.10 React testing
*** 21.11 Assessment: Rendering with React
** module 22 react state management
** module 24 react and apis with hooks
** module 25 react router
** module 26 frontend deployment
** module 29 careers: personal branding
* Backend Development - Modules 30-40
** Node and Express - Module 30
** Robust Server Structure - Module 31
** Project - Module 32
** Postgres- Module 33
** Creating Relations - Module 34
** Node, Express, and Postgres - Module 35
** Backend Deployment - Module 36
** Connecting it all - Module 37
** Mock Interview: Backend - Module 38
** Node and Express - Module 39
** Node and Express - Module 40
* Module 46 - Careers: Interviewing

** 46.1 - Understanding interviewing
** 46.2 - Mastering the soft skills of interviewing

Mastering the soft skills of interviewing
2 hoursEstimated completion time
Learning Objective
By the end of this lesson, you should be able to master the behavioral components of interviews.

Overview
Some things are universal to all interviews. You're always going to be asked about your background. You're always going to be asked about your salary requirements. And employers are always going to want you to be prepared and poised. Accordingly, there are some best practices that you should apply to all of your interviews. This lesson covers how to prepare for an interview, answer common interview questions, and follow up after an interview.

Key Terms
STAR method
An acronym that stands for situation-task-action-result, this approach is a straightforward and systematic way to answer behavioral questions
Preparing for interviews
Making a good impression at an interview starts with preparing for the interview before it happens. Some things you should do well in advance, and other things you should do on the day of the interview.

Before the interview
Before the interview, get prepared by conducting some research, rehearsing your answers to common interview questions, and making a list of questions that you want to ask the interviewers.

Researching the company
Employers appreciate candidates who are familiar with their company and work. Take some time to review the company's website and blog, as well as any recent articles about the company that you can find online. You should be able to explain the work that they do and why you're interested in working for them.

Researching your interviewers
Try to find out who's interviewing you and then check them out on LinkedIn. Look at their backgrounds and figure out how long they've been at the company and in their job. Look for things that you have in common or that you find interesting about them. Knowing a little about your interviewers can give you clues about the types of questions that you can expect them to ask, and help you know what questions you should ask them. It can even provide some conversation topics to bond over during the informal, in-between moments of an interview.

Reviewing the job listing
It might be a while between the time that you apply to a job and the time that you interview for that job. Always review the job listing so that you know exactly what the job is and what skills the employer is interested in. This will help you determine which relevant skills and projects you should highlight during the interview.

Preparing your answers to common interview questions
Although it's impossible to know the specific questions that you're going to be asked during an interview, there are common types of questions that arise in most interviews. For example, you're going to be asked about your past work experience, your projects, and your salary expectations. Think about how you want to answer these questions before the interview, so that you're ready to provide effective answers during the interview. Many of these common interview questions, plus strategies for answering them, are described below.

Preparing questions to ask during the interview
Interviews should be two-sided. While the employers are deciding if you're a good fit for their company, you're also trying to decide if the company and employers are a good fit for your life. This means that you should also come prepared with questions to ask the interviewers. Writing them down ahead of time and bringing them to the interview makes you look prepared. It also ensures that you won't forget to ask about anything that's important to you.

The day of the interview
On the day of the interview, there are some final considerations to keep in mind, from dressing appropriately to using nonverbal cues to your advantage.

Dressing the part
These days, many companies allow their employees to dress casually at work—although this differs by industry, company, and location. But as the person being interviewed, you want to make a good first impression and appear clean, polished, and professional. Here are a few guidelines to follow:

Be the best-dressed person in the room: Aim to dress one step more formal than the interviewers. For example, if they're wearing jeans and a t-shirt, you should be wearing jeans and a button-up shirt. Your goal is to fit in, so you look like a culture match, but also to show professionalism and convey that you take the interview seriously.

Be tidy: Whatever you wear, make sure that you and your outfit are clean. Your hair and teeth should be brushed, and your clothes should be pressed and without holes or stains.

Be comfortable: You should look professional and you should be physically comfortable so that your clothing doesn't distract you. So make sure to wear clothing that's easy to move in and doesn't require frequent adjustments.

Be fabulous: Wear something that you like. When you feel good about the way that you look, you have more confidence. This makes you appear more competent and sets you up for a better interview.

Arriving on time
Be on time for the interview. Punctuality shows employers that you take the job, their time, and yourself seriously. It also gives you time to steady your nerves. Here are good rules to follow:

For phone screens: Pick up the phone after the first or second ring.

For virtual interviews: Join the meeting room five minutes before the interview. Ensure that all of your technology is functioning correctly.

For onsite interviews: Arrive at the site of the interview 10 minutes early, and plan for traffic and parking. Don't arrive more than 15 minutes early, because the interviewer is probably busy and this can be annoying for the person who then needs to accommodate you.

Being present
Before your interview, make sure that your mobile phone and other gadgets are silenced or powered off. A buzzing phone during an interview can be distracting and can make you appear careless.

Monitoring your nonverbal behavior
In addition to your verbal answers, interviews are also paying attention to your nonverbal behavior during interviews. Here are a few things to keep in mind during your interview:

Maintain upright posture. Sit up straight and roll your shoulders back. This communicates confidence and competence.

Face the interviewer with your body. This communicates that you're interested in the interviewer and invested in the conversation.

Uncross your arms. Open posture communicates that you're friendly and trustworthy.

Be still. Try not to fidget, swivel, or tap your fingers or feet. This communicates nervousness and can distract the interviewer.

Maintain eye contact. It's okay to blink, but you should look at your interviewers when you're answering questions, and especially when they're talking. This communicates that you're listening and engaged.

Keeping calm
Interviewing can be stressful. It's important to know some techniques that can help you stay calm in a stressful environment. For example, you could try striking a power pose, listening to a fun playlist, or practicing breathing exercises before your interview. And, ultimately, remember that some interviews are meant to test your knowledge—so it's okay if you don't know the answer to every question.

Asking questions
In most interviews, you are asked if you have any questions for your interviewers. Your answer should always be yes. Asking thoughtful questions is a good way for you to learn more about the company, and it's also a way for you to show your interest in the company and connect with your interviewers. In general, it's good to ask a couple of questions about the job, a couple of questions about the team that you'd be working with, and a couple of questions about the company's work culture. Here's a list of questions that you can ask your interviewers; of course, it's okay to write your own too.

Answering common questions
Even though every interview is different, there are some questions that you should always be prepared to answer. These are covered below.

Tell me about yourself
This is often the logical first question that you're asked during an interview. It helps the interviewer get to know you and establishes what follow-up questions they should ask you during the rest of the interview.

Your response should always include these components:

Your desired profession.

How your background connects you to your desired profession. Most employers want to know why you're changing careers, so it helps to briefly explain how your background led you to where you are today. This also gives you an opportunity to highlight relevant experience that the employer may have not realized.

How you're qualified for your desired profession. Highlight all of your relevant education and experience (like Thinkful!) and transferrable skills. Make it clear that you have the skills that you need to do the job. Include any skills that you have that are on the job listing.

Here's an example:

My name is Emet, and I'm a project manager. I started out as an instructional designer, which includes a lot of project management. In addition to developing curriculum, I was responsible for making sure that my projects were delivered on time, and I was managing subject matter experts' tasks and schedules. The project management part of the work has always been my favorite part of the job, so I decided that it was time to transition fully to project management. To make sure that I have all of the skills that I need, I recently completed a certificate program in project management. In this program, I learned how to plan, schedule, and budget for business projects; use project management tools; and create project summary reports. I also learned how to handle the less technical aspects of the job, like resolving conflicts and motivating people to complete work on time.

Everything in your answer should be relevant to the job that you're applying to; there's no need to tell your life story. Additionally, aim to keep your answer concise, about one to two minutes long.

How many years of experience do you have?
This question comes up a lot during phone screens. Employers try to get quick facts that help them decide if they should keep you in—or filter you out of—the interview process.

In your response, be honest and provide a specific length of time, but don’t diminish the time that you spent studying or using relevant skills in past jobs. That counts! Here's an example:

Collectively, I have two years of experience in web development. Most recently I completed a program at Thinkful where I worked alongside engineers in a fast-paced educational setting. During this six-month intensive, I built web applications from the ground up and really honed my skills in pair programming, troubleshooting, and quality assurance. Additionally, in my previous role as a Data Analyst, I built various tools using HTML and CSS to improve team operations.

Why do you want to work here?
Employers like to hire people who are excited about their company and work, as opposed to people who just want a paycheck and will take any job. So, to gauge your level of interest and check if you've done your homework, they might ask why you want to work at their company or what you know about their company.

From your research before the interview, you should have an answer ready. Identify something specific that you like about the company's values, projects, or people. Show genuine interest without being salesy. Here's an example:

While I understand the need to make a profit, it's important to me to work for a company that's also a benefit to society. Being able to see is clearly a benefit to society, and I like that you're going above and beyond with charitable work by donating a pair of prescription lenses for every pair of glasses that you sell. Also, everyone who I've chatted with so far seems happy to work here.

What are you looking for?
At some point, you're probably going to be asked about the type of job that you want now or in the future. Like the question above, this helps employers gauge if their company and job opening are right for you. Your answer should include the specific titles that interest you, the industries that interest you, and the locations that interest you. Ideally, your stated interests will match the title, industry, and location of the job that you're interviewing for. For example, you could tell them that you're interested in a social media marketing role at a tech company in Portland.

If you're asked about your long-term career goals, the employer might be trying to find out how long you plan to stay in the job if you get hired. Is it a job that you're excited about having for a while, or is it just a way to make money until you can find something that you truly want? Of course, the employer wants to hire someone who wants to stay awhile, so that they don't need to rehire for the job in a few months. When answering this question, you should emphasize that, although you're open to opportunities for growth or mentorship in the future, you're currently happy learning as much as you can in the type of job that you're interviewing for.

Tell me about your past projects
Employers often ask you questions about your past work or projects. This helps them gauge how transferable your experience is and assess your ability to communicate concepts and processes.

This is an opportunity for you to bring up facts that show off your skills. Start with an overview of your project, then get into specifics. Focus on your specific contributions, how you solved problems, and your results. Here's an example:

At Thinkful, I completed a variety of projects. Some were group projects so that we could mimic a team workplace environment, some involved pair programming with senior engineers, and some were individual projects. For my capstone project, I developed a web app that helps users plan road trips with scheduled stops. Whatever route the user chooses, the app provides weather forecasts and suggests food and lodging options. This was built using JavaScript, Angular, Node, Express, HTML, CSS, and the Google Directions and Places APIs. Most of that, I learned at Thinkful, but I actually taught myself Angular while I was developing the app.

What are your weaknesses?
When interviewers ask you about your weaknesses, it's probably for two reasons: They want to know what your weaknesses are in case they disqualify you from the job. And they want to know if you're self-aware and able to turn your weaknesses into strengths.

In your answer, you should provide a real weakness, but you should make sure to choose a weakness that won't disqualify you from the job. You should also say what you're doing to improve upon that weakness. Here's an example:

Though I've never missed a deadline, in the past, I've struggled with staying organized. I recently started adding every single thing on my to-do list to a Google calendar, which has made a huge difference. I'm also teaching myself how to use Kanban boards and project management software, like Asana.

What are your salary requirements?
Employers don't want to commit to a candidate who they can't afford. By asking you about your salary requirements, they can avoid getting excited about you if you're out of their range.

Your goal, on the other hand, is to set yourself up for the best possible offer and continue the conversation. To make sure that you're not overselling or underselling yourself, try to have the interviewer be the first person to provide a number or range. You can do this by redirecting the question. You'll learn more about how to navigate this process later in this module, but for now, here are a couple of examples:

Good question. I think I need to learn a bit more about this job before I'm able to give you a specific number. Is there a range that you have in mind?

I haven't yet had a chance to dig into the market rate and general salary for other folks at Netflix with my experience, but if you have a range that you can share, I'll be happy to compare that to my research. Otherwise, I trust that if I'm a fit, the salary will be aligned with my experience.

Alternatively, you can say that you're flexible as long as the offer is fair. Here's an example:

I'm open to any compensation that's externally competitive and internally fair.

In case you're required to provide a number, do some research before your interview. You can talk to others in your field, ask your career coach, and check out sites like Glassdoor to learn about average salaries for similar jobs. This allows you to provide a number that's backed up by data, rather than personal interest. Even so, you should still appear flexible. Here's an example:

Based on my research, it looks like the average base salary for data scientists in Seattle is $110K. Is that higher or lower than what you have in mind?

Answering behavioral questions
In addition to the questions described above, there's also a common type of interview question that you should be aware of: behavioral questions. These questions are asked to determine how you might behave in a particular situation (hence behavioral questions).

To determine how you might behave, interviewers ask you either about your past experience in a given situation or how you would respond in a hypothetical situation. Here are some examples:

Tell me about a time when you disagreed with your boss.

What do you do when you disagree with your boss?

What would you do if you disagreed with your boss?

No matter the question or phrasing, you should answer all behavioral questions using the STAR method.

Using the STAR method
The STAR method is a straightforward and systematic way to answer behavioral questions. It follows the acronym STAR, which stands for "situation, task, action, and result." Here's how the method works:

Situation: First, provide context by describing a similar situation that you were in; this usually involves a problem or conflict.

Task: Describe your specific tasks or role in the situation.

Action: Describe the action that you took to move the situation toward a result.

Result: Describe the result of your actions and how the situation resolved. This should be positive and, ideally, quantifiable. You can also share any lessons that you learned, in case you would do something differently the next time that you're in a similar situation.

Here's an example:

As part of a team of five people in a marketing firm, I was working with a new client who wanted to improve their online presence and get more website traffic. I was tasked with collaborating with the contracted designer to help with the designs and make sure that we were reaching a wider audience. Together with the designer, I was able to get their website updated with better UX/UI. I also updated their mobile site on iOS and Android to reach a wider market of users. Within the first month, we increased their overall user traffic by 33%, and it increased week-over-week by 5% for the remainder of the quarter.

Talking about your projects
There is an infinite number of behavioral questions that interviewers can ask, but they tend to fall within one of these categories:

How you work in stressful situations

How you respond when you fail

How you handle conflict with other people

How you motivate yourself and others

How you make decisions

How your work has made a positive impact

How you build relationships with or manage stakeholders

Before the interview, think of situations from your past that you can refer to for each category. Ideally, think about the ways that you can answer these questions with your Thinkful education; consider your projects, group assignments, or interactions with your mentor and classmates. This allows you to answer the interviewer's questions and remind them of your relevant skills and experience. This is particularly important if you don't have prior experience in the field or are struggling to think of transferable examples.

Take a moment to reflect on one of your recent Thinkful projects and answer these questions:

What was the hardest thing about your project, and what did you do to overcome it?

How did you exceed the project requirements, and what impact did that have on the project or your overall growth in the field?

What was the biggest mistake that you made while working on your project? What did you learn, and what would you do differently next time?

What aspect of your project are you most proud of and why?

Take that information and use the STAR format to answer the following prompt: Tell me about a challenging project that you worked on.

Following up after interviews
You might assume that the interview is over once you hang up or leave, but that's incorrect. After every interview, you should follow up—both to thank the interviewer and to stay updated about next steps.

Following up to thank the interviewers
Send a follow-up thank-you email within 24 hours of your interview.

Your thank-you message should include the following:

Gratitude

Excitement about the job

Something specific about the conversation that you had that pertains to the job and your experience

An invitation to contact you if the interviewer has additional questions

Enthusiasm about the next step in the interview process

Here's an example:

Riley,

Thank you so much for taking time out of your day to interview me. I had a great time talking to you and was especially excited to hear about your team's mentorship opportunities.

I'm looking forward to chatting with the rest of your team next week. Until then, if you have additional questions, don't hesitate to reach out!

Cheers,

Will

If you don't have the interviewer's contact information, you can ask the person who organized your interview if they're willing to forward your message. In the case that multiple people interview you, you can either send individual messages or one group message.

Following up when you don't get a response
Sometimes employers get busy and forget to follow up with you. Don't take it personally. Instead, be proactive and follow up with them. At the end of an interview or in your follow-up thank-you email, you should always ask what and when the next step of the interview process is. That way, if you don't hear from the employer by the date and time that they stated, you can follow up.

Allow yourself two check-ins for every step of the interview process. And leave about five business days between each of those check-ins. If the employer doesn't respond after the second check-in, move on to the next opportunity.

It's generally best practice to follow up via email with your recruiting contact or the last person who you interviewed with. Keep your follow-up short and professional. Don't make assumptions and don't indicate any anger or frustration; there's probably a good reason why they haven't gotten back to you. Here's an example of an appropriate follow-up email:

Hello, Reagan!

I hope that this message finds you well. I wanted to touch base about the cybersecurity role that I interviewed for last week—both to express my continued excitement about the opportunity and to ask if you've made a decision about next steps.

Thanks again for your time and consideration.

Regards,

Malia

Follow all of the tips in this lesson, and you're sure to make a good impression—one that may even lead to a job offer.

Supplementary resources
Practice behavioral interview questions

Sample questions to ask during an interview

The STAR method worksheet

Answering "Tell me about yourself" questions

** 46.3 - Engineering and web development interviews

Engineering and web development interviews
1 hourEstimated completion time
Learning Objective
By the end of this lesson, you should be able to prepare for a software engineering interview.

Interviewing for a software engineering role or a similar role can vary widely depending on the company, the industry, and the specific responsibilities of the role. An interview for a full-stack engineer, for example, will likely be different from an interview for a frontend web developer.

Nevertheless, there are still some common steps to the interview process. When you begin an interview process for a technical role, you will likely encounter many of the following steps:

Application process

Take-home challenge

Technical and culture-fit phone screen

Onsite coding or whiteboard challenge

These steps are described next, including any variations that you may encounter.

Application process
The first step in the interview process is actually applying to the role. What is required for the role will differ, but you will often need to include the following information:

A resume

A cover letter

Your GitHub profile

Your personal website

Depending on the application process, you may be able to apply using the information that you have on LinkedIn.

Take-home challenge
Sometimes, you will be given a take-home challenge before moving on to the next step of the process—even before you speak with anyone in person or over the phone. If you encounter this, the company is probably attempting to filter out applicants. You may also receive a take-home challenge after completing a phone screen.

Take-home challenges can vary considerably in terms of difficulty and length. All of the following examples are possible:

You are given a web application to build with limited functionality and particular constraints. For example, you must build a website that filters movies based on a search string in the URL. (An example project is included at the end of this lesson.)

You are given a small set of coding challenges to solve. (Examples of these kinds of questions are included at the end of this lesson.)

You are given a bug to fix on an existing codebase or are asked to review existing code and give your opinion.

Typically, the process will look like this:

You will receive an email admitting you to the next step of the interview process. The hiring manager provides instructions and a deadline. They also specify how to submit the problem.

You will work on completing the problem according to the instructions. If it is a project, you will likely develop the project on your own machine before sending them a GitHub link or zip file. If it is a coding challenge, you will likely complete the problem on an external website.

Once your submission has been reviewed, you will be notified of whether or not you are being moved to the next step of the process.

As soon as you receive the email with the deadline, check your calendar and make certain that you believe that you have enough time to complete the problem. If you have something important coming up, do not hesitate to ask for a modest extension.

Technical and cultural phone screen
This step of the process typically involves a mixture of casual questions, technical questions, and possibly some live coding. If more than a conversation is required, the interviewer should let you know up front what is expected of you.

Either way, you may want to ask if there's anything in particular that you should be prepared to discuss.

Casual questions
During this part of the interview, you will likely be asked generic interview questions, such as the following:

Tell me about yourself.

Why did you decide to become a web developer?

Tell me about your past experiences.

Prepare for these kinds of basic biographical questions ahead of time so that you do not stumble while describing yourself or your past experiences.

Technical questions
During this part of the interview, the interviewer will ask you generic coding questions about languages that you know or high-level concepts. They may also ask you more specific questions about projects that you've completed that are showcased on your GitHub or portfolio website.

If you previously completed a coding challenge of some sort, they may ask you questions specifically about that coding challenge.

Generic coding questions
If the interviewer decides to ask you general questions about coding, the topics can range from the abstract to the highly specific. Here are a few example questions:

What is one of your favorite parts of JavaScript?

Describe the process that happens when you perform a search on Google. In your answer, refer to DNS, browsers, servers, and databases.

What is a closure?

What are the four pillars of object-oriented programming?

What are global variables?

A Google search for JavaScript interview questions will provide you with more than enough questions to look up.

Specific coding questions
Your interviewer may also ask you questions about your code or about code that they gave you ahead of time.

To prepare for these kinds of questions, make sure that you are familiar with your own code. It is also helpful to have written comments for your code, especially if it is something particularly complex. Make sure that you are comfortable explaining what your code is doing as well as how it is doing it.

Here are some examples:

I see that you have testing in your projects. Do you find testing useful while developing an application? Why or why not?

In your capstone project, you enabled CORS. Can you describe what the CORS package is doing and what CORS is?

In your capstone project, you made use of a complex component structure. Can you describe how you structured your project to manage state?

Live coding
If the interviewer has you do some live coding, they will likely have you use a platform that lets them see or share your screen. Hopefully, the interviewer will give you some idea ahead of time about what kind of problem you will be solving.

During a situation like this, remain calm and ask questions if you get confused. Treat this like a pairing session, where the interviewer is your partner. Although you will be driving the experience, it is common to forget some syntax or need to clarify some of the requirements.

Onsite technical challenge or whiteboard interview
If you are brought in to do a technical interview in person, it is likely that you may be asked some of the same coding questions described earlier. You may also be asked to either complete a technical challenge with a member of the engineering team or solve a challenge in front of engineering team members.

The number of people who you interact with really depends on the size of the company and the engineering team. You may speak with just one or two people throughout your experience, or you may meet with an entire team.

Coding challenge
If you end up pairing with another member of the team, you will likely be solving a small problem with the help of the team member. The team member will often introduce the codebase and the problem, and then the two of you will work together.

Often, this style of interview is as much about solving the problem as it is about how you ask questions and work with the other developer. During this process, you want to use technical language and ask questions about why and how the code works. Usually, you'll be free to look up syntax issues, just as you would while normally developing.

Whiteboard interview
A whiteboard challenge is a classic interview component for software engineering roles. In recent years, this practice's usefulness has been questioned. However, it is still likely that you will be asked to complete one of these challenges.

A whiteboard question will require that you solve an algorithmic problem without the use of a computer. Typically, you'll be standing up at a whiteboard, marker in hand, in front of one or two developers. This is often challenging for a few reasons:

You likely rely on your code editor to fill in the blanks for syntax and methods that you don't know. During a whiteboard interview, you will need to recall that information from memory.

The problem that you will be given may be conceptually difficult and possibly require you to find an optimal solution. These kinds of problems are difficult on their own, even with a computer.

Standing up and talking about code while you write it is difficult!

To prepare yourself for a whiteboard interview, practice solving coding challenges without the use of a computer. As you practice, talk out loud and write the problem down on a sheet of paper or a whiteboard, if you have one. Try to emulate the experience as best as you can.

Example whiteboard questions are included in the following section.

Example coding project
Expectations of take-home exercise
The goal of this exercise is to demonstrate your ability and knowledge around building full-stack web applications. We want to see what kind of choices you make in terms of both the visual design and the architectural design.

This exercise should take you around four hours to complete. Please feel free to ask us questions ahead of time to clarify requirements or discuss the due date if it does not work for you.

Deliverable
In this exercise, you will be building a simple website that organizes homes for sale. Your website should have the following features:

Display all homes on a single page, where only the image, price, address, and registration date are shown.

Sort homes by price and registration date, both ascending and descending.

Click a home to see more information, including the real estate agent details and a brief description.

A button on the home page should let any user add a new home through a form. All information is required.

The home data should be stored in a persistent storage solution. To start, you should include the following data: homes.json.

Technical constraints
You are welcome to build this project using whatever stack you prefer. Please keep in mind that you must do the following:

You must include a persistent storage solution for your application.

You must deploy your application to the web so that we may access it.

Outside of that, have fun with your stack—but be ready to defend your decisions!

Submission details
When you are done, please respond to this email with a link to your deployed application and your GitHub. In your GitHub repository's README, please include instructions on how to install and run your application.

Code challenge resources
There are numerous websites that will help you practice small but difficult problems. These kinds of problems could show up during a code screen or during a whiteboard interview. The following are just a few:

HackerRank
Exercism.io
Codewars
LeetCode
CodeSignal

** 46.4 - Negotiating

Negotiating
1 hourEstimated completion time
Learning Objective
By the end of this lesson, you should be able to negotiate a job offer effectively.

Overview
All job offers present the opportunity to negotiate. A good negotiation, however—one that results in a happy outcome for you and the employer—requires research, planning, and the right attitude. This lesson teaches you the right way to negotiate, beginning with why and when you should.

Key Terms
Fair market value
The amount of money that employers generally pay someone with your skills for a specific task
Why and when you should negotiate
Negotiation can be uncomfortable and, therefore, tempting to skip. But often, a few awkward minutes are worth the long-term benefits of asking for more. This section details why and when it's a good time to negotiate.

Why you should negotiate
There are lots of good reasons to negotiate an initial offer. Here are four reasons that usually apply:

You deserve to be paid your fair market value. This is the amount that employers generally pay someone with your skills for a specific task. As such, your compensation should be based on your fair market value. Not your previous salary. Not a company's income. Not more. Not less. If your initial offer is below your fair market value, you may be able to correct this through negotiation.

Employers expect you to negotiate. Negotiating is common practice. Employers aren't surprised or offended when you try to negotiate. Because employers expect you to negotiate, they often initially offer you less than they are willing to pay you. They probably expect to pay you more than their initial offer.

Asking for a fair salary communicates your value. If you go to the store to purchase a microwave, you naturally assume that the most expensive microwave is also the highest quality and the least expensive microwave is the lowest quality. The same is true of how employers view you. If you don't contend for a salary that aligns with your fair market value, employers might wrongly view you as less skilled than you actually are.

Your base salary influences your future earnings. If you hope to work at the same company for a long time, your future raises and bonuses are generally based on the base salary that you start with. For that reason, negotiate the highest base salary that you can. That can amount to a difference of hundreds of thousands of dollars over the span of your career.

When you should negotiate
Negotiating is a good idea in most scenarios, but not all. Below are some guidelines to follow regarding when you should and shouldn't try to negotiate.

Negotiate after you receive an offer. The best time to discuss compensation is after you receive a job offer. This is when you have the most leverage, because you're certain that the employer wants to hire you more than every other candidate who they interviewed. If an employer wants to hire you, they're more likely to be flexible when discussing compensation, because they want to ensure that you accept their offer.

Negotiate when the offer is below your fair market value. As stated previously, you deserve to be paid your fair market value. If the offer is less, you have an objective reason to ask for more, and you should.

Negotiate when you won't accept the current offer. If the offer is below what you're willing to accept, then you have nothing to lose. If you negotiate, the company might agree to pay you an amount that you're happy with. And if they aren't flexible, at least you asked.

Refrain from negotiating when the employer says that you're receiving their best offer. When an employer says that you're receiving their best offer, they might be bluffing. But it's also possible that they're telling you the truth and giving you their best offer to show you how valuable you are to their team. If you try to negotiate, you might seem unappreciative or insensitive to the company's budget, and it's possible that the employer will rescind the offer. Generally, only try to negotiate in this circumstance if you won't accept the position unless the offer increases.

Refrain from negotiating when you have no justification. In the event that an employer makes you an offer that is well above your fair market value, it may be pointless to negotiate, because you have nothing to justify asking for more.

The eight steps of negotiation
No matter how big or small the compensation package is, the following eight steps are a great road map to follow when negotiating a job offer. You should follow the first two steps before you receive an offer and the last six steps after you receive an offer.

Before receiving an offer
When you're considering buying a particular home, it's smart to compare it to other houses in the area, so that you know that the seller is requesting a fair price. It's also helpful to inspect the house so that you know that it has all of the features that are important to you (three bedrooms, a fenced backyard, and so on).

The same is true of job offers. To ensure that you receive a fair offer that has all of the components that matter most to you, you first need to research what a fair offer is. Then, take some time to think about what benefits you value most.

Step 1: Determine your fair market value
Always bring data to a negotiation. In particular, know your fair market value. This is an objective number that's provided by external sources; therefore, it's difficult for an employer to disagree with.

When determining your fair market value, choose a number that is ambitious but not impossible. There is always a range, so aim for a base salary that is at or above the average salary within that range. For example, if the range of compensation is $30,000-$50,000, and the average salary is $41,000, aim for a salary that is between $41,000 and $50,000.

Here are three ways that you can determine your fair market value.

Check Glassdoor

Glassdoor is an excellent resource for determining your fair market value. Start by going to Glassdoor's website.

In the text boxes at the top, list the job title and location of the job that you're considering and select Salaries from the drop-down list. This will return a page that shows you the range of salaries and the average salary that employers in that location pay for the job that you listed.

Conduct an informational interview

Because salary ranges differ by company, it's helpful to talk to an employee of the exact company that you're interviewing at. If you have the opportunity, you can ask that employee if they know the expected salary range for the role that you're seeking.

For example, you could ask, "If offered a job here for the data analytics associate role, what salary should I try to negotiate?" This should happen during a casual conversation or informational interview, not an actual job interview.

Ask your career coach

Your career coach dutifully tracks the employment details of all Thinkful graduates they work with, including base salaries. If another Thinkful graduate has already been hired at the company that you're interviewing at, your career coach might know the salary range that the company is willing to entertain.

Step 2: Familiarize yourself with the components of an offer
Compensation is more than just the base salary. When considering a job offer, you should weigh all of the monetary gains, the future potential that the job would provide you with, and how happy it would make you on a day-to-day basis.

Monetary gains

Base salary is just the tip of the iceberg. Monetary compensation generally includes healthcare and a retirement plan.

Sometimes, it also includes a signing bonus, annual pay increases written into the contract, and equity or stock options. It may also include various other perks, like a bus pass, meals, a gym membership, or continuing education funds.

Future potential

Your next job might not be your dream job—but, ideally, it will lead you to your dream job. Consider how the job title and responsibilities will look on your resume to a future employer, and see if there are opportunities for mentorship and growth within the company.

Happiness

It's the small, day-to-day details and interactions that either provide you with job satisfaction or make you resent going to work. These details comprise the people who you work with, including the company's leadership as well as your direct managers and coworkers.

Other important factors include the number of hours that you're expected to work each day, as well as the type of work that you're assigned. You also want to consider the environment that you get to work in, and the length of your commute. It also involves other details that matter to you personally, like the ability to work from home or bring your pet to work.

Take some time to think about which offer components are most important to you—and which ones you're willing to compromise on.

Upon receiving an offer
Surely, the happiest part of a job search is receiving an offer. Should you choose to negotiate, you can use the following steps as a guide.

Step 3: Take a step back
Upon receiving an offer—even a good one—it's best to take a step back. Don't accept or reject the offer immediately. Instead, warmly but neutrally thank the employer, ask for a written version of the complete compensation package, and ask for time to look it over.

The amount of time that you ask for is up to you. If you're actively interviewing at other companies and expecting more offers, it might be good to ask for a week. This way, the other companies will have the chance to finish interviewing you and make you an offer. If you're confident that you want to accept this offer, no matter the result, you might only need a day.

For example, you could say, "I appreciate the offer! Are you able to email me a copy of the entire Employee Agreement? I'd love to have a couple of days to look it over and make a decision."

Or you could say, "Thank you! I'm glad to hear that you want me on the team; I really enjoyed talking to everyone last week! Can you email me the offer details? If possible, I'd like to discuss this at home and get back to you next week."

Step 4: Strategize
With the full details of a job offer in front of you, it's time to strategize your negotiation. In this step, you should review the offer, determine what you would like to negotiate, gather supporting data, and rehearse your talking points.

Assess and plan

First, write down what the offer includes and what changes you want to see. Is the base salary aligned with your fair market value? Can you ask for more based on your prior experience or education?

Does the job title accurately reflect the responsibilities? Is there a retirement plan? How much time off is included? What else?

When you're determining a base salary and benefits to ask for, it's helpful to ask for more than you want. (Remember: You want your salary ask to be ambitious, but not impossible.) Why? Because the employer may try to negotiate down, but also because the employer might give you exactly what you ask for.

Gather data

Whatever you decide to ask for, have data that supports your request.

If you ask for a higher base salary, you should be able to point to an outside source, like Glassdoor, that demonstrates your counteroffer's reasonableness. Or, if you ask for a different title, you should be able to show the employer other job descriptions that show why your title makes more sense.

And if you ask for a higher base salary to compensate for a lack of healthcare, you should have the math ready that shows exactly how much you will need to pay for healthcare out of pocket each year. And so on.

Have these notes on hand so that you can refer to them if necessary.

Practice

It might feel silly, but you should practice negotiating aloud. This helps you get the wording and tone right, and it makes it easier to follow through when you're talking to the employer.

Rehearse how you're going to start the negotiation, what you're going to ask for, and what you're going to say if the employer responds favorably or negatively to your requests. You may also benefit from writing out a script or talking points that you can refer to.

Practice speaking in a tone that is warm but neutral. Your tone should not be aggressive, because this can sour the relationship between you and your new employer. Conversely, you shouldn't seem overly excited about the offer; the employer won't feel the need to negotiate if they're sure that you're going to accept either way.

Step 5: Schedule a time to reconnect with the employer
The day before you said that you would reconnect with the employer (or earlier, if you're ready), email the employer to request a time to discuss the compensation package over the phone.

Don't negotiate over email. It's easier for an employer to say no to a computer than a human who they're actively talking to, and email creates an opportunity for tone to be misinterpreted.

Here's an example of an email that you could use to request a phone call:

Hi, Sabine,

I'm excited about the offer and was wondering if you have some time tomorrow to discuss a few questions that I have.

I look forward to speaking with you!

Best,

Darnell

Step 6: Negotiate
It's time!

After you greet the employer (remember that your tone should be warm and neutral), begin the negotiation by naming the items that you would like to negotiate. Indicate which items are most important to you and provide data to support your case. This is better than negotiating each item one at a time, as the employer can lose patience and generosity the longer that it goes on.

Here's an example:

Hi! How is your day going so far?

So, I had a chance to look at the offer and I have a couple of questions. I'm wondering how flexible the base salary is and if it's possible to increase the signing bonus. Base salary is most important to me. After doing some research, I saw that the average salary for this role in San Francisco is closer to $100,000.

Now, wait. Let the employer speak next.

The employer will likely do one of three things: they will improve the offer, they will say that they need to ask a manager for approval and will get back to you later, or they will say that they're unable to change the offer.

If the employer isn't willing to negotiate one or all parts of the offer, don't try to negotiate a second time; it's unlikely that they'll change their mind. If you try to negotiate again, the employer might rescind the job offer altogether, because they won't want to hire an employee who seems unhappy with their compensation from the start.

Step 7: Take another step back and assess the new offer
If the employer gives you everything that you've asked for, you can skip to step eight. Otherwise, thank the employer for their willingness to listen and consider your amendments, and ask for an additional day to consider the new offer. The offer might be the same, but now it's official and final.

You might already be leaning toward accepting or rejecting the offer, but it's a good practice to never make big life decisions on the spot. You might change your mind.

You can say, for example, "Thanks so much! I'm going to run this by my partner one more time and will get back to you with an official response tomorrow morning, if that's OK."

Step 8: Accept or decline the offer
After considering the final offer, it's time to make a decision.

If you choose to accept the offer, congratulations! You can email or call the employer and tell them that you accept and are thrilled to begin working with them.

If you choose to reject the offer, remain kind and professional, even if you're frustrated. Why? The world is small; you might cross paths with the employer at another company in the future or at a local meetup.

Also, remember that you represent Thinkful and your other classmates. So, conduct yourself professionally so that the employer is willing to work with other Thinkful alumni who want the offer that you rejected. You can even consider recommending a classmate for the role.

Here's an example:

I really appreciate you and the team taking time to get to know me. While I'm a big fan of your company, I don't think that this is the right choice for me at this time. If you like, I'd be glad to introduce you to two of my classmates who have similar skill sets and, I believe, would be perfect for the job.

FAQs
Here are some frequently asked questions about negotiating salary offers.

What do I do if an employer asks me about my salary expectations before they make me an offer?
Employers sometimes ask you about your salary expectations early in the interview process to see if your salary expectations are aligned. If you say a number that's more than they want to pay, they might remove you from the application pool.

If you say a number that's too low, they might offer you a salary at the bottom of the range that they're willing to pay or assume that you're less capable than you are.

For this reason, to the best of your ability, sidestep or redirect questions related to salary expectations before you're made an offer. You can do this by providing a general answer, asking for more time to think about it, or asking them a question.

For example, you can say that you'll happily consider all offers that are in line with the market. Or you can say, "There's still a lot that I need to learn about this role. Would it be okay if we revisit this question after I have the chance to do more research?"

Here's yet another option: "Great question! I was actually going to ask you what your pay range is for this position."

If the employer insists that you provide a specific number, you can refer to objective data and ask them what they think of that figure. For example, you could say, "Glassdoor says that the average salary for a junior data scientist in Seattle is about $100,000. Does that sound right to you?"

The point is to make salary an open discussion rather than a take-it-or-leave-it ultimatum. If you show that you're flexible, then most employers are happy to move forward with you.

How do I respond if an employer asks me to share my current or past salaries?
Avoid disclosing your current or past salaries. All job offers should be based on your fair market value—not your current or past salaries. If asked, you can politely respond that you prefer not to disclose that information since it's in a different industry.

Alternatively, you could say, "I'm a student, so I currently don't have a salary," or, "I'm glad to consider any salary that's aligned with the market rate for this role."

What do I do if an online application requires me to list my salary requirements or a current or past salary?
You can try writing N/A or Prefer not to disclose.

If you're required to list a number, however, write $1. The employer will know that you want more than $1 or that your current or past salary is greater than $1; this simply communicates that you don't want to discuss it at this time.

How do I calculate an hourly rate?
If you're asked to provide an hourly rate, it's generally because you're considering a contract role. Many contract roles don't include standard benefits, like healthcare or 401(k) matching, so it's helpful to add these lost gains into the hourly rate that you provide.

Calculate the following:

Your market value.

The amount of money that you would need to pay out of pocket each year for healthcare.

The amount of money that you will miss out on by not having a company retirement savings plan, like 401(k) matching or a Registered Retirement Savings Plan.

Add these three numbers together, and then divide that number by 2,080 (the number of work hours in a year). Voilà! That's your hourly rate.

Alternatively, you can use this handy salary calculator to convert an annual salary to an hourly rate.

What things can I do to give myself more leverage when negotiating?
Here are five things that you can do to give yourself more leverage when negotiating:

Be certain that the employer wants to hire you. In other words, don't negotiate until the employer gives you an official job offer.

When you receive an offer, maintain a warm but neutral tone. If it's obvious that you're happy with the initial offer, an employer will have no motivation to increase it.

If possible, interview at multiple companies simultaneously. If an employer knows that other companies are interested in you, they will be more motivated to make you a good offer so that you choose them.

Build allies at the company. If current employees are eager for you to be hired, they will put pressure on the employer to ensure that you're hired, no matter the rate.

Have a good attitude and aim for a win-win result for you and the employer. If you seem unfriendly, annoyed, or self-serving, the employer might not feel like doing you any favors. They might even second-guess having you on their team.

Supplementary resources
Ask For It: How Women Can Use the Power of Negotiation to Get What They Really Want

Startup Employees: Understand Your Offer

10 reasons you should NOT negotiate your salary

Equity vs. Salary in Tech: What's the Difference?

** 46.5 - Interviewing soft skills project
** 46.6 - Finalizing your GitHub portfolio

* unsorted


Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly

different type data type
loop over objects
destructing
rest
scope
array method
arrows function
git, github


html boilerplate
