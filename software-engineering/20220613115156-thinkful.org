:PROPERTIES:
:ID:       c4ffc59c-65b7-4f0e-b749-bcd46ef75fb0
:END:
#+title: thinkful
#+date: [2022-06-13 Mon 11:51]

*** mod 3 JavaScript on your machine
**** javascript with node

REPL stands for read, evaluate, print, and loop.
REPL is a program that will allow you to run code and see the output from it.
REPL use to run short snippets of code.
can't save using a repl
The Node REPL is particularly useful for trying out snippets of code, such as short functions, methods, or statements.

node - runs the js repl


Multiple lines of code
You can write multiple lines of code in the REPL.
If you do so, you will need to be careful about your curly braces {} and parentheses (), because you cannot go up a line.

Writing multiple lines will look like this:
Writing a function in the REPL
As you can see, three dots ... denotes that you are currently writing a statement that has not yet ended.
You will see this same thing if you were to write an if/else statement or for loop.

Quitting the REPL
To quit the REPL, you have three options:
Press Control+D (or Command+D on a Mac).
Press Control+C (or Command+C on a Mac) twice.
Type .exit.

Running JavaScript files

touch myFile.js - create a javascript file named myFile
node myFile.js - run a javascript file named myFile

From the command line, you can then run this file with Node by running the following:

node ~/thinkful/my-other-file.js

**** automated testing primer

Writing code is about solving problems without creating new problems (bugs).

Unit test A test that checks a small piece of code, generally a single function
These tests can help you understand when your code is working as requested and when it is falling short.

Automated testing: The practice of running tests against your code using automated software, with the overall goal of creating high-quality, error-free code

Understanding how testing works is therefore crucial for your success both as a student and in the workforce.

Intro to automated testing
Automated testing helps developers recognize issues as they occur so that the issues can be remediated before the software is released into production.
It's typically easier and less expensive to identify and fix an issue before rather than after putting the software in the hands of end users.

The majority of the assessments in this program contain automated test code.
The benefit of this approach is that you can get immediate feedback on your code and identify errors in your programs prior to submitting your work.

Although there are many different types of automated tests, the majority of the tests that you will encounter in this program are unit tests, which are one of the most common types of automated tests in the industry.

Unit tests are automated tests created by software developers to test the individual parts of a program.
They ensure that the program does what it's designed or programmed to do.
Each unit test tests only a small part of a program, which makes it easy to track down where the issues are.


Folder structure for a typical Eng assessment
The two folders of interest here are the src and the test folders.

The src folder (also called the source folder) is the folder where you will usually be asked to provide your solution code, inside either a single file or multiple files.

The test folder is the folder that stores the test file (or test files) for the assessment.
Test files are generally stored in a folder labeled test (or some variation of this name) for easy reference.
Note that the names of test files typically end with the .test.js extension so that the computer can easily identify them.

Whenever you run the automated tests, your computer will find and execute the test files, which will in turn import and test the code that you wrote inside the src folder.

While you're working on an assessment, feel free to look at the contents of the test files, but don't worry about trying to understand what each line of test code is doing for now.
For now, just keep in mind that the test files contain a set of instructions on how to test your code.

Automated test output
Whenever you run the tests for each assessment, you will be presented with some output in the terminal (if you're running the tests locally) or in the Qualified window (if you're using the qualified-attach command).
The test output will indicate whether or not you're on the right track with the assessment, so it's important that you understand how to interpret the basic parts of the test output.

Automated testing is an important technique in software development, and knowing how to interpret basic test outputs is a good first step to mastering this skill, which you will continue to develop throughout the program.

**** environment variables and script arguments

Environment variable Also called an env var, a key-value pair held by your current operating system and user
Command-line script Also called a script or a command-line program, a reusable program that can be run on your command line

Running JavaScript on your computer instead of on the web comes with some advantages.
 Node has access to the environment variables running on your machine, which allows you to customize the JavaScript programs that you write.
 Additionally, Node lets you parse arguments used with the Node command.
 This allows you to write command-line programs.

You are learning about environment variables and script arguments now because they are used sparingly when learning to build servers or running React.

Environment variables
Your computer currently has several stored variables that help it run.
Just like JavaScript variables, these environment variables have a name and point towards a specific value.
Environment variables, or env vars, are key-value pairs held by your current operating system and user.
Like variables in JavaScript, they are used to perform and configure certain actions.

The convention is that all environment variables are written in screaming snake case.
 In other words, letters are capitalized and separated by underscores, like this: ENV_VAR.



env Echo environment variables
You can print a value to the terminal by using the echo command.
Choose one of the variables from the list above and print it out, replacing ENVIRONMENT_VARIABLE in the code below with the name of the variable.

echo $ENVIRONMENT_VARIABLE
Use environment variables with JavaScript
Whenever you run a JavaScript file with Node, it gives you access to a number of global variables.
One of those variables is process, which is an object.

For this program and the majority of web development, you can ignore most of what is in the process object.
However, there are a couple of keys in this object that can be useful for building different types of programs.
One of those keys, .env, gives you access to all of the environment variables on your system.


console.log(process.env);
Run the file using the node command.
You will see that process.env prints another object.
Update your code above to print a single environment variable from this object. (Be careful about the capitalization!)

Set temporary environment variables
You can also temporarily set an environment variable, just for however long it takes to run the program.
Update your file to include the following:

console.log(process.env.NODE_ENV);
Then, run the command shown below, replacing <filename> with a path to your file.

NODE_ENV=development node <filename>
You will see the word development printed back to your terminal. If you run the file without setting the environment variable, you won't see anything printed to your console.

Script arguments
Node also allows you to build complex command-line scripts with JavaScript.
A command-line script, also called a command-line program or simply script, is an often small program that can be run on your command line to achieve any number of effects.
You can think of it as a function for the command line.

Command-line scripts can be used to do just about anything, from creating a new HTML and CSS project to printing out a fun message.
Often, command-line scripts contain arguments, just like functions do.
Whereas a function has parameters that are a part of the function's definition, a Node script with arguments might look like the following:

node plant-facts.js "Pretzel Bean"
In this case, there is a single argument: "Pretzel Bean".

You can access what was run on the command line through the process object as well. Running process.argv will print an array of what was on the command line, separated by spaces.

For example, for the above line, process.argv would print the following:

[
  "/Users/your-username/.nvm/versions/node/v13.12.0/bin/node",
  "/Users/your-username/path/to/your/plant-facts.js",
  "Pretzel Bean",
];
In the above array, you can see the following:

The full path to the node command

The full path to the plant-facts.js file

"Pretzel Bean", which was the argument

It is important to note that the quotation marks in the command matter! Instead of the above, imagine that you ran the following command:

node plant-facts.js Pretzel Bean
The output of process.argv would be as follows:

[
  "/Users/your-username/.nvm/versions/node/v13.12.0/bin/node",
  "/Users/your-username/path/to/your/plant-facts.js",
  "Pretzel",
  "Bean",
];
Notice that it now sees Pretzel Bean as two distinct arguments.

**** modules

Learning Objective
By the end of this lesson, you will be able to create and connect your own modules.

Overview
Using JavaScript with Node is quite powerful. However, this combination can become even more useful when you add Node modules into the mix. In this lesson, you will learn about local modules, which are one of the three different types of modules. At this point in your journey, learning how to make use of modules will allow you to better organize the JavaScript code that you write on your machine.

What is a module?
In Node, each file is treated as a separate module. A module, sometimes also referred to as a package, can contain any JavaScript code. It most commonly exports an object or a function. The exported value then becomes available in other modules.

Put simply, each file in a Node project is its own module. You can then export data from that file to be used in another file.

Do this
Create a new folder
In this lesson, you will be asked to make a few different files to practice the concepts that you are learning. Create a new folder with a memorable name, like learning-node-modules/.

Local modules
The best way to understand modules is to create and use them. For example, take a look at the following code. Imagine that it is in a file called plants.js.

function findPlantById(plants, id) {
  let result = null;
  for (let i = 0; i < plants.length; i++) {
    let plant = plants[i];
    if (plant.id === id) {
      result = plant;
    }
  }
  return result;
}

module.exports = findPlantById;
The above function expects an array of objects as the first argument passed to the function, where each object has an id. It then accepts an id. The function then loops through all of the plants and returns the one that has a matching id. If none match, it returns null.

At the end of the code block shown above, you may have noticed the following line:

module.exports = findPlantById;
This line indicates that the file is a module. A function is being exported from this file.

You can use this function in another file. For example, take a look at the following code. Imagine that it is in a file called main.js.

let find = require("./plants");
let plants = [
  { id: 1, name: "Garden Rocket Arugula" },
  { id: 2, name: "Watercress" },
  { id: 3, name: "Royal Rose Radicchio" },
];

const result = find(plants, 2);
console.log(result);
The new and important part of the code above is the require() function. The require() function takes a path as an argument. If no file extension is given, it will assume that the file is a JavaScript file. It looks into that file and then finds what is exported, and whatever is exported is returned from the require() function.

So, in the above file, the following happens:

The findPlantById() function is imported from the plants.js file. Notice that it is assigned to a new name, find, although it can be assigned any name.

A plants variable is declared, which points to an array of objects with IDs.

The find() function is called with the appropriate arguments.

Do this
Create a module
In the folder that you've created, create two new files: plants.js and main.js. Copy the above content into the files as appropriate, and then run the main.js file.

You will see the following output:

{ id: 2, name: "Watercress" }
View the default value
In your plants.js file, comment out the line that is exporting the function, as follows:

// module.exports = findPlantById;
Then, at the top of your main.js file, add the following line:

console.log(require("./plants.js"));
What do you see? You should see an empty object. By default, if you require a file that doesn't have a module.exports statement, you will receive an empty object.

Now, undo the changes that you made in this step.

Export an object
After you've undone the changes from the above task, update your plants.js file with the following export statement. This export statement should replace the one that you already have.

module.exports = { findPlantById: findPlantById };
Now, you are exporting an object instead of a function. How would you update your code in main.js so that you can still call the function?

There are a few ways that could work, but one option is to update the code as follows:

let plantFunctions = require("./plants");
let plants = [
  { id: 1, name: "Garden Rocket Arugula" },
  { id: 2, name: "Watercress" },
  { id: 3, name: "Royal Rose Radicchio" },
];

console.log(plantFunctions.findPlantById(plants, 2));

**** the package.json file

Configuration file Any file that's necessary to run an overall project but may not have explicit code inside of it

Each folder that you create and plan to run with Node can be considered a Node package or project.
These projects can contain a configuration file, package.json, which gives additional information about the project.
This configuration file also allows for some interesting functionality through the use of npm, the command-line tool that you installed at the beginning of this module.

Configuration files
So far, the files that you've created have been JavaScript files that you've been able to run with Node.
These files are, obviously, critical to running code in that they have code in them.
As you advance throughout this program, you will also come across a number of configuration files, which are essential to larger projects.
Configuration files can generally be described as any file that's necessary to run an overall project but may not have explicit code (functions) inside of it.

For example, your text editor (whether it's Visual Studio Code, Sublime, or something else) likely has a settings file that defines how your text editor works. These settings may determine how your code is spaced or what colors your text editor shows. These settings don't explicitly run your text editor, but they do shape how the text editor is run.

The package.json file
For Node projects, the main configuration file is the package.json file. This file contains meta information about the project and allows you to customize some commands that can be run.

The package.json file can be created through npm. After navigating to the folder where you want to create your project, you can create a package.json file by running the following command on the command line:

npm init -y
The above command will create a new package.json file in the directory where it was run. It will also fill in some default values.

Note: Each Node project should only have a single package.json file.

Do this
Create a package.json file
Create a new directory called first-package-json on your computer. On your command line, navigate to that directory and run the above command to create a package.json file.

Take a look at the file that was just created. Note that it looks similar to a JavaScript object.

JSON
The file that you created isn't a JavaScript file—it's a JSON file. JSON stands for JavaScript Object Notation, which is different from JavaScript. JSON looks like a JavaScript object but has more limitations. In particular, when writing JSON, you must consider the following:

All keys in a JSON file must be wrapped in quotations.

A JSON file cannot include JavaScript comments or variables. Instead, the file must only contain a single JavaScript object.

Values such as booleans, numbers, strings, arrays, and other objects are valid in JSON.

Keys
If you used the command suggested earlier in this lesson, your package.json file will look something like this by default:

{
  "name": "first-package-json",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
All of the above keys are optional. But there are a few that you will want to keep—especially the following:

name: This is the name of your package. By default, it will take the name from your folder's name.

description: This is a description of your project. You can place whatever you want here.

scripts: This is where you will set up scripts to be run through npm. You will learn more about scripts below.

You can learn more about the package.json file and other keys in the package.json documentation.

Scripts
Right now, one of the most useful skills that you can learn is how to build scripts with the package.json file. The scripts key has a value that is an object. Each key in that object is the name of a script that can be run from the command line. The value associated with that key is a string containing any valid command-line code. Running that script with npm will execute the code on the command line.

For example, take the following default script:

{
  "test": "echo \"Error: no test specified\" && exit 1"
}
This script can be run with the following command:

npm run test
When the above command is run on the command line in the folder where the package.json file exists, it will run the value as a script. Here's an example:

Example of running npm test
After npm run test was run, the value of the test command was run. That is, a specific message was echoed.

You can create new scripts by adding new key-value pairs. For example, the following script will simply run the pwd command on the command line.

"print-working-directory": "pwd"
To run the command, you would type the following:

npm run print-working-directory
Note: If you try to include the above script, make sure to use the correct syntax for your JSON file.

Do this
Run JavaScript with npm
In the first-package-json folder, create a new file called main.js. Add the following code to it:

console.log("Hello, world!");
Then, add a script called dev that will run the following command:

node main.js
Afterward, on the command line, you should be able to run the following command and see "Hello, world!" printed to the console.

npm run dev
Default commands
The npm program expects you to use some common terms like start and test. For these common terms, you can skip the run part of the command.

npm test
However, you will still need to use the run part of the command for custom scripts.

npm run dev
More of the supported scripts can be found in the npm scripts documentation.

**** installing packages


Open-source Code that is available to be viewed, downloaded, and edited by anyone

The npm tool can help you install and manage these packages.

Viewing packages
https://npmjs.com/ - where javascript packages can be found


Moment
Take a look at the Moment package.
This page shows you information about how to install the package, how it can be used, and various statistics on the package's usage.
For example, this package describes itself as "a lightweight JavaScript date library for parsing, validating, manipulating, and formatting dates."

You also can see that this package has been downloaded often and has been updated recently.
When you're assessing whether or not to use a package, it is a good idea to look at these statistics.

Note: You may notice from the documentation that the Moment package is now a legacy project and is no longer being updated. However, Moment continues to be a very popular and useful package, and you'll work with it throughout this lesson.

Reading documentation
You learned that the Moment package can help parse and format dates in JavaScript.
How does it do this? To answer this question, you will need to read the documentation.

So far, you have likely only seen documentation on the official JavaScript language from MDN.
MDN is a great resource, but it doesn't contain documentation on packages.

Now, you will need to look instead at the specific package and its documentation.
Thankfully, Moment has fantastic documentation, which can be found at Moment's website.

Reading documentation is its own skill, and it can be challenging at first. As you come across phrases and terms that you don't understand, you will need to be patient and look up new concepts.

Installing
You can install a package with a simple npm command:

npm install <package-name>
npm i <package-name>

Running this command (while changing <package-name> to the name of the package) will do the following:
If a node_modules/ folder doesn't already exist, a node_modules/ folder will be created in the current directory.
If a package-lock.json file doesn't already exist, a package-lock.json file will be created in the current directory.
If a package.json file does already exist, the package and its version number will be recorded in the package.json file.
The package will be downloaded from the web to your computer.
In general, you always want to have a package.json file before running any install commands.


Do this
Create a JavaScript project
First, complete the following steps:

Create a new directory called installing-packages.

Then, create a package.json file and a main.js file.

In the package.json file, create a start script that runs your main.js file with Node.

Finally, include the following in your main.js file:

console.log("The current date is: " + Date.now());
When you run your script, you will see something like the following show in your terminal:

The current date is: 1592329893846
Install the Moment package
The above date isn't very useful! Instead, try using the Moment package. Install Moment using the following command:

npm install moment
Then, require the Moment package in your main.js file:

let moment = require("moment");
Run your code and confirm that the output looks the same as it did before.

Use Moment
Now it is time to actually use Moment. Before looking at the solution below, try reading the Moment documentation yourself, and look for how you might display a more human-readable date format.

If you're having a hard time, try looking at the display format section of the documentation. As you can see, there are actually several ways to display dates with Moment.

If you're still having trouble, you can replace your console.log() statement with the following:

console.log("The current date is: " + moment().format("MMMM Do, YYYY"));
Dependencies
Whenever you install a package with npm install or npm i, the installation will be recorded in your package.json file under a key titled dependencies. It will look something like this:

"dependencies": {
  "moment": "^2.26.0"
}
The string value next to the package name is the version number for that package. If you are interested in the version number syntax, you may optionally read more about it in the package.json dependencies documentation.

Developer dependencies
In the future, you may also see a command like this:

npm install <package-name> --save-dev
The --save-dev flag will be included for packages that are necessary only for the development of the project, not for running it. Packages installed with that flag will show up under the devDependencies key instead of dependencies.

The reason behind this will be explained whenever it is asked of you. For now, just keep in mind that you may see this flag.

The package-lock.json file
The package-lock.json file is automatically created whenever you install a package. Similarly to package.json, package-lock.json is a configuration file.

The difference is that you will never need to edit this file. The package-lock.json file is essentially metadata for package.json. Although it is required, it does not require any management by you.

You can read more about the package-lock.json file in the package-lock.json documentation.

Node modules
When you install a package, that package's code will be added to a node_modules folder. Modules that aren't created by you or installed in Node will be contained in this folder.

As you'll see, the installed packages also have a package.json file. If the installed package has its own dependencies, those packages will also be installed.

You can delete the node_modules folder at any time and reinstall the packages by using the npm install command without providing a package name. By default, npm install will install everything listed in your package.json file.

Do this
Browse the node_modules/ folder
Take a look inside the node_modules/ folder inside your installing-packages/ directory. You will see a single folder: moment/.

Look around the folder briefly, and try to find the package.json file. As you can see, Moment is just another Node project, like the one that you have!

**** Assesment: JavaScript on your machine
*** module 7 Git and GitHub
**** Version control and setup

Snapshot A view of code taken at a specific time

***** What is version control?

Version control The process of managing changes to code
Version control refers to the process of managing changes to code, and it's a critical part of modern web development.

Version control systems Systems for managing changes to files, software, websites, and other computer or web-based programs

A version control system (VCS) makes it easy to switch between past and current versions of the same code.

Version control is important for a few reasons:
If you introduce a bug, you might want to roll back to a previous version of the code that does not include the bug.
As the size of an application grows, it can be challenging to keep all developers up to date. A good version control system makes it easy to know how far behind or ahead your code is.
If each version of code is being stored, it becomes simple to compare two snapshots of the code. This makes reviewing changes to code much simpler.

***** Why do you need version control?

Developing complex software, like the website that you are using right now, is impossible without a version control system.
Version control tracks every change to the source code. It is an essential tool to ensure the integrity of the codebase.

***** What is Git?

Git is a powerful but complex command-line tool that allows you to track changes to a project on your local machine.

Git repository A container for tracking all changes for a specific project

A Git commit is a bundle of changes packaged together.
A repository will have multiple commits saved on it that make up the entire project history.

Git manages local version control.

***** What is GitHub?

GitHub provides free online hosting of both public and private Git repositories.



GitHub is important for a few reasons:
By looking at your public GitHub repositories, prospective employers can get a better sense of how you write code and solve problems than they can from your resume.
The visual display of your public commits shows your enthusiasm for writing code.
With GitHub, you can back up your Git repository for free. If anything happens to your local version, you'll be able to pull a copy from GitHub.
GitHub makes it much easier to collaborate over the internet.
GitHub provides many tools that benefit developers, such as pull requests, issue tracking, profile creation, and more.
GitHub makes it easier to contribute to open-source projects hosted on GitHub. Contributing to open-source projects is a great way to impress prospective employers.


GitHub hosts Git repositories on the web.
With that said, using both Git and GitHub allows you to sync local repositories with repositories on GitHub (known as remote repositories).
Git and GitHub are almost always used together, although they don't have to be.

Remote repository Also called the remote repo, the GitHub project folder that is stored on the GitHub.com website

**** Git basics


Main branch The default branch that is always created when a new repository is made
Staging a file Adding a file by moving it to a staging area
Staging area A place for changes that are ready to be committed
Untracked One of the four possible states of a file in a Git repository. An untracked file is not part of the Git repository
Staged One of the four possible states of a file in a Git repository. A staged file is one that is ready to be committed
Unmodified One of the four possible states of a file in a Git repository. An unmodified file is one that has not been changed since the last commit
Modified One of the four possible states of a file in a Git repository. A modified file is one that has been changed since the last commit
SHA A 40-character checksum hash that identifies the commit

Getting started
A Git repository is just a folder, but it can track every file in the folder, including every file in every subfolder.
What makes it special is that it has the .git folder inside of it.

A good rule to remember is that you don't need to put a Git repository inside of another Git repository.


git init - initialize, or create, a new repository inside of the current folder.

Delete the .git folder
Now, go ahead and delete the .git folder in your getting-started-with-git folder. Then, run git init once more.

git status will be a useful command to know. This command will display information about what is currently happening in your Git repository. When you first run git status in an empty repository, you'll get a message like the following:

On branch main

No commits yet

nothing to commit (create/copy files and use "git add" to track)
The above output tells you the following information:

You are currently on the main branch. (If you haven't changed your default, this may be called the master branch). This is the default branch that is always created when a new repository is created. You'll learn more about branches later on.

There haven't been any commits. You'll do that soon!

There haven't been any changes in the repository since you ran git init. Note that the output also provides a helpful hint about what you might do next.

Tip
The git status command is always good to run if you're a bit confused about what is happening with Git.

Do this
Create a file
In the getting-started-with-git folder, create a new file called teams.txt. Then, run git status. You will see something like the following outputted to your terminal:

On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	teams.txt

nothing added to commit but untracked files present (use "git add" to track)
Notice that the message has changed.

The Untracked files section of the message tells you which files are in the folder but aren't tracked by Git. The untracked state is one of the four possible states of a file in a Git repository. An untracked file isn't part of the Git repository.

Staging files
Once you've made changes to a file, or just created a new one, you can then add the file. Adding a file is also sometimes called staging a file, because that file is moved to a staging area. The staging area represents changes that are ready to be committed, as opposed to the untracked files, which aren't yet ready to be committed.

To summarize, there are four possible statuses for a change:

Untracked

Staged

Unmodified

Modified

The following diagram shows how files transition between the possible statuses:

A diagram of how Git commits work
If you want to move a file from untracked to staged, you can run the add command, which you can see below:

git add teams.txt
As you might have noticed, this is the syntax that was suggested in the output from git status.

Do this
Stage files
Stage your file by running the git add command above. Then, type git status. You will see something like the following code:

On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

	new file:   teams.txt
As you can see above, the output provides instructions on how to unstage the teams.txt file if you choose—which implies that the teams.txt file is now staged. In fact, all files listed in the Changes to be committed section are staged.

Awesome job on making it this far in the lesson! So far, you've learned the how to create new repositories with git init, stage new files or changes to existing files with git add, and check the status of a repo with git status.

Before continuing on, feel free to take a quick break. In the remainder of this lesson, you will learn how to commit changes with git commit.

Making commits
Each commit bundles together all staged changes and saves them, along with a helpful message and meta information about those changes.

The more commits that you make, the easier it is to get a detailed history of what happened. And, as you'll learn later, having more commits gives you more checkpoints that you can return to if something goes wrong.

Tip
The best developers commit often. This ensures that their work is recorded, labeled, and backed up.

Do this
Make a commit
At this point, your changes are staged and you're ready to make your first commit. To do so, run this command:

git commit -m "Adding the teams.txt file"
The git commit command saves whatever is staged, packaging the changes into a single commit. The -m flag allows you to add a message and provide context to your commit.

If you run git status again, you will see something like the following:

On branch main
nothing to commit, working tree clean
Check your history
How do you know if your commit worked? One way is to use the git log command, which will show you the history for your entire repository.

Try running the git log command. Your output will look something like this:

commit 8529743e386b193450baab116e5a0e81a0b5ea9f (HEAD -> main)
Author: Author Name <email@thinkful.com>
Date:   Thu Jul 2 10:35:33 2020 -0700

    Adding the teams.txt file
Tip
Remember that you can type Q or q if you want to get out of the reader.

The output shown is a single commit! In this commit, you can see the following information:

A commit SHA, which represents the commit's unique ID (in this case,

85297...)

Who made the commit and what time it was committed

The commit message

For now, you can ignore the (HEAD -> main) part of the commit message. This will be covered later in the module.

What makes a good commit?
Git is very flexible and makes it easy to commit to the repository. In fact, there are only two constraints when making a commit:

You need to include at least one staged change.

You need to include a commit message.

Recent versions of Git allow you to commit without a message. But just because you can do this doesn't mean that you should. There are two qualities to keep in mind when making a commit:

The size of your commit

The message of your commit

You'll explore both of these qualities below.

Commit size
It's better to make many small commits rather than one big commit. With many small commits, you end up with multiple descriptive messages that make it easy for a collaborator (or your future self) to understand what happened.

It also makes it easier to return to a particular point in your project. If you only have two commits, and their commit messages are Initial commit and Project completed, there's no way to return to a version of your project that's between those two points.

Additionally, it's ideal to group files that are related to each other in the same commit. For example, say that you made changes to the following files:

teams.txt
players.txt
configuration.txt
You may want to make two commits:

Your first commit might be to add configuration.txt.

Your second commit might be to add teams.txt and players.txt.

Why should you separate the commits in this way? The configuration.txt file may not actually be related to the teams.txt and players.txt files. So, creating a separate commit can help emphasize that the configuration.txt file is for a different purpose.

It isn't always possible to split content up like this. However, the best developers strive to use their commits to create a coherent narrative for their projects.

Commit message
Another important component of commits is the actual message itself. Although figuring out the right size of commit takes some practice, writing a good commit message is far easier.

Your commit message should do the following:

Describe why you are making the change

Use proper spelling

Take a look at the following two commit messages:

"Updated files"

"Added new players and team names"

Is it clear to you which one is better? The second message actually gives some information as to what was added, whereas the first one tells you nothing. And you can be even clearer if you give some context as to why the changes occurred. For example, take a look at this commit message:

"New season started: Added new players and teams."

It's possible to get really detailed with your commit messages; you can even make multi-line commits. For now, it's sufficient to just give a short contextual summary of the code changes.

Do this
Make more changes
Add the following text to your teams.txt file.

Hopper Hawks
The Lovelace Lynxs
Turing's Tigers
View the changes
It is often useful to view the changes that you made before you stage them. You can do so with the git diff command.

Try running git diff. You will see something like the output below.

diff --git a/teams.txt b/teams.txt
index e69de29..eea9eae 100644
--- a/teams.txt
+++ b/teams.txt
@@ -0,0 +1,3 @@
+Hopper Hawks
+The Lovelace Lynxs
+Turing's Tigers
Tip
Remember that you can type Q or q if you want to get out of the reader.

The above code shows the following information:

The content at the top indicates that this is comparing an older version of the teams.txt file to the current, changed version.

Any line with a plus sign + in front of it shows what is added. Any removed line will be shown with a minus sign - in front of it.

The git diff command is a powerful tool to help you make the most out of your commits and to confirm what is being changed.

Tip
You can only use git diff to compare changes that haven't been staged.

Add all changes
Add your changes to the staging area with the following command:

git add -A
The -A flag will add all changes to the staging area, including new files. Since you just checked the diff between the history and the current changes, you know that adding everything now will make a fine commit.

If you make a number of changes to a project and haven't committed for a while, consider not using the -A flag. Instead, add files individually so that you can make multiple commits.

Get out of vi
Now, try running the following command. Note that this command is missing the -m flag!

git commit
Depending on your operating system, it is likely that you may enter into a terminal editor called vi. The vi editor isn't really that scary, but it can seem overwhelming if you haven't seen it before.

A screenshot of the Vi editor
For now, you should just plan to quit vi if you accidentally get into it. To do so, type :q!. Then, press Enter.

A screenshot of how to exit the Vi editor
Quitting the vi editor will bring you back to your terminal, but you won't have made a commit. So try again to make your commit. This time, use the -m flag, and make sure to include a commit message.

When changes aren't committed
At this point, the repository shouldn't have any uncommitted changes, and running git status should display the following:

On branch main
nothing to commit, working tree clean
It is possible to have one file that has both some staged changes and some changes that aren't staged. When this happens and you commit, you might be surprised to see that some changes aren't included in the commit.

Tip
The git commit command only commits staged changes.

Do this
Try committing with unstaged changes
Now, give it a try. Add the following text to your teams.txt file:

Torvald's Tornados
Stage your changes with the following command:

git add -A
Now, run git diff. The changes are staged, so git diff should show no differences.

Add the following text to your teams.txt file:

Page Panthers
Now, run git status. You'll see something like the code below:

On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   teams.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   teams.txt
Note that modified: teams.txt appears under both Changes to be committed: and Changes not staged for commit:.

What happens if you commit now? Remember, Git only commits changes that are staged. And you staged only one of the changes, so you can conclude that only the addition of Torvald's Tornados will be included in the commit.

Give it a try. Run git commit -m "add new team: Torvald's Tornados".

Now, run git diff again. You'll be able to see that the addition of Page Panthers, which isn't yet staged, wasn't included in the commit.

**** Pushing and pulling

Local repository Also called the local repo, the project folder that is stored on your computer
Remote repository Also called the remote repo, the GitHub project folder that is stored on the GitHub.com website
Pulling changes Copying commits from the remote repository that are not yet in your local repository
Pushing changes To move the commits that you've made from your local machine up to a GitHub repository

***** Pushing
Pushing changes to GitHub means to move the commits that you've made from your local machine up to a GitHub repository.

Note that only your commits will be pushed. If you have files or changes that haven't been committed, they will not make their way to GitHub.

To push to GitHub, you'll do the following three steps:

Create a repository on GitHub.

Use commands provided by GitHub to link the two.

Use commands provided by GitHub to push your code.

Moving forward, Git repositories on your local computer will be described as local repositories, while GitHub repositories on the web will be described as remote repositories.

A local repository is a repository created on your machine; this is what is created when you run git init. And a remote repository is a repository that is created on the web, with a website like GitHub. These repositories can be synced with each other, but they don't necessarily have to be.

Remote repositories will require authentication. Authentication confirms your credentials and will allow you to securely access your account's resources. You can access repositories from the command line in two ways: SSH and HTTPS. GitHub recommends using the HTTPS method and provides detailed instructions on how to set a personal access token.

Do this
Create a new remote repository
Go to GitHub's website and create a new repository. The way that you do this will depend on the interface that you're looking at. Either click the New button, or select the ➕ icon next to your profile picture. Then, in the drop-down menu, click New repository.

You will then be presented with a screen that looks similar to this:

A screenshot of the Create a new repository page in GitHub
On this page, fill in a repository name. It's a good idea to have your repository name match the folder that you created on your local machine, but it isn't a requirement.

Make sure that the Initialize this repository with a README checkbox is cleared. Then click Create repository.

Next, you'll see something like this page:

A screenshot of the GitHub setup page
Connect your local and remote repositories
The page pictured above describes how you can connect your local and remote repositories. Focus on the following section:

A screenshot of a portion of the Getting started page on GitHub
Normally, you would run both lines of code to push your repository. But for now, you'll run them one by one.

First, run the following line in your local repository:

git remote add origin <your-url>
The above command adds a new remote repository (git remote add) with the name origin and a URL pointing towards the URL that you just created. You can name your remote repository whatever you like, although origin is standard.

When you run this command on the command line, you won't see any output. But you can check for all your remote repositories by running git remote -v. That will return an output like this:

origin	https://github.com/thinkful/getting-started-with-git.git (fetch)
origin	https://github.com/thinkful/getting-started-with-git.git (push)
The output above shows that there is a remote called origin at the given URL. (Don't worry about the duplicate listing.)

Sync through pushing
The second line of code shown on GitHub is the branch command.

git branch -M main
Note: You will learn more about branches later in this program. But for now, you just need to know that this command will rename the master branch to main. Since October 2020, GitHub has stopped using the master terminology.

The third line of code shown on GitHub is the push command.

git push -u origin main
This command uses git push to push your commits to the remote origin on the main branch. The -u flag sets the default upstream reference. This essentially means that for all future times that you want to push, you can just type git push.

After running the above command, you will see an output in your terminal. Try refreshing the page on GitHub, and you will see your newly committed files up on GitHub.

Practice with git push
Try running git push again. Do you see the following message?

Everything up-to-date
If you ever see this message, it means that there are no new commits to be pushed.

Now, try making a new file called README.md. Don't add any content to it. Then, try running git push again, as follows:

touch readme.md
git push
You will see the "Everything up-to-date" message once again. This is because, while you have new files, you haven't actually made a new commit.

Add and commit the file (with a valid commit message!), and then try pushing once again. You can use the following code:

git add README.md
git commit -m "add readme file"
git push

***** Pulling
When you're collaborating with another person, they might be pushing to the same repository that you are. That means that it's possible for the remote repository to have commits that you do not have on your local repository.

The way to fix this is to pull down changes. Pulling changes means copying commits from the remote repository that are not yet in your local repository.

Do this
Make changes on GitHub
Instead of working with another person, you can simulate the experience by editing your files directly on GitHub. From your remote repository's page, click the README.md file. Clicking the filename will bring you to that specific file.

This file should be empty. Click the Edit ✎ icon so that you can edit the file.

The GitHub edit icon
This will bring you to a text editor on GitHub. Make some changes to the file, and then scroll to the bottom of the page.

The Commit changes screen on GitHub
Click the Commit changes button. The commit message will be something like "Update README.md."

You've now made a commit on GitHub!

Pull changes
Your local repository is now out of date with the remote repository. To fix this, you can run the git pull command:

git pull
Tip
The full command is git pull origin main, but you only need to type git pull. This is because you included the -u flag when you set up the repository.

After running the command, you will see some output in your terminal that shows your new commits being pulled to your local repository. When you check the README.md file, you will see the content that you added to the file.

**** Forking and cloning

1.5 hoursAverage Reading Time

Learning Objective
By the end of this lesson, you will be able to fork copies of repositories to your own GitHub account and clone repositories from GitHub to your local machine.

Overview
Now that you know how to push and pull, you're ready to use Git and GitHub to work on projects on your own and sync those projects to GitHub. For this program, you may also want to occasionally pull down some code that already exists. And once you start your career as a professional developer, you will often need to clone the work that your company has done on an already existing repository. This lesson will provide an overview of how to perform these tasks.

Key Terms
Forking
The process of copying a remote repository from a different user to your own account
Cloning
The process of copying any remote repository to your computer
Forking
Forking is a word that GitHub uses to describe the process of copying another user's remote repository to a new remote repository under your own account. Forking is popular among open-source projects, because it allows you to copy over an entire project and make minor tweaks. You can also use forking as a tool for collaboration, which will be discussed later on.

In this program, you'll use forking to get copies of starter code on your own account. This way, as you work on the starter code, you can push that code up to your own account and maintain it.

Do this
Fork a repository
Go to Jenny Thinkful's GitHub profile, and click the pizza repository. You will arrive at a page that looks like the image below:

A screenshot of the pizza repository
Click the Fork button in the top-right corner. Then, select your user account. You will see an image like the one below:

An image of the GitHub page that occurs when you try to fork something.
When this is completed, you'll have a copy of the pizza repository on your account. To confirm that you're looking at the repository on your account, take a look at the top-left corner of the page. You will see something like the following (except with your username in place of thinkful):

thinkful / pizza
forked from jennythinkful/pizza
If you see that, you have successfully copied the repository to your own account! Notice that you can still see Jenny's last commit and her profile image.

Cloning
Cloning a repository refers to copying the commits from the remote repository to a local version. Cloning is essentially a way to download the contents of a remote repository through the command line.

When you use git clone to clone a repository, the command will do the following:

Create a new directory with the name of the repository.

Create a link in the new directory to the remote repository.

Download the contents of the repository to your computer, in the new directory.

Because cloning will create a .git folder, it is very important that you don't clone inside an existing repository. You always want to be in a directory that isn't a Git repository.

Do you need to fork before cloning?
Forking and cloning are two separate processes that can go together but don't have to. Forking is the process of copying a remote repository from a different user to your own account. And cloning is the process of copying any remote repository to your computer.

You can just fork, just clone, or do both.

Do this
Clone a repository
Go to the pizza repository that you forked earlier:

A screenshot of the GitHub pizza repo
Click the Code button in the top-right corner. Then, copy the URL. It will look like this:

https://github.com/jennythinkful/pizza.git
Notice that it's essentially the URL in the location bar, except with .git at the end.

On your command line, go into a directory that isn't a Git repository. Remember, it's very important that you do not run the following command inside of a Git repository. If you do, you will end up with nested local repositories.

Once you're in a directory that isn't a Git repository, run the following command:

git clone https://github.com/jennythinkful/pizza.git
You will see that some files are being downloaded. You'll also notice that you have a new folder, called pizza.

Go into that folder and type ls -la. You will see something like the following:

drwxr-xr-x   7 wesreid  staff  224 Jul  2 17:21 .
drwx------@ 11 wesreid  staff  352 Jul  2 17:21 ..
drwxr-xr-x  12 wesreid  staff  384 Jul  2 17:21 .git
-rw-r--r--   1 wesreid  staff    8 Jul  2 17:21 README.md
drwxr-xr-x   3 wesreid  staff   96 Jul  2 17:21 images
-rw-r--r--   1 wesreid  staff  646 Jul  2 17:21 index.html
-rw-r--r--   1 wesreid  staff  921 Jul  2 17:21 style.css
As you can see, the files were downloaded and a repository was created.

Check the remotes
Cloning creates a link between the remote repository that you cloned and your local repository. You can see this if you run git remote -v.

You will see that the origin is pointing toward the repository that you cloned.

*** module 8 developer collaboration
**** GitHub projects and issues
***** Kanban boards

Kanban board An agile scheduling and workflow system where tasks are separated into individual cards, which are then organized into columns that indicate their status

A Kanban board is a system where tasks are separated into individual cards, which are then organized into columns that indicate their status.
The most common columns are To do, In progress, and Done.

In Japanese, the word Kanban translates generally as a visual signal.
Accordingly, it's important to keep each distinct task visible and separate from the others.
The term Kanban has a rich history from manufacturing.


Kanban cards

Card A visual representation of a task to be completed on a Kanban board

Each task to be completed is called a card when it's placed on a Kanban board.
Ultimately, it is up to you and your team to determine how to write cards.
Typically, it's best to write small cards that can be completed in full.

For example, cards for households chores might look like this:
Clean the microwave
Mop the kitchen floor
Go grocery shopping

These cards are succinct and specific.
Contrast this with a card that says "Clean the house."
Cleaning the house isn't a very specific task, so this task should be broken down further.

With practice, you'll be able to better define the right size for cards.
In general, don't write cards that are so big that they can't be completed in a day—and don't write cards that are so small that they can be completed in only a few minutes.


Kanban columns

Columns on a Kanban board help organize your cards in different states.
Together, they should represent the progression of a task from incomplete to complete.

Here are a few of the most common columns for Kanban boards:
Upcoming (or To do): These are the cards that you've prioritized to work on next.
In progress (or Doing): These are the cards that you're currently working on. If you have to stop working on a particular card, it should be moved back to Upcoming.
Completed (or Done): These are cards that have been completed in full.

The steps above are usually placed in order, from left to right.
This represents the progression of a card from To do to In progress to Done.

The columns above are the most common, but there are others that you might see, particularly as part of a development process.
Here are some other common columns:
Backlog: This column goes before the To do column. This is for cards that you need to get to eventually, but that are not the top priority at the moment.
Reviewed (or Ready): This column typically goes right before the Done column. If a card involves something that needs to be deployed or reviewed by someone before the card can be considered done, it might be moved to this column while waiting for that action.

***** GitHub projects


Creating GitHub issues
The Issues tab, shown below, allows you and other developers to propose tasks that need to be completed.

The Issues tab in GitHub

Issues Tasks that need to be completed, which include chores, bugs, and feature requests

GitHub issues generally encompass three different types of activities: chores, bugs, and feature requests.

Chores
Chores are tasks that need to get done but may not require any real creative or thoughtful work.
This could be tasks like updating the version of a node package or fixing a misspelling.

Bugs
Bugs are problems that occurred with an application.
These could be overt problems, like the application crashing.
Or they could be quality issues, such as a certain page taking too long to run.

When you add a bug as an issue, it's important to be detailed about where and how the bug occurs.

Feature requests
Feature requests are issues that request the addition of some new or improved functionality.
These could be crucial features, or they could be quality-of-life features, like allowing for changing a color scheme.

It's natural for some features to be a higher priority than others.

Issue options
Each issue has a number of components.
It's important to be able to understand different aspects of an issue so that you can create new ones and reference them.
To explore these components, take a look at the labeled image above.

Then read more about each section below:
The issue heading contains the name of an individual issue as well as a number. You can link back to this issue by referencing that number in your projects or pull requests.
The description section of the issue allows the creator to describe what the issue is and give as much context as they like. In this section, you can also see a timeline of what has occurred related to the issue.
The sidebar contains a number of ways to categorize the issue. You can assign an issue to a particular person, or give it a label to help organize it further. You can also associate the issue with a specific project, milestone, or pull request.
The comments section provides a space to add additional comments. These comments could detail your progress on the issue, or they could be a way to ask questions about an issue that someone else made.

**** writing user stories

User story An application or product feature written from the perspective of a particular user

Introduction to user stories
Feature requests are different from other types of cards that you might write because they often don't include implementation details.
That is, whereas a chore or bug might have exact steps, a feature requires a certain amount of creativity on your part as a developer.
Because of this, feature requests are written a bit differently than other cards.
One way to write feature requests is to write them as user stories, from the perspective of a user rather than a developer.

What is a user story?
A user story is an application or product feature written from the perspective of a particular user.
User stories are the first attempt that a developer makes at trying to determine what the product needs to be in its purest form.
A complete and full list of user stories should fully describe the application—without describing the implementation.

These constraints are important for a couple of reasons:
Well-written user stories keep the focus on the user and their needs, as opposed to the developer's limitations.
With the end goal defined but not the implementation, teams can come up with creative and collaborative solutions as they work.

Take a look at an example. A user story might be written as follows:
As a new user, I want to be able to view and compare subscription pricing so that I can decide which plan is best for me.

Below is a breakdown of what this user story does:
It describes the feature from the perspective of a particular type of user, including what they want to be able to do and why they want to be able to do it.
It uses specific verbs (view and compare) that describe what needs to be accomplished.
It doesn't describe how the feature needs to be implemented.

To accomplish this user story, you could create a separate page, a dialog, or something else. Typically, the actual implementation details are decided in collaboration with other people on the team.

User story format
User stories usually follow a consistent pattern.
As a [type of user], I want [to accomplish or solve something] so that [reason behind the feature].
Each of the sections between the brackets [] are important, and they're worth defining precisely and concisely.

Types of users
One of the most significant oversights that can happen at this stage of the design process is to assume that your perspective on a product is the only possible perspective.

In fact, all projects must consider at least the following three types of users:
New users
Returning users
Administrators

The first two are easy to understand, but be aware that there can be multiple variants of each new and returning user type. Meanwhile, administrators tend to represent the company paying you to do the work. Administrators may spend more time interacting with your product each day than all the other users combined.

Feature descriptions
The "I want" part of a user story typically needs to involve one or two verbs that describe an action that someone wants to take. For example, "As a new user, I want a free account" is not an actionable user story; it only describes a want.

Instead, focus on picking precise actions for your user stories. You can also include a constraint to help describe a feature. For example, "I want to be able to buy a product" is different than "I want to be able to buy a product in as few clicks as possible."

Here are a few examples of feature descriptions:
I want to be able to sort my contacts by first and last name.
I want to be able to purchase a product in as few clicks as possible.
I want to be able to use keyboard shortcuts to navigate around my dashboard.

Purpose-driven features
When developers create a product, they sometimes neglect to consider why a feature is important; the developers may just focus on the feature itself. However, clearly defining the reason why a feature exists is often the best way to come up with more creative and successful solutions.

Take a look at the following user story:
As a frequent user, I want to be able to sign up for a newsletter so that I can stay up to date on what new content is being posted to the website.
This user story is well written and fits the defined format. But do you notice how the first part of the story is in conflict with the last part? If a user is frequently reading the website, why would they want more updates on what content is available?
Writing the "why" often leads to conversations like this. It doesn't mean that the story is wrong; instead, it means it might need clarification or further research.
Perhaps the development team completing this feature would decide that frequent users don't need to sign up for content updates, but instead should see a reminder of a paid service. Or, maybe the development team would tweak the message specifically for frequent users.

Compare the story above to the same story without the "why" behind it:
As a frequent user, I want to be able to sign up for a newsletter.

This user story feels different; here, a task is being given without much context. As a developer, you might just complete the task and move on—without addressing the actual needs of the user.

**** pair programming

Pair programming The practice of working on a single problem with a peer, in one shared workspace

What is pair programming?
Pair programming, also called pairing, is the practice of working on a single problem with a peer, in one shared workspace.
Pair programming typically looks like two developers sitting down at one computer.
One developer will have their hands on the keyboard while the other will be sitting nearby, as the two work together to solve the same problem.
Some companies use pair programming for 100% of their work, others never use it, and still others use it for specific occasions like onboarding new developers.

Why use pair programming?
Proponents of pair programming say that there are many benefits.
Here are some of the most commonly cited benefits:
Increased code quality because the developers must communicate out loud as they program
Better transfer of skills from one developer to another
Improved resiliency to interruption or distraction, because disrupting the process means disrupting two people instead of one

Despite these benefits, pair programming isn't perfect.
This practice is often difficult, and it can turn into a negative experience for some people.
Later on in this lesson, you'll learn about ways to create a positive pairing environment.

Driving and navigating
In pair programming, there are two distinct roles: the driver and the navigator. Both have access to a keyboard, but the driver does most of the typing. Pairs should discuss a problem and agree on a rough solution. Then the driver is responsible for implementing it.

The navigator is responsible for keeping the larger picture in mind and guiding the driver in the right direction. The navigator also watches for syntax errors, thinks about solutions to the problems that the pair is solving, and researches questions in the background. If the navigator wants to type something, the best practice is to ask permission before doing so. Generally, the navigator should not dictate code word by word; instead, they should provide general directions that the driver then implements.

Pairing sessions
For most of the pairing sessions that you'll participate in during this program, you'll pair either with other students or with a mentor. Although these two scenarios will be different, there are common processes to follow throughout.

Starting a pairing session
Begin by determining who will be the driver and who will be the navigator. Clearly define a point when you will switch roles. Then discuss the tasks that you need to complete, and pick a place to start.

From the very beginning, it's easy to fall into a few traps. Watch out for the following issues:

The more experienced developer shouldn't take over, no matter if they are driving or navigating. The goal is to work together and share knowledge.

When you're the navigator, you aren't taking a break. The role of the navigator is to catch small issues, help brainstorm solutions, and look up syntax. Regardless of your role, be an active participant.

If either one of you is uncertain about where to begin or what is going on, then you should discuss the problem further. No one should be left behind.

It's important to stay engaged, no matter who you're working with. Ask questions, offer to be the driver, and do your best to stay focused.

During a pairing session
Aim to switch who is driving and who is navigating about every 30 minutes, or at another reasonable stopping place. Switching roles gives you both a chance to take a step back to consider what you've done and what you'll do next. And it's a way to make sure that both members of a pair understand what you're building.

If you aren't working on the same computer, the driver should push their work to GitHub when you switch, and the navigator should pull down that work. The new driver should start by reviewing what was done and discussing the plan for the next session.

It's also important to be direct with your partner throughout your pairing session. Because you set a baseline at the beginning of the session for what good communication means to you, you can bring it up with your partner if things have strayed from that baseline. Make sure to communicate your thoughts if you feel that the pairing isn't working effectively, or if you're struggling to work together effectively for any significant reason.

Finishing a pairing session
Remember that one of the most valuable aspects of this program is the steady flow of feedback that you get. Take five minutes at the end of the session to debrief with your partner.

You should both mention one thing that the other person did well during the session and one thing that they can improve on. Make sure to thank each other for the feedback and for working together for the session. And as you get this feedback from your partner, it's important to use this time to reflect on the feedback received and address any changes that you could implement to make future sessions more efficient.

Being a great partner
Be patient with your partner if one of you is having an easier time understanding the session's work. Don't feel too embarrassed if your partner takes on the role of teacher for the session. And if you have experience with a topic, don't work ahead if your partner doesn't understand what you're doing. At no point should either of you feel as though you aren't contributing to the project or learning something new.

When you're giving feedback, choose your words with care and make sure to say what you actually mean. And when you're receiving feedback, assume the best of your partner. They almost certainly intend to help you be productive and improve your skills, though every suggestion might not come out quite right. If you feel that your partner isn't being sensitive to your needs—for example, by driving for an entire session—speak up! Your partner is learning this new skill, too. Make sure that you bring up your concerns with specific feedback.

As you work, explain what you're implementing and specify why you are making each decision.

Pairing remotely
Working remotely makes it harder to understand someone, particularly if there's any subtlety to something that they're expressing. Aim to overcommunicate and be incredibly explicit about what you're doing and how you're feeling. When you're sitting next to someone, you might recognize when they're starting to get tired—but that's much harder to intuit remotely. Remember to take some short breaks if you or your partner are feeling burnt out.

Make sure that you have headphones that you're comfortable wearing for long periods. Headphones will reduce audio feedback and make it easier to hear each other.

*** module 9

*** unsorted

1. Understand the problem - aka "reflect the question back into your our words."
    -  Do you understand all the words used in stating the problem?
    -  What are you asked to find or show?
    -  Can you restate the problem in your own words?
    -  Can you think of a picture or diagram that might help you understand the problem?
    -  Is there enough information to enable you to find a solution?

2. Devise a plan - aka "Pseudocode"
    * Guess and check           |   * Look for a pattern
    * Make an orderly list      |   * Draw a picture
    * Eliminate possibilities   |   * Solve a simpler problem
    * Use symmetry              |   * Use a model
    * Consider special cases    |   * Work backwards
    * Use direct reasoning      |   * Use a formula
    * Solve an equation         |   * Be ingenious

3. Carry out the plan - aka "code your Pseudocode"
    * Third. Carry out your plan.
    * Carrying out your plan of the solution, check each step. Can you see clearly that the step is correct? Can you prove that it is correct?

4. Look back - aka "refactor"
    * Fourth. Examine the solution obtained.
    * Can you check the result? Can you check the argument?
    * Can you derive the solution differently? Can you see it at a glance?
    * Can you use the result, or the method, for some other problem?

Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly
