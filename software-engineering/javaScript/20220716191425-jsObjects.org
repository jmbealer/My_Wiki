:PROPERTIES:
:ID:       75a7ea1f-4030-407b-920a-4b8b11369b93
:END:
#+title: jsObjects
#+date: [2022-07-16 Sat 19:14]


JavaScript objects is an unordered collection of properties.
JavaScript object is a built-in data type for storing key-value pairs.

JavaScript properties are key-value pairs of an object.

Common practice to declare objects with the const keyword.

A JavaScript object literal is enclosed with curly braces {}.
Values are mapped to keys in the object with a colon (:), and the key-value pairs are separated by commas.
All the keys are unique, but values are not.

js Objects syntax:
object = {key: value};
object.key;
object["key"];

** destructuring and rest thinkful

Deep destructuring The process of destructuring multiple levels of an array or other object
Destructuring The process of unpacking the properties or values in an array or other object and assigning them into distinct variables
Rest operator An operator that condenses entries in arrays and other objects

Destructuring objects


Now, take a moment to examine the object in the code sample below.
const product = {
  title: "The Golden Compass",
  priceInCents: 799,
  author: {
    firstName: "Philip",
    surname: "Pullman",
  },
};

When working with an object, you'll often need to use some, but not all, of the available keys.

Consider this example:
function printAuthorAndTitle(product) {
  return `${product.title} by ${product.author.firstName} ${product.author.surname}`;
}

The above function works just fine.
However, the return statement ends up being a bit long because you have to repeat the product variable multiple times.
In this case, you might update the above function to the one below, hoping to make it easier to read:

function printAuthorAndTitle(product) {
  const author = product.author;
  const title = product.title;
  return `${title} by ${author.firstName} ${author.surname}`;
}

The second function is more legible than the first.
But it still looks clunky; after all, the product variable continues to be repeated multiple times.
Fortunately, there's another option: destructuring.
When you destructure an object or array, you're unpacking the properties or values and assigning them into distinct variables.

Take a look at the following version of the function above, which makes use of destructuring. What do you notice?

function printAuthorAndTitle(product) {

  const { author, title } = product;

  return `${title} by ${author.firstName} ${author.surname}`;

}

In this example, two new const variables are being created: author and title.

Notice how these new variables are wrapped in curly brackets {} before the = sign.
This is the destructuring syntax.
Those variables are set to whatever keys can be found inside of the product object.
If a key isn't found, it will be set to undefined.

Take a look:
const { yearPublished } = product;
console.log(yearPublished); //> undefined
Because product doesn't contain a yearPublished key, undefined would be logged to the console.

And what's more, you can destructure multiple levels into an object. Check it out.

function printAuthorAndTitle(product) {
  const {
    author: { firstName, surname },
    title,
  } = product;
  return `${title} by ${firstName} ${surname}`;
}

In the above function, the author key, which also points to an object, is further destructured to access the firstName and surname keys.
Note that there is no author variable in this function.
The only variables that are created are firstName, surname, and title.

Do this
Destructure an object

Take a look at the following object. Practice destructuring all of the keys from this object.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

When you're done, you can compare your work to this solution:

const {name} = author;

const firstName = name.firstName;

const surname = name.surname

console.log(firstName); //> 'Philip'

console.log(surname); //> 'Pullman'

Missing keys

Review the following code. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};


const { firstName } = author;

console.log(firstName);

As you can see, firstName ends up being undefined because the author object doesn't have a key called firstName. The firstName key belongs to the nested object that the name key points to.

Deep destructuring
Examine the code sample below. What do you expect will happen? Make a prediction, and then run the code for yourself.

const author = {
  name: {
    firstName: "Philip",
    surname: "Pullman",
  },
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;
console.log(firstName);
console.log(name);

In this case, firstName will be printed out as "Philip". But trying to print name will cause a ReferenceError.

When you use the syntax above to do deep destructuring, you're able to dive into and unpack multiple levels of an object. However, you won't have access to every value along the way. Furthermore, deep destructuring can cause some issues if the key is missing.

For example, take a look at the code below.

const author = {
  birthday: "1946-10-19",
};

const {
  name: { firstName },
} = author;

If you run this code, you will receive the following error:

Uncaught TypeError: Cannot read property 'firstName' of undefined

If you use deep destructuring, you'll need to make sure that the inputted object or array is of the right shape. This will help prevent errors like this one.
Destructuring arrays

As you know, objects are accessed by their keys. Arrays, on the other hand, are accessed by their index. In the above example, object keys were used to destructure objects and create variables. The process for arrays is similar, except that you'll use those specific positions in the array to create the variables. To begin, check out the array below:

const genres = [
  "Fantasy",
  "Fiction",
  "Nonfiction",
  "Science Fiction",
  "Young Adult",
];

You can destructure this array by doing the following:

const [first, second] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'

In the above example, two new variables are created: first and second. Those variable names are set to the elements at index 0 and index 1. The rest of the elements are ignored.
Do this
Destructure an array

Take a look at the following array. Practice destructuring the first, second, and third values from this array.

const authors = [
  "Ursula K. Le Guin",
  "Brandon Sanderson",
  "Terry Pratchett",
  "Neil Gaiman",
  "J. R. R. Tolkien",
];

const [first, second, third] = authors;

The rest operator

As you've seen, destructuring is an extremely valuable tool. But that being said, destructuring an array on its own is only so useful. It's much more useful when it pairs up with another tool: the rest operator.
Take a look at the code sample below. What do you notice?

const [first, second, ...otherGenres] = genres;
console.log(first); //> 'Fantasy'
console.log(second); //> 'Fiction'
console.log(otherGenres); //> [ 'Nonfiction', 'Science Fiction', 'Young Adult' ]

In this example, there are two variables: first and second. Those are followed by the syntax that makes up the rest operator: the three periods ... and a variable name, which in this case is otherGenres. The variable that follows ... will contain all of the remaining array elements that weren't destructured. This can be very useful for splitting apart an array.
Destructuring parameters

You can also use destructuring in functions in order to destructure the parameters. Take a look at this example:

function printAuthorAndTitle({ author, title }) {

  return `${title} by ${author.firstName} ${author.surname}`;

}


printAuthorAndTitle(product); //> 'The Golden Compass by Philip Pullman'

The above syntax, once understood, is useful for at least two reasons:

    You know that the expected input into the function is an object.

    The function is concise and easy to read.

However, there is a downside to this approach: if you need to access the entire inputted object, you have no way to do so.

object destructuring
quickly extract prop values from objects and assign to local variable.
commonly used to aid readability.
const car = {
  make: "Toyota",
  model: "Corolla",
  drive() {
    console.log("The car is driving!");
  }
}

// Destructure values from car
const {make, model, drive, numberOfWheels} = car;

console.log(make); // "Toyota"
console.log(model); // "Corolla"
drive(); // The care is driving!
console.log(numberOfWheels); // undefined

peculiarities of accessing objects
const littleYacht = {
  floorColor: "red",
  maximumLbs: 1000,
  inOperation: true,
  christened: false,
  hornSound: "Ride of the Walkeries",
  "Dock Name": "oceania",
  //Dock Name: "oceania",

  playHorn: function() {
    console.log(littleYacht.hornSound);
  }
};

console.log(littleYacht.floorColor);
console.log(littleYacht["floorColor"]);
// console.log(littleYacht[floorColor]);

console.log(littleYacht["Dock Name"]);
// console.log(littleYacht.Dock Name);

the in operator
check existence of a key in an object:
const myObj = {
  color: "red",
  shape: "circle",
  size: "4cm"
}

console.log("shape" in myObj); // => true
console.log("height" in myObj); // => false

methods are properties of objects which are functions
const car = {
  make: "Toyota",
  model: "Corolla",
  // this is a method
  drive() {
    console.log("The car is driving!");
  },
  // it's shorthand for this
  useHorn: function() {
    console.log("Beep");
  }
}

car.drive(); // Logs out "The car is driving!"
car.useHorn(); // Logs out "Beep"

** object shorthand and spread thinkful

Object shorthand JavaScript syntax that supports the creation of objects using values stored in variables, where the variable name becomes the key and the stored value becomes the value in the key-value pair
Spread operator An operator that expands entries in arrays and other objects

Object shorthand
Newer versions of JavaScript have made it even easier for you to streamline your code by allowing you to create object shorthands.
Object shorthand syntax means that you can create objects using values that you've stored in variables.

Take a look:
const title = "Infernal Devices";
const author = "K.W. Jeter";
const book = { title, author };

Notice that in the above code, there is no colon : symbol to distinguish a key from a value. So, what are the keys and values of this object?

console.log(book); //> { title: "Infernal Devices", author: "K.W. Jeter" }

Here, JavaScript takes the name of the variable and sets that to be the key. It then sets the value to be whatever is stored in that variable. This works with more complicated data types, as well.

const product = { book, priceInCents: 1950 };

With this shorthand tool, you can write cleaner code. The above code would result in the following:

{
  book: {
    title: "Infernal Devices",
    author: "K.W. Jeter",
  },
  priceInCents: 1950,
};

The spread operator
The spread operator allows you to easily combine arrays and objects without a lot of complicated code.
For example, with what you know now, how would you go about combining the following two arrays?

const ownedBooks = ["Infernal Devices", "Foundation"];
const wishlist = ["Good Omens", "Guards! Guards!"];

At first glance, you'd probably see that you could loop through one array and push each item into the other, or you could use the concat() method, which you can learn more about in MDN's array documentation.
And yet, it can be even easier than that.

Review the code below. What do you notice?

const allBooks = [...ownedBooks, ...wishlist];
//> [ "Infernal Devices", "Foundation", "Good Omens", "Guards! Guards!" ]

Do you see the three periods ...?
When ... is used with an existing array on the right side of the = sign, it will expand the entries inside of that array.
In the above case, both arrays are expanded into a new array, so that all of the array elements appear next to one another.

This can also be accomplished with objects, as follows:

const salesTax = { state: "Washington", tax: 0.065 };
const sale = { ...product, ...salesTax };
/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 1950,
    state: "Washington",
    tax: 0.065
  };
*/

In the example above, the product object contains the book key and the priceInCents key.
The salesTax object contains the state and tax keys.
Those keys are all placed into a new object in the variable sale.
Note how the book object wasn't expanded; the spread operator expands only one level deep.

You also can overwrite keys in an object where you're using shorthand. You can do this by simply using the key once again. Take a look:

const sale = {
  ...product,
  ...salesTax,
  priceInCents: product.priceInCents * (1 + salesTax.tax),
};

/*
  {
    book: {
      title: "Infernal Devices",
      author: "K.W. Jeter",
    },
    priceInCents: 2076.75,
    state: "Washington",
    tax: 0.065
  };
*/

In the above example, the product and salesTax values are expanded with the spread operator, just like before. But this time, the priceInCents key is added to overwrite the priceInCents key that was stored in the product variable.


Property value shorthand (for Objects)
A convenient shorthand method for creating an object if your local variable name matches the new object's key

// Function that returns a new 'cat' object:
function createCat(name) {
  const color = getRandomColor();

  return {
    eyes: 2,
    legs: 4,
    name,     // same as name: name
    color,    // same as color: color
  };
}

const myCat = createCat('tabby');

example:
{
  eyes: 2,
  legs: 4,
  name: 'tabby',
  color: 'blue'
}


Spread operator (...) with objects
    Helps us manage merging objects
    Creates a new object
    Be aware of the order in which merging is done

const littleYacht = {
    "Dock Name": "oceania",
    floorColor: "red",
    christened: false,
    hornSound: "Ride of the Walkeries",
    playHorn() {
        console.log(littleYacht.hornSound);
    }
};

const littleYacht2 = {
    roofColor: "green",  // new key, will be added
    christened: true     // duplicate key, will be overwritten
};

const newYacht = { ...littleYacht, ...littleYacht2 };

The this keyword
    (Generally) used in methods to refer to properties of an object
    Don't need to know the variable name of the object itself

const littleYacht = {
    hornSound: "Ride of the Walkeries",
    playHorn: function() {
      // Equivalent to littleYacht.hornSound
      console.log(this.hornSound);
    }
};

littleYacht.playHorn(); // Ride of the Walkeries


What does this refer to?
    this is assigned a value at the moment the method is invoked, and not when it is defined
    this is assigned to the object to the left of the dot when the function was called

const littleYacht = {
  hornSound: "Ride of the Walkeries",
  playHorn: function() {
    console.log(this.hornSound);
  }
};

littleYacht.playHorn(); // Ride of the Walkeries

const biggerYacht = {
  hornSound: "Fog Horn",
  playHorn: littleYacht.playHorn
};

biggerYacht.playHorn(); // Fog Horn
** objects methods

Object Methods

Objects can also have methods.

Methods are actions that can be performed on objects.

Methods are stored in properties as function definitions.
Property 	Property Value
firstName 	John
lastName 	Doe
age 	50
eyeColor 	blue
fullName 	function() {return this.firstName + " " + this.lastName;}

A method is a function stored as a property.
Example
const person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

In the example above, this refers to the person object.

I.E. this.firstName means the firstName property of this.

I.E. this.firstName means the firstName property of person.

What is this?

In JavaScript, the this keyword refers to an object.

Which object depends on how this is being invoked (used or called).

The this keyword refers to different objects depending on how it is used:
In an object method, this refers to the object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.
In an event, this refers to the element that received the event.
Methods like call(), apply(), and bind() can refer this to any object.
Note
this is not a variable. It is a keyword. You cannot change the value of this.
See Also:

The this Keyword

In a function definition, this refers to the "owner" of the function.

In the example above, this is the person object that "owns" the fullName function.

In other words, this.firstName means the firstName property of this object.

Learn more about this in The JavaScript this Tutorial.
Accessing Object Methods

You access an object method with the following syntax:
objectName.methodName()
Example
name = person.fullName();

If you access a method without the () parentheses, it will return the function definition:
Example
name = person.fullName;
Do Not Declare Strings, Numbers, and Booleans as Objects!

When a JavaScript variable is declared with the keyword "new", the variable is created as an object:
x = new String();        // Declares x as a String object
y = new Number();        // Declares y as a Number object
z = new Boolean();       // Declares z as a Boolean object

Avoid String, Number, and Boolean objects. They complicate your code and slow down execution speed.

You will learn more about objects later in this tutorial.
Test Yourself With Exercises
Exercise:

Alert "John" by extracting information from the person object.

const person = {
  firstName: "John",
  lastName: "Doe"
};

alert();


Start the Exercise

Prevent Object Mutation

As seen in the previous challenge, const declaration alone doesn't really protect your data from mutation. To ensure your data doesn't change, JavaScript provides a function Object.freeze to prevent data mutation.

Any attempt at changing the object will be rejected, with an error thrown if the script is running in strict mode.

let obj = {
  name:"FreeCodeCamp",
  review:"Awesome"
};
Object.freeze(obj);
obj.review = "bad";
obj.newProp = "Test";
console.log(obj);

The obj.review and obj.newProp assignments will result in errors, because our editor runs in strict mode by default, and the console will display the value { name: "FreeCodeCamp", review: "Awesome" }.

In this challenge you are going to use Object.freeze to prevent mathematical constants from changing. You need to freeze the MATH_CONSTANTS object so that no one is able to alter the value of PI, add, or delete properties.
** accessing objects
Accessing Object Properties with Dot Notation
There are two ways to access the properties of an object: dot notation (.) and bracket notation ([]), similar to an array.
Dot notation is what you use when you know the name of the property you're trying to access ahead of time.


Accessing Object Properties with Bracket Notation
The second way to access the properties of an object is bracket notation ([]). If the property of the object you are trying to access has a space in its name, you will need to use bracket notation.
However, you can still use bracket notation on object properties without spaces.


Note that property names with spaces in them must be in quotes (single or double).
Read the values of the properties an entree and the drink of testObj using bracket notation and assign them to entreeValue and drinkValue respectively.

Accessing Object Properties with Variables
Another use of bracket notation on objects is to access a property which is stored as the value of a variable. This can be very useful for iterating through an object's properties or when accessing a lookup table.
Here is an example of using a variable to access a property:
const dogs = {
  Fido: "Mutt",
  Hunter: "Doberman",
  Snoopie: "Beagle"
};
const myDog = "Hunter";
const myBreed = dogs[myDog];
console.log(myBreed);
The string Doberman would be displayed in the console.
Another way you can use this concept is when the property's name is collected dynamically during the program execution, as follows:
const someObj = {
  propName: "John"
};
function propPrefix(str) {
  const s = "prop";
  return s + str;
}
const someProp = propPrefix("Name");
console.log(someObj[someProp]);
someProp would have a value of the string propName, and the string John would be displayed in the console.
Note that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name.
Set the playerNumber variable to 16. Then, use the variable to look up the player's name and assign it to player.

Updating Object Properties
After you've created a JavaScript object, you can update its properties at any time just like you would update any other variable. You can use either dot or bracket notation to update.
For example, let's look at ourDog:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
Since he's a particularly happy dog, let's change his name to the string Happy Camper. Here's how we update his object's name property: ourDog.name = "Happy Camper"; or ourDog["name"] = "Happy Camper"; Now when we evaluate ourDog.name, instead of getting Camper, we'll get his new name, Happy Camper.
Update the myDog object's name property. Let's change her name from Coder to Happy Coder. You can use either dot or bracket notation.

Add New Properties to a JavaScript Object
You can add new properties to existing JavaScript objects the same way you would modify them.
Here's how we would add a bark property to ourDog:
ourDog.bark = "bow-wow";
or
ourDog["bark"] = "bow-wow";
Now when we evaluate ourDog.bark, we'll get his bark, bow-wow.
Example:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
ourDog.bark = "bow-wow";
Add a bark property to myDog and set it to a dog sound, such as "woof". You may use either dot or bracket notation.
Using Objects for Lookups
Objects can be thought of as a key/value storage, like a dictionary. If you have tabular data, you can use an object to lookup values rather than a switch statement or an if/else chain. This is most useful when you know that your input data is limited to a certain range.
Here is an example of a simple reverse alphabet lookup:
const alpha = {
  1:"Z",
  2:"Y",
  3:"X",
  4:"W",
  ...
  24:"C",
  25:"B",
  26:"A"
};
alpha[2];
alpha[24];
const value = 2;
alpha[value];
alpha[2] is the string Y, alpha[24] is the string C, and alpha[value] is the string Y.
Convert the switch statement into an object called lookup. Use it to look up val and assign the associated string to the result variable.

Manipulating Complex Objects
Sometimes you may want to store data in a flexible Data Structure. A JavaScript object is one way to handle flexible data. They allow for arbitrary combinations of strings, numbers, booleans, arrays, functions, and objects.
Here's an example of a complex data structure:
const ourMusic = [
  {
    "artist": "Daft Punk",
    "title": "Homework",
    "release_year": 1997,
    "formats": [
      "CD",
      "Cassette",
      "LP"
    ],
    "gold": true
  }
];
This is an array which contains one object inside. The object has various pieces of metadata about an album. It also has a nested formats array. If you want to add more album records, you can do this by adding records to the top level array. Objects hold data in a property, which has a key-value format. In the example above, "artist": "Daft Punk" is a property that has a key of artist and a value of Daft Punk.
Note: You will need to place a comma after every object in the array, unless it is the last object in the array.
Add a new album to the myMusic array. Add artist and title strings, release_year number, and a formats array of strings.

Accessing Nested Objects
The sub-properties of objects can be accessed by chaining together the dot or bracket notation.
Here is a nested object:
const ourStorage = {
  "desk": {
    "drawer": "stapler"
  },
  "cabinet": {
    "top drawer": {
      "folder1": "a file",
      "folder2": "secrets"
    },
    "bottom drawer": "soda"
  }
};
ourStorage.cabinet["top drawer"].folder2;
ourStorage.desk.drawer;
ourStorage.cabinet["top drawer"].folder2 would be the string secrets, and ourStorage.desk.drawer would be the string stapler.
Access the myStorage object and assign the contents of the glove box property to the gloveBoxContents variable. Use dot notation for all properties where possible, otherwise use bracket notation.
** deleting properties

Delete Properties from a JavaScript Object
We can also delete properties from objects like this:
delete ourDog.bark;
Example:
const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"],
  "bark": "bow-wow"
};
delete ourDog.bark;
After the last line shown above, ourDog looks like:

{
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
}
Delete the tails property from myDog. You may use either dot or bracket notation.

** objects examples
#+begin_src js
// create an empty object
const object = {}; // empty object
// create an object
const object = {key: value};
// create an object with multiple keys
const object = {key1: value1, key2: value2};
// create an object with multiple keys that span multiple lines.
const object = {
    key1: value1,
    key2: value2
};
// create an object with nested values foo and bar
const object = {key: ["foo", "bar"]};
// return an object value with dot
object.key; // return value
// add a key to object with dot
object.newKey = "newValue"; // adds newKey with newValue to object.
// update key to a new value with dot
object.key = "newValue"; // change key to newValue in object
// return an object value with brackets
object[key]; // return value
// access object value when key has spaces
object["key two"]; // return value
// add a key to object with brackets
object["newKey"] = "newValue"; // adds newKey with newValue to object.
// update key to a new value with brackets
object["oldKey"] = "newValue"; // change key to newValue in object

// nested key
const object = {
    key: {
        nestedKey: {
            nKey2: 111
        }
    }
};
object.key.nestedKey.nKey2;
object["key"]["nestedKey"]["nKey2"];
object.key.nestedKey.["nKey2"] = 222;
#+end_src

arr = [
  { key0: "val0", key1: "val1"}
]
arr[0].key1

bracket variables
let var = "oldKey";
obj[var]; // oldValue
